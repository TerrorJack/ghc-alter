<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Vectorise.Exp</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Vectorise-Exp.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">ghc-8.3: The GHC API</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Vectorise.Exp</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Vectorise right-hand sides of toplevel bindings</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Vectorisation of expressions.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:vectTopExpr">vectTopExpr</a> :: <a href="Var.html#t:Var">Var</a> -&gt; <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a> -&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> (<a href="../base-4.10.0.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a>, <a href="Vectorise-Utils-Hoisting.html#t:Inline">Inline</a>, <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a>))</li><li class="src short"><a href="#v:vectTopExprs">vectTopExprs</a> :: [(<a href="Var.html#t:Var">Var</a>, <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a>)] -&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> (<a href="../base-4.10.0.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a>, [(<a href="Vectorise-Utils-Hoisting.html#t:Inline">Inline</a>, <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a>)]))</li><li class="src short"><a href="#v:vectScalarFun">vectScalarFun</a> :: <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a> -&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> <a href="Vectorise-Vect.html#t:VExpr">VExpr</a></li><li class="src short"><a href="#v:vectScalarDFun">vectScalarDFun</a> :: <a href="Var.html#t:Var">Var</a> -&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a></li></ul></div><div id="interface"><h1 id="g:1">Vectorise right-hand sides of toplevel bindings</h1><div class="top"><p class="src"><a id="v:vectTopExpr" class="def">vectTopExpr</a> :: <a href="Var.html#t:Var">Var</a> -&gt; <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a> -&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> (<a href="../base-4.10.0.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a>, <a href="Vectorise-Utils-Hoisting.html#t:Inline">Inline</a>, <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a>)) <a href="src/Vectorise-Exp.html#vectTopExpr" class="link">Source</a> <a href="#v:vectTopExpr" class="selflink">#</a></p><div class="doc"><p>Vectorise a polymorphic expression that forms a *non-recursive* binding.</p><p>Return <code><a href="../base-4.10.0.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if the expression is scalar; otherwise, the first component of the result
 (which is of type <code><a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a></code>) indicates whether the expression is parallel (i.e., whether it is
 tagged as <code>VIParr</code>).</p><p>We have got the non-recursive case as a special case as it doesn't require to compute
 vectorisation information twice.</p></div></div><div class="top"><p class="src"><a id="v:vectTopExprs" class="def">vectTopExprs</a> :: [(<a href="Var.html#t:Var">Var</a>, <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a>)] -&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> (<a href="../base-4.10.0.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a>, [(<a href="Vectorise-Utils-Hoisting.html#t:Inline">Inline</a>, <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a>)])) <a href="src/Vectorise-Exp.html#vectTopExprs" class="link">Source</a> <a href="#v:vectTopExprs" class="selflink">#</a></p><div class="doc"><p>Vectorise a recursive group of top-level polymorphic expressions.</p><p>Return <code><a href="../base-4.10.0.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if the expression group is scalar; otherwise, the first component of the result
 (which is of type <code><a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a></code>) indicates whether the expressions are parallel (i.e., whether they are
 tagged as <code>VIParr</code>).</p></div></div><div class="top"><p class="src"><a id="v:vectScalarFun" class="def">vectScalarFun</a> :: <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a> -&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> <a href="Vectorise-Vect.html#t:VExpr">VExpr</a> <a href="src/Vectorise-Exp.html#vectScalarFun" class="link">Source</a> <a href="#v:vectScalarFun" class="selflink">#</a></p><div class="doc"><p>Vectorise an expression of functional type, where all arguments and the result are of primitive
 types (i.e., <code><a href="../base-4.10.0.0/Data-Int.html#t:Int">Int</a></code>, <code><a href="../base-4.10.0.0/Prelude.html#t:Float">Float</a></code>, <code><a href="../base-4.10.0.0/Prelude.html#t:Double">Double</a></code> etc., which have instances of the <code>Scalar</code> type class) and
 which does not contain any subcomputations that involve parallel arrays.  Such functionals do not
 require the full blown vectorisation transformation; instead, they can be lifted by application
 of a member of the zipWith family (i.e., <code><a href="../base-4.10.0.0/GHC-OldList.html#v:map">map</a></code>, <code><a href="../base-4.10.0.0/GHC-OldList.html#v:zipWith">zipWith</a></code>, zipWith3', etc.)</p><p>Dictionary functions are also scalar functions (as dictionaries themselves are not vectorised,
 instead they become dictionaries of vectorised methods).  We treat them differently, though see
 &quot;Note [Scalar dfuns]&quot; in <code>Vectorise</code>.</p></div></div><div class="top"><p class="src"><a id="v:vectScalarDFun" class="def">vectScalarDFun</a> <a href="src/Vectorise-Exp.html#vectScalarDFun" class="link">Source</a> <a href="#v:vectScalarDFun" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Var.html#t:Var">Var</a></td><td class="doc"><p>Original dfun</p></td></tr><tr><td class="src">-&gt; <a href="Vectorise-Monad-Base.html#t:VM">VM</a> <a href="CoreSyn.html#t:CoreExpr">CoreExpr</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Vectorise a dictionary function that has a 'VECTORISE SCALAR instance' pragma.</p><p>In other words, all methods in that dictionary are scalar functions &#8212; to be vectorised with
 <code><a href="Vectorise-Exp.html#v:vectScalarFun">vectScalarFun</a></code>.  The dictionary &quot;function&quot; itself may be a constant, though.</p><p>NB: You may think that we could implement this function guided by the structure of the Core
     expression of the right-hand side of the dictionary function.  We cannot proceed like this as
     <code><a href="Vectorise-Exp.html#v:vectScalarDFun">vectScalarDFun</a></code> must also work for *imported* dfuns, where we don't necessarily have access
     to the Core code of the unvectorised dfun.</p><p>Here an example &#8212; assume,</p><pre>class Eq a where { (==) :: a -&gt; a -&gt; Bool }
instance (Eq a, Eq b) =&gt; Eq (a, b) where { (==) = ... }
{-# VECTORISE SCALAR instance Eq (a, b) }</pre><p>The unvectorised dfun for the above instance has the following signature:</p><pre>$dEqPair :: forall a b. Eq a -&gt; Eq b -&gt; Eq (a, b)</pre><p>We generate the following (scalar) vectorised dfun (liberally using TH notation):</p><pre>$v$dEqPair :: forall a b. V:Eq a -&gt; V:Eq b -&gt; V:Eq (a, b)
$v$dEqPair = /\a b -&gt; \dEqa :: V:Eq a -&gt; \dEqb :: V:Eq b -&gt;
               D:V:Eq $(vectScalarFun True recFns
                        [| (==) @(a, b) ($dEqPair @a @b $(unVect dEqa) $(unVect dEqb)) |])</pre><p>NB:
 * '(,)' vectorises to '(,)' &#8212; hence, the type constructor in the result type remains the same.
 * We share the '$(unVect di)' sub-expressions between the different selectors, but duplicate
   the application of the unvectorised dfun, to enable the dictionary selection rules to fire.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.2</p></div></body></html>