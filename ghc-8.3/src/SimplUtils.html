<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>simplCore/SimplUtils.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The AQUA Project, Glasgow University, 1993-1998
<a name="line-3"></a>
<a name="line-4"></a>\section[SimplUtils]{The simplifier utilities}
<a name="line-5"></a>-}</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>SimplUtils</span> <span class='hs-layout'>(</span>
<a name="line-10"></a>        <span class='hs-comment'>-- Rebuilding</span>
<a name="line-11"></a>        <span class='hs-varid'>mkLam</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase</span><span class='hs-layout'>,</span> <span class='hs-varid'>prepareAlts</span><span class='hs-layout'>,</span> <span class='hs-varid'>tryEtaExpandRhs</span><span class='hs-layout'>,</span>
<a name="line-12"></a>
<a name="line-13"></a>        <span class='hs-comment'>-- Inlining,</span>
<a name="line-14"></a>        <span class='hs-varid'>preInlineUnconditionally</span><span class='hs-layout'>,</span> <span class='hs-varid'>postInlineUnconditionally</span><span class='hs-layout'>,</span>
<a name="line-15"></a>        <span class='hs-varid'>activeUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>activeRule</span><span class='hs-layout'>,</span>
<a name="line-16"></a>        <span class='hs-varid'>getUnfoldingInRuleMatch</span><span class='hs-layout'>,</span>
<a name="line-17"></a>        <span class='hs-varid'>simplEnvForGHCi</span><span class='hs-layout'>,</span> <span class='hs-varid'>updModeForStableUnfoldings</span><span class='hs-layout'>,</span> <span class='hs-varid'>updModeForRules</span><span class='hs-layout'>,</span>
<a name="line-18"></a>
<a name="line-19"></a>        <span class='hs-comment'>-- The continuation type</span>
<a name="line-20"></a>        <span class='hs-conid'>SimplCont</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>DupFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-21"></a>        <span class='hs-varid'>isSimplified</span><span class='hs-layout'>,</span> <span class='hs-varid'>contIsStop</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-varid'>contIsDupable</span><span class='hs-layout'>,</span> <span class='hs-varid'>contResultType</span><span class='hs-layout'>,</span> <span class='hs-varid'>contHoleType</span><span class='hs-layout'>,</span>
<a name="line-23"></a>        <span class='hs-varid'>contIsTrivial</span><span class='hs-layout'>,</span> <span class='hs-varid'>contArgs</span><span class='hs-layout'>,</span>
<a name="line-24"></a>        <span class='hs-varid'>countArgs</span><span class='hs-layout'>,</span>
<a name="line-25"></a>        <span class='hs-varid'>mkBoringStop</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkRhsStop</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLazyArgStop</span><span class='hs-layout'>,</span> <span class='hs-varid'>contIsRhsOrArg</span><span class='hs-layout'>,</span>
<a name="line-26"></a>        <span class='hs-varid'>interestingCallContext</span><span class='hs-layout'>,</span>
<a name="line-27"></a>
<a name="line-28"></a>        <span class='hs-comment'>-- ArgInfo</span>
<a name="line-29"></a>        <span class='hs-conid'>ArgInfo</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>ArgSpec</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkArgInfo</span><span class='hs-layout'>,</span>
<a name="line-30"></a>        <span class='hs-varid'>addValArgTo</span><span class='hs-layout'>,</span> <span class='hs-varid'>addCastTo</span><span class='hs-layout'>,</span> <span class='hs-varid'>addTyArgTo</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-varid'>argInfoExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>argInfoAppArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushSimplifiedArgs</span><span class='hs-layout'>,</span>
<a name="line-32"></a>
<a name="line-33"></a>        <span class='hs-varid'>abstractFloats</span>
<a name="line-34"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-35"></a>
<a name="line-36"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-37"></a>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreMonad</span>        <span class='hs-layout'>(</span> <span class='hs-conid'>SimplMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreSyn</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>CoreSubst</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PprCore</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreFVs</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUtils</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreArity</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUnfold</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>IdInfo</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Demand</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>SimplMonad</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>     <span class='hs-varid'>hiding</span><span class='hs-layout'>(</span> <span class='hs-varid'>substTy</span> <span class='hs-layout'>)</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>hiding</span><span class='hs-layout'>(</span> <span class='hs-varid'>substCo</span> <span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>dataConWorkId</span><span class='hs-layout'>,</span> <span class='hs-varid'>isNullaryRepDataCon</span> <span class='hs-layout'>)</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>OrdList</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>isNilOL</span> <span class='hs-layout'>)</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MonadUtils</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pair</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelRules</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>       <span class='hs-layout'>(</span> <span class='hs-varid'>fsLit</span> <span class='hs-layout'>)</span>
<a name="line-66"></a>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>when</span> <span class='hs-layout'>)</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>sortBy</span> <span class='hs-layout'>)</span>
<a name="line-69"></a>
<a name="line-70"></a><span class='hs-comment'>{-
<a name="line-71"></a>************************************************************************
<a name="line-72"></a>*                                                                      *
<a name="line-73"></a>                The SimplCont and DupFlag types
<a name="line-74"></a>*                                                                      *
<a name="line-75"></a>************************************************************************
<a name="line-76"></a>
<a name="line-77"></a>A SimplCont allows the simplifier to traverse the expression in a
<a name="line-78"></a>zipper-like fashion.  The SimplCont represents the rest of the expression,
<a name="line-79"></a>"above" the point of interest.
<a name="line-80"></a>
<a name="line-81"></a>You can also think of a SimplCont as an "evaluation context", using
<a name="line-82"></a>that term in the way it is used for operational semantics. This is the
<a name="line-83"></a>way I usually think of it, For example you'll often see a syntax for
<a name="line-84"></a>evaluation context looking like
<a name="line-85"></a>        C ::= []  |  C e   |  case C of alts  |  C `cast` co
<a name="line-86"></a>That's the kind of thing we are doing here, and I use that syntax in
<a name="line-87"></a>the comments.
<a name="line-88"></a>
<a name="line-89"></a>
<a name="line-90"></a>Key points:
<a name="line-91"></a>  * A SimplCont describes a *strict* context (just like
<a name="line-92"></a>    evaluation contexts do).  E.g. Just [] is not a SimplCont
<a name="line-93"></a>
<a name="line-94"></a>  * A SimplCont describes a context that *does not* bind
<a name="line-95"></a>    any variables.  E.g. \x. [] is not a SimplCont
<a name="line-96"></a>-}</span>
<a name="line-97"></a>
<a name="line-98"></a><a name="SimplCont"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SimplCont</span>
<a name="line-99"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span>                <span class='hs-comment'>-- Stop[e] = e</span>
<a name="line-100"></a>        <span class='hs-conid'>OutType</span>         <span class='hs-comment'>-- Type of the &lt;hole&gt;</span>
<a name="line-101"></a>        <span class='hs-conid'>CallCtxt</span>        <span class='hs-comment'>-- Tells if there is something interesting about</span>
<a name="line-102"></a>                        <span class='hs-comment'>--          the context, and hence the inliner</span>
<a name="line-103"></a>                        <span class='hs-comment'>--          should be a bit keener (see interestingCallContext)</span>
<a name="line-104"></a>                        <span class='hs-comment'>-- Specifically:</span>
<a name="line-105"></a>                        <span class='hs-comment'>--     This is an argument of a function that has RULES</span>
<a name="line-106"></a>                        <span class='hs-comment'>--     Inlining the call might allow the rule to fire</span>
<a name="line-107"></a>                        <span class='hs-comment'>-- Never ValAppCxt (use ApplyToVal instead)</span>
<a name="line-108"></a>                        <span class='hs-comment'>-- or CaseCtxt (use Select instead)</span>
<a name="line-109"></a>
<a name="line-110"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CastIt</span>              <span class='hs-comment'>-- (CastIt co K)[e] = K[ e `cast` co ]</span>
<a name="line-111"></a>        <span class='hs-conid'>OutCoercion</span>             <span class='hs-comment'>-- The coercion simplified</span>
<a name="line-112"></a>                                <span class='hs-comment'>-- Invariant: never an identity coercion</span>
<a name="line-113"></a>        <span class='hs-conid'>SimplCont</span>
<a name="line-114"></a>
<a name="line-115"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ApplyToVal</span>         <span class='hs-comment'>-- (ApplyToVal arg K)[e] = K[ e arg ]</span>
<a name="line-116"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>      <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-117"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_arg</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InExpr</span>       <span class='hs-comment'>-- The argument,</span>
<a name="line-118"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StaticEnv</span>    <span class='hs-comment'>--     and its static env</span>
<a name="line-119"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-120"></a>
<a name="line-121"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ApplyToTy</span>          <span class='hs-comment'>-- (ApplyToTy ty K)[e] = K[ e ty ]</span>
<a name="line-122"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>     <span class='hs-comment'>-- Argument type</span>
<a name="line-123"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>     <span class='hs-comment'>-- Type of the function, presumably (forall a. blah)</span>
<a name="line-124"></a>                                  <span class='hs-comment'>-- See Note [The hole type in ApplyToTy]</span>
<a name="line-125"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-126"></a>
<a name="line-127"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Select</span>             <span class='hs-comment'>-- (Select alts K)[e] = K[ case e of alts ]</span>
<a name="line-128"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>        <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-129"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InId</span>           <span class='hs-comment'>-- case binder</span>
<a name="line-130"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- Alternatives</span>
<a name="line-131"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StaticEnv</span>      <span class='hs-comment'>--   and their static environment</span>
<a name="line-132"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-133"></a>
<a name="line-134"></a>  <span class='hs-comment'>-- The two strict forms have no DupFlag, because we never duplicate them</span>
<a name="line-135"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>StrictBind</span>          <span class='hs-comment'>-- (StrictBind x xs b K)[e] = let x = e in K[\xs.b]</span>
<a name="line-136"></a>                        <span class='hs-comment'>--       or, equivalently,  = K[ (\x xs.b) e ]</span>
<a name="line-137"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>        <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-138"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InId</span>
<a name="line-139"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InBndr</span><span class='hs-keyglyph'>]</span>
<a name="line-140"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_body</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InExpr</span>
<a name="line-141"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StaticEnv</span>
<a name="line-142"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-143"></a>
<a name="line-144"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>StrictArg</span>           <span class='hs-comment'>-- (StrictArg (f e1 ..en) K)[e] = K[ f e1 .. en e ]</span>
<a name="line-145"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>     <span class='hs-comment'>-- Always Simplified or OkToDup</span>
<a name="line-146"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span>     <span class='hs-comment'>-- Specifies f, e1..en, Whether f has rules, etc</span>
<a name="line-147"></a>                               <span class='hs-comment'>--     plus strictness flags for *further* args</span>
<a name="line-148"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cci</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CallCtxt</span>    <span class='hs-comment'>-- Whether *this* argument position is interesting</span>
<a name="line-149"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-150"></a>
<a name="line-151"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TickIt</span>              <span class='hs-comment'>-- (TickIt t K)[e] = K[ tick t e ]</span>
<a name="line-152"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>Tickish</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Tick tickish &lt;hole&gt;</span>
<a name="line-153"></a>        <span class='hs-conid'>SimplCont</span>
<a name="line-154"></a>
<a name="line-155"></a><a name="DupFlag"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoDup</span>       <span class='hs-comment'>-- Unsimplified, might be big</span>
<a name="line-156"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Simplified</span>  <span class='hs-comment'>-- Simplified</span>
<a name="line-157"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OkToDup</span>     <span class='hs-comment'>-- Simplified and small</span>
<a name="line-158"></a>
<a name="line-159"></a><a name="isSimplified"></a><span class='hs-definition'>isSimplified</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-160"></a><span class='hs-definition'>isSimplified</span> <span class='hs-conid'>NoDup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-161"></a><span class='hs-definition'>isSimplified</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>       <span class='hs-comment'>-- Invariant: the subst-env is empty</span>
<a name="line-162"></a>
<a name="line-163"></a><a name="perhapsSubstTy"></a><span class='hs-definition'>perhapsSubstTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StaticEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-164"></a><span class='hs-definition'>perhapsSubstTy</span> <span class='hs-varid'>dup</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-165"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSimplified</span> <span class='hs-varid'>dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-166"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-167"></a>
<a name="line-168"></a><span class='hs-comment'>{-
<a name="line-169"></a>Note [DupFlag invariants]
<a name="line-170"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-171"></a>In both (ApplyToVal dup _ env k)
<a name="line-172"></a>   and  (Select dup _ _ env k)
<a name="line-173"></a>the following invariants hold
<a name="line-174"></a>
<a name="line-175"></a>  (a) if dup = OkToDup, then continuation k is also ok-to-dup
<a name="line-176"></a>  (b) if dup = OkToDup or Simplified, the subst-env is empty
<a name="line-177"></a>      (and and hence no need to re-simplify)
<a name="line-178"></a>-}</span>
<a name="line-179"></a>
<a name="line-180"></a><a name="instance%20Outputable%20DupFlag"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyword'>where</span>
<a name="line-181"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>OkToDup</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ok"</span>
<a name="line-182"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>NoDup</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"nodup"</span>
<a name="line-183"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>Simplified</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"simpl"</span>
<a name="line-184"></a>
<a name="line-185"></a><a name="instance%20Outputable%20SimplCont"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyword'>where</span>
<a name="line-186"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>interesting</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Stop"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>brackets</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>interesting</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-187"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>  <span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"CastIt"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprOptCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-188"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-varid'>t</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"TickIt"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-189"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-190"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"ApplyToTy"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprParendType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-191"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-192"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"ApplyToVal"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dup</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprParendExpr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-193"></a>                                        <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-194"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-195"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"StrictBind"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-196"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-197"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"StrictArg"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_fun</span> <span class='hs-varid'>ai</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-198"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-199"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Select"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dup</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span>
<a name="line-200"></a>       <span class='hs-varid'>whenPprDebug</span> <span class='hs-layout'>(</span><span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>seTvSubst</span> <span class='hs-varid'>se</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>alts</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-201"></a>
<a name="line-202"></a>
<a name="line-203"></a><span class='hs-comment'>{- Note [The hole type in ApplyToTy]
<a name="line-204"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-205"></a>The sc_hole_ty field of ApplyToTy records the type of the "hole" in the
<a name="line-206"></a>continuation.  It is absolutely necessary to compute contHoleType, but it is
<a name="line-207"></a>not used for anything else (and hence may not be evaluated).
<a name="line-208"></a>
<a name="line-209"></a>Why is it necessary for contHoleType?  Consider the continuation
<a name="line-210"></a>     ApplyToType Int (Stop Int)
<a name="line-211"></a>corresponding to
<a name="line-212"></a>     (&lt;hole&gt; @Int) :: Int
<a name="line-213"></a>What is the type of &lt;hole&gt;?  It could be (forall a. Int) or (forall a. a),
<a name="line-214"></a>and there is no way to know which, so we must record it.
<a name="line-215"></a>
<a name="line-216"></a>In a chain of applications  (f @t1 @t2 @t3) we'll lazily compute exprType
<a name="line-217"></a>for (f @t1) and (f @t1 @t2), which is potentially non-linear; but it probably
<a name="line-218"></a>doesn't matter because we'll never compute them all.
<a name="line-219"></a>
<a name="line-220"></a>************************************************************************
<a name="line-221"></a>*                                                                      *
<a name="line-222"></a>                ArgInfo and ArgSpec
<a name="line-223"></a>*                                                                      *
<a name="line-224"></a>************************************************************************
<a name="line-225"></a>-}</span>
<a name="line-226"></a>
<a name="line-227"></a><a name="ArgInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-228"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span>
<a name="line-229"></a>        <span class='hs-varid'>ai_fun</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutId</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- The function</span>
<a name="line-230"></a>        <span class='hs-varid'>ai_args</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- ...applied to these args (which are in *reverse* order)</span>
<a name="line-231"></a>
<a name="line-232"></a>        <span class='hs-varid'>ai_type</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Type of (f a1 ... an)</span>
<a name="line-233"></a>
<a name="line-234"></a>        <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunRules</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- Rules for this function</span>
<a name="line-235"></a>
<a name="line-236"></a>        <span class='hs-varid'>ai_encl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Flag saying whether this function</span>
<a name="line-237"></a>                                <span class='hs-comment'>-- or an enclosing one has rules (recursively)</span>
<a name="line-238"></a>                                <span class='hs-comment'>--      True =&gt; be keener to inline in all args</span>
<a name="line-239"></a>
<a name="line-240"></a>        <span class='hs-varid'>ai_strs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bool</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Strictness of remaining arguments</span>
<a name="line-241"></a>                                <span class='hs-comment'>--   Usually infinite, but if it is finite it guarantees</span>
<a name="line-242"></a>                                <span class='hs-comment'>--   that the function diverges after being given</span>
<a name="line-243"></a>                                <span class='hs-comment'>--   that number of args</span>
<a name="line-244"></a>        <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Discounts for remaining arguments; non-zero =&gt; be keener to inline</span>
<a name="line-245"></a>                                <span class='hs-comment'>--   Always infinite</span>
<a name="line-246"></a>    <span class='hs-layout'>}</span>
<a name="line-247"></a>
<a name="line-248"></a><a name="ArgSpec"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArgSpec</span>
<a name="line-249"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValArg</span> <span class='hs-conid'>OutExpr</span>                    <span class='hs-comment'>-- Apply to this (coercion or value); c.f. ApplyToVal</span>
<a name="line-250"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>     <span class='hs-comment'>-- Apply to this type; c.f. ApplyToTy</span>
<a name="line-251"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-layout'>}</span>   <span class='hs-comment'>-- Type of the function (presumably forall a. blah)</span>
<a name="line-252"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CastBy</span> <span class='hs-conid'>OutCoercion</span>                <span class='hs-comment'>-- Cast by this; c.f. CastIt</span>
<a name="line-253"></a>
<a name="line-254"></a><a name="instance%20Outputable%20ArgSpec"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ArgSpec</span> <span class='hs-keyword'>where</span>
<a name="line-255"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ValArg</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ValArg"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>e</span>
<a name="line-256"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"TyArg"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-257"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastBy</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"CastBy"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>c</span>
<a name="line-258"></a>
<a name="line-259"></a><a name="addValArgTo"></a><span class='hs-definition'>addValArgTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-260"></a><span class='hs-definition'>addValArgTo</span> <span class='hs-varid'>ai</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValArg</span> <span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ai_args</span> <span class='hs-varid'>ai</span>
<a name="line-261"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>ai_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyTypeToArg</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_type</span> <span class='hs-varid'>ai</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-262"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decRules</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_rules</span> <span class='hs-varid'>ai</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-263"></a>
<a name="line-264"></a><a name="addTyArgTo"></a><span class='hs-definition'>addTyArgTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-265"></a><span class='hs-definition'>addTyArgTo</span> <span class='hs-varid'>ai</span> <span class='hs-varid'>arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_spec</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ai_args</span> <span class='hs-varid'>ai</span>
<a name="line-266"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ai_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>piResultTy</span> <span class='hs-varid'>poly_fun_ty</span> <span class='hs-varid'>arg_ty</span>
<a name="line-267"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decRules</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_rules</span> <span class='hs-varid'>ai</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-268"></a>  <span class='hs-keyword'>where</span>
<a name="line-269"></a>    <span class='hs-varid'>poly_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai_type</span> <span class='hs-varid'>ai</span>
<a name="line-270"></a>    <span class='hs-varid'>arg_spec</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>poly_fun_ty</span> <span class='hs-layout'>}</span>
<a name="line-271"></a>
<a name="line-272"></a><a name="addCastTo"></a><span class='hs-definition'>addCastTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutCoercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-273"></a><span class='hs-definition'>addCastTo</span> <span class='hs-varid'>ai</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CastBy</span> <span class='hs-varid'>co</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ai_args</span> <span class='hs-varid'>ai</span>
<a name="line-274"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>ai_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pSnd</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-275"></a>
<a name="line-276"></a><a name="argInfoAppArgs"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutExpr</span><span class='hs-keyglyph'>]</span>
<a name="line-277"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-conid'>[]</span>                              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-278"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastBy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>                <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>  <span class='hs-comment'>-- Stop at a cast</span>
<a name="line-279"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>ValArg</span> <span class='hs-varid'>e</span>                 <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span>       <span class='hs-conop'>:</span> <span class='hs-varid'>argInfoAppArgs</span> <span class='hs-keyword'>as</span>
<a name="line-280"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span> <span class='hs-conop'>:</span> <span class='hs-varid'>argInfoAppArgs</span> <span class='hs-keyword'>as</span>
<a name="line-281"></a>
<a name="line-282"></a><a name="pushSimplifiedArgs"></a><span class='hs-definition'>pushSimplifiedArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-283"></a><span class='hs-definition'>pushSimplifiedArgs</span> <span class='hs-sel'>_env</span> <span class='hs-conid'>[]</span>           <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span>
<a name="line-284"></a><span class='hs-definition'>pushSimplifiedArgs</span> <span class='hs-varid'>env</span>  <span class='hs-layout'>(</span><span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span>
<a name="line-285"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>arg</span> <span class='hs-keyword'>of</span>
<a name="line-286"></a>      <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span>
<a name="line-287"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-288"></a>      <span class='hs-conid'>ValArg</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Simplified</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-289"></a>      <span class='hs-conid'>CastBy</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CastIt</span> <span class='hs-varid'>c</span> <span class='hs-varid'>rest</span>
<a name="line-290"></a>  <span class='hs-keyword'>where</span>
<a name="line-291"></a>    <span class='hs-varid'>rest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pushSimplifiedArgs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>
<a name="line-292"></a>           <span class='hs-comment'>-- The env has an empty SubstEnv</span>
<a name="line-293"></a>
<a name="line-294"></a><a name="argInfoExpr"></a><span class='hs-definition'>argInfoExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-295"></a><span class='hs-comment'>-- NB: the [ArgSpec] is reversed so that the first arg</span>
<a name="line-296"></a><span class='hs-comment'>-- in the list is the last one in the application</span>
<a name="line-297"></a><span class='hs-definition'>argInfoExpr</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>rev_args</span>
<a name="line-298"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rev_args</span>
<a name="line-299"></a>  <span class='hs-keyword'>where</span>
<a name="line-300"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>                              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span>
<a name="line-301"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ValArg</span> <span class='hs-varid'>a</span>                 <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>`App`</span> <span class='hs-varid'>a</span>
<a name="line-302"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>`App`</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span>
<a name="line-303"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastBy</span> <span class='hs-varid'>co</span>                <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCast</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-304"></a>
<a name="line-305"></a>
<a name="line-306"></a><a name="FunRules"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>FunRules</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Remaining rules for this function</span>
<a name="line-307"></a>     <span class='hs-comment'>-- Nothing =&gt; No rules</span>
<a name="line-308"></a>     <span class='hs-comment'>-- Just (n, rules) =&gt; some rules, requiring at least n more type/value args</span>
<a name="line-309"></a>
<a name="line-310"></a><a name="decRules"></a><span class='hs-definition'>decRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunRules</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FunRules</span>
<a name="line-311"></a><span class='hs-definition'>decRules</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-varid'>rules</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>rules</span><span class='hs-layout'>)</span>
<a name="line-312"></a><span class='hs-definition'>decRules</span> <span class='hs-conid'>Nothing</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-313"></a>
<a name="line-314"></a><a name="mkFunRules"></a><span class='hs-definition'>mkFunRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FunRules</span>
<a name="line-315"></a><span class='hs-definition'>mkFunRules</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-316"></a><span class='hs-definition'>mkFunRules</span> <span class='hs-varid'>rs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_required</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>
<a name="line-317"></a>  <span class='hs-keyword'>where</span>
<a name="line-318"></a>    <span class='hs-varid'>n_required</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ruleArity</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>
<a name="line-319"></a>
<a name="line-320"></a><span class='hs-comment'>{-
<a name="line-321"></a>************************************************************************
<a name="line-322"></a>*                                                                      *
<a name="line-323"></a>                Functions on SimplCont
<a name="line-324"></a>*                                                                      *
<a name="line-325"></a>************************************************************************
<a name="line-326"></a>-}</span>
<a name="line-327"></a>
<a name="line-328"></a><a name="mkBoringStop"></a><span class='hs-definition'>mkBoringStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-329"></a><span class='hs-definition'>mkBoringStop</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-conid'>BoringCtxt</span>
<a name="line-330"></a>
<a name="line-331"></a><a name="mkRhsStop"></a><span class='hs-definition'>mkRhsStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>       <span class='hs-comment'>-- See Note [RHS of lets] in CoreUnfold</span>
<a name="line-332"></a><span class='hs-definition'>mkRhsStop</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-conid'>RhsCtxt</span>
<a name="line-333"></a>
<a name="line-334"></a><a name="mkLazyArgStop"></a><span class='hs-definition'>mkLazyArgStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-335"></a><span class='hs-definition'>mkLazyArgStop</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cci</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cci</span>
<a name="line-336"></a>
<a name="line-337"></a><a name="contIsRhsOrArg"></a><span class='hs-comment'>-------------------</span>
<a name="line-338"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-339"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-340"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-341"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-342"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-343"></a>
<a name="line-344"></a><a name="contIsRhs"></a><span class='hs-definition'>contIsRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-345"></a><span class='hs-definition'>contIsRhs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>RhsCtxt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-346"></a><span class='hs-definition'>contIsRhs</span> <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-347"></a>
<a name="line-348"></a><a name="contIsStop"></a><span class='hs-comment'>-------------------</span>
<a name="line-349"></a><span class='hs-definition'>contIsStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-350"></a><span class='hs-definition'>contIsStop</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-351"></a><span class='hs-definition'>contIsStop</span> <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-352"></a>
<a name="line-353"></a><a name="contIsDupable"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-354"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-355"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsDupable</span> <span class='hs-varid'>k</span>
<a name="line-356"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-357"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- ...ditto...</span>
<a name="line-358"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- ...ditto...</span>
<a name="line-359"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsDupable</span> <span class='hs-varid'>k</span>
<a name="line-360"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-keyword'>_</span>                                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-361"></a>
<a name="line-362"></a><a name="contIsTrivial"></a><span class='hs-comment'>-------------------</span>
<a name="line-363"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-364"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-365"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>                       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsTrivial</span> <span class='hs-varid'>k</span>
<a name="line-366"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsTrivial</span> <span class='hs-varid'>k</span>
<a name="line-367"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsTrivial</span> <span class='hs-varid'>k</span>
<a name="line-368"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-keyword'>_</span>                                                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-369"></a>
<a name="line-370"></a><a name="contResultType"></a><span class='hs-comment'>-------------------</span>
<a name="line-371"></a><span class='hs-definition'>contResultType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span>
<a name="line-372"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-373"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-374"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-375"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-376"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-377"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-378"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-379"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-380"></a>
<a name="line-381"></a><a name="contHoleType"></a><span class='hs-definition'>contHoleType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span>
<a name="line-382"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-383"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleType</span> <span class='hs-varid'>k</span>
<a name="line-384"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pFst</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-385"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-386"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>perhapsSubstTy</span> <span class='hs-varid'>dup</span> <span class='hs-varid'>se</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-387"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funArgTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_type</span> <span class='hs-varid'>ai</span><span class='hs-layout'>)</span>
<a name="line-388"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>  <span class='hs-comment'>-- See Note [The hole type in ApplyToTy]</span>
<a name="line-389"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-390"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFunTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>perhapsSubstTy</span> <span class='hs-varid'>dup</span> <span class='hs-varid'>se</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-391"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>contHoleType</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>
<a name="line-392"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-393"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>perhapsSubstTy</span> <span class='hs-varid'>d</span> <span class='hs-varid'>se</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-394"></a>
<a name="line-395"></a><a name="countArgs"></a><span class='hs-comment'>-------------------</span>
<a name="line-396"></a><span class='hs-definition'>countArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-397"></a><span class='hs-comment'>-- Count all arguments, including types, coercions, and other values</span>
<a name="line-398"></a><span class='hs-definition'>countArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>countArgs</span> <span class='hs-varid'>cont</span>
<a name="line-399"></a><span class='hs-definition'>countArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>countArgs</span> <span class='hs-varid'>cont</span>
<a name="line-400"></a><span class='hs-definition'>countArgs</span> <span class='hs-keyword'>_</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-401"></a>
<a name="line-402"></a><a name="contArgs"></a><span class='hs-definition'>contArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSummary</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span>
<a name="line-403"></a><span class='hs-comment'>-- Summarises value args, discards type args and coercions</span>
<a name="line-404"></a><span class='hs-comment'>-- The returned continuation of the call is only used to</span>
<a name="line-405"></a><span class='hs-comment'>-- answer questions like "are you interesting?"</span>
<a name="line-406"></a><span class='hs-definition'>contArgs</span> <span class='hs-varid'>cont</span>
<a name="line-407"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lone</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-408"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>cont</span>
<a name="line-409"></a>  <span class='hs-keyword'>where</span>
<a name="line-410"></a>    <span class='hs-varid'>lone</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- See Note [Lone variables] in CoreUnfold</span>
<a name="line-411"></a>    <span class='hs-varid'>lone</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-412"></a>    <span class='hs-varid'>lone</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-413"></a>    <span class='hs-varid'>lone</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-414"></a>
<a name="line-415"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-416"></a>                                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_interesting</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>se</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span>
<a name="line-417"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>
<a name="line-418"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>
<a name="line-419"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>
<a name="line-420"></a>
<a name="line-421"></a>    <span class='hs-varid'>is_interesting</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>se</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interestingArg</span> <span class='hs-varid'>se</span> <span class='hs-varid'>arg</span>
<a name="line-422"></a>                   <span class='hs-comment'>-- Do *not* use short-cutting substitution here</span>
<a name="line-423"></a>                   <span class='hs-comment'>-- because we want to get as much IdInfo as possible</span>
<a name="line-424"></a>
<a name="line-425"></a>
<a name="line-426"></a><a name="mkArgInfo"></a><span class='hs-comment'>-------------------</span>
<a name="line-427"></a><span class='hs-definition'>mkArgInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>
<a name="line-428"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Rules for function</span>
<a name="line-429"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>        <span class='hs-comment'>-- Number of value args</span>
<a name="line-430"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>  <span class='hs-comment'>-- Context of the call</span>
<a name="line-431"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-432"></a>
<a name="line-433"></a><span class='hs-definition'>mkArgInfo</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>call_cont</span>
<a name="line-434"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>fun</span>            <span class='hs-comment'>-- Note [Unsaturated functions]</span>
<a name="line-435"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span>
<a name="line-436"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_rules</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-437"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_strs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vanilla_stricts</span>
<a name="line-438"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vanilla_discounts</span> <span class='hs-layout'>}</span>
<a name="line-439"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-440"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span>
<a name="line-441"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_rules</span>
<a name="line-442"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interestingArgContext</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>call_cont</span>
<a name="line-443"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_strs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_type_str</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>arg_stricts</span>
<a name="line-444"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-layout'>}</span>
<a name="line-445"></a>  <span class='hs-keyword'>where</span>
<a name="line-446"></a>    <span class='hs-varid'>fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>fun</span>
<a name="line-447"></a>
<a name="line-448"></a>    <span class='hs-varid'>fun_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFunRules</span> <span class='hs-varid'>rules</span>
<a name="line-449"></a>
<a name="line-450"></a>    <span class='hs-varid'>vanilla_discounts</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<a name="line-451"></a>    <span class='hs-varid'>vanilla_discounts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>repeat</span> <span class='hs-num'>0</span>
<a name="line-452"></a>    <span class='hs-varid'>arg_discounts</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>fun</span> <span class='hs-keyword'>of</span>
<a name="line-453"></a>                        <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span><span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span><span class='hs-varid'>ug_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discounts</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-454"></a>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>discounts</span> <span class='hs-varop'>++</span> <span class='hs-varid'>vanilla_discounts</span>
<a name="line-455"></a>                        <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>vanilla_discounts</span>
<a name="line-456"></a>
<a name="line-457"></a>    <span class='hs-varid'>vanilla_stricts</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_stricts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bool</span><span class='hs-keyglyph'>]</span>
<a name="line-458"></a>    <span class='hs-varid'>vanilla_stricts</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>repeat</span> <span class='hs-conid'>False</span>
<a name="line-459"></a>
<a name="line-460"></a>    <span class='hs-varid'>arg_stricts</span>
<a name="line-461"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>splitStrictSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-462"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>demands</span><span class='hs-layout'>,</span> <span class='hs-varid'>result_info</span><span class='hs-layout'>)</span>
<a name="line-463"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>demands</span> <span class='hs-varop'>`lengthExceeds`</span> <span class='hs-varid'>n_val_args</span><span class='hs-layout'>)</span>
<a name="line-464"></a>                <span class='hs-keyglyph'>-&gt;</span>      <span class='hs-comment'>-- Enough args, use the strictness given.</span>
<a name="line-465"></a>                        <span class='hs-comment'>-- For bottoming functions we used to pretend that the arg</span>
<a name="line-466"></a>                        <span class='hs-comment'>-- is lazy, so that we don't treat the arg as an</span>
<a name="line-467"></a>                        <span class='hs-comment'>-- interesting context.  This avoids substituting</span>
<a name="line-468"></a>                        <span class='hs-comment'>-- top-level bindings for (say) strings into</span>
<a name="line-469"></a>                        <span class='hs-comment'>-- calls to error.  But now we are more careful about</span>
<a name="line-470"></a>                        <span class='hs-comment'>-- inlining lone variables, so its ok (see SimplUtils.analyseCont)</span>
<a name="line-471"></a>                   <span class='hs-keyword'>if</span> <span class='hs-varid'>isBotRes</span> <span class='hs-varid'>result_info</span> <span class='hs-keyword'>then</span>
<a name="line-472"></a>                        <span class='hs-varid'>map</span> <span class='hs-varid'>isStrictDmd</span> <span class='hs-varid'>demands</span>         <span class='hs-comment'>-- Finite =&gt; result is bottom</span>
<a name="line-473"></a>                   <span class='hs-keyword'>else</span>
<a name="line-474"></a>                        <span class='hs-varid'>map</span> <span class='hs-varid'>isStrictDmd</span> <span class='hs-varid'>demands</span> <span class='hs-varop'>++</span> <span class='hs-varid'>vanilla_stricts</span>
<a name="line-475"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-476"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"More demands than arity"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idArity</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>
<a name="line-477"></a>                                <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>demands</span> <span class='hs-layout'>)</span>
<a name="line-478"></a>                   <span class='hs-varid'>vanilla_stricts</span>      <span class='hs-comment'>-- Not enough args, or no strictness</span>
<a name="line-479"></a>
<a name="line-480"></a>    <span class='hs-varid'>add_type_str</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bool</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bool</span><span class='hs-keyglyph'>]</span>
<a name="line-481"></a>    <span class='hs-comment'>-- If the function arg types are strict, record that in the 'strictness bits'</span>
<a name="line-482"></a>    <span class='hs-comment'>-- No need to instantiate because unboxed types (which dominate the strict</span>
<a name="line-483"></a>    <span class='hs-comment'>-- types) can't instantiate type variables.</span>
<a name="line-484"></a>    <span class='hs-comment'>-- add_type_str is done repeatedly (for each call); might be better</span>
<a name="line-485"></a>    <span class='hs-comment'>-- once-for-all in the function</span>
<a name="line-486"></a>    <span class='hs-comment'>-- But beware primops/datacons with no strictness</span>
<a name="line-487"></a>
<a name="line-488"></a>    <span class='hs-varid'>add_type_str</span>
<a name="line-489"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-490"></a>      <span class='hs-keyword'>where</span>
<a name="line-491"></a>        <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-492"></a>        <span class='hs-varid'>go</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>strs</span>            <span class='hs-comment'>-- Look through foralls</span>
<a name="line-493"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTy_maybe</span> <span class='hs-varid'>fun_ty</span>       <span class='hs-comment'>-- Includes coercions</span>
<a name="line-494"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>strs</span>
<a name="line-495"></a>        <span class='hs-varid'>go</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>str</span><span class='hs-conop'>:</span><span class='hs-varid'>strs</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Add strict-type info</span>
<a name="line-496"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-497"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>str</span> <span class='hs-varop'>||</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>False</span> <span class='hs-varop'>==</span> <span class='hs-varid'>isLiftedType_maybe</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>strs</span>
<a name="line-498"></a>               <span class='hs-comment'>-- If the type is levity-polymorphic, we can't know whether it's</span>
<a name="line-499"></a>               <span class='hs-comment'>-- strict. isLiftedType_maybe will return Just False only when</span>
<a name="line-500"></a>               <span class='hs-comment'>-- we're sure the type is unlifted.</span>
<a name="line-501"></a>        <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>strs</span>
<a name="line-502"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strs</span>
<a name="line-503"></a>
<a name="line-504"></a><span class='hs-comment'>{- Note [Unsaturated functions]
<a name="line-505"></a>  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-506"></a>Consider (test eyeball/inline4)
<a name="line-507"></a>        x = a:as
<a name="line-508"></a>        y = f x
<a name="line-509"></a>where f has arity 2.  Then we do not want to inline 'x', because
<a name="line-510"></a>it'll just be floated out again.  Even if f has lots of discounts
<a name="line-511"></a>on its first argument -- it must be saturated for these to kick in
<a name="line-512"></a>-}</span>
<a name="line-513"></a>
<a name="line-514"></a>
<a name="line-515"></a><span class='hs-comment'>{-
<a name="line-516"></a>************************************************************************
<a name="line-517"></a>*                                                                      *
<a name="line-518"></a>        Interesting arguments
<a name="line-519"></a>*                                                                      *
<a name="line-520"></a>************************************************************************
<a name="line-521"></a>
<a name="line-522"></a>Note [Interesting call context]
<a name="line-523"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-524"></a>We want to avoid inlining an expression where there can't possibly be
<a name="line-525"></a>any gain, such as in an argument position.  Hence, if the continuation
<a name="line-526"></a>is interesting (eg. a case scrutinee, application etc.) then we
<a name="line-527"></a>inline, otherwise we don't.
<a name="line-528"></a>
<a name="line-529"></a>Previously some_benefit used to return True only if the variable was
<a name="line-530"></a>applied to some value arguments.  This didn't work:
<a name="line-531"></a>
<a name="line-532"></a>        let x = _coerce_ (T Int) Int (I# 3) in
<a name="line-533"></a>        case _coerce_ Int (T Int) x of
<a name="line-534"></a>                I# y -&gt; ....
<a name="line-535"></a>
<a name="line-536"></a>we want to inline x, but can't see that it's a constructor in a case
<a name="line-537"></a>scrutinee position, and some_benefit is False.
<a name="line-538"></a>
<a name="line-539"></a>Another example:
<a name="line-540"></a>
<a name="line-541"></a>dMonadST = _/\_ t -&gt; :Monad (g1 _@_ t, g2 _@_ t, g3 _@_ t)
<a name="line-542"></a>
<a name="line-543"></a>....  case dMonadST _@_ x0 of (a,b,c) -&gt; ....
<a name="line-544"></a>
<a name="line-545"></a>we'd really like to inline dMonadST here, but we *don't* want to
<a name="line-546"></a>inline if the case expression is just
<a name="line-547"></a>
<a name="line-548"></a>        case x of y { DEFAULT -&gt; ... }
<a name="line-549"></a>
<a name="line-550"></a>since we can just eliminate this case instead (x is in WHNF).  Similar
<a name="line-551"></a>applies when x is bound to a lambda expression.  Hence
<a name="line-552"></a>contIsInteresting looks for case expressions with just a single
<a name="line-553"></a>default case.
<a name="line-554"></a>
<a name="line-555"></a>Note [No case of case is boring]
<a name="line-556"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-557"></a>If we see
<a name="line-558"></a>   case f x of &lt;alts&gt;
<a name="line-559"></a>
<a name="line-560"></a>we'd usually treat the context as interesting, to encourage 'f' to
<a name="line-561"></a>inline.  But if case-of-case is off, it's really not so interesting
<a name="line-562"></a>after all, because we are unlikely to be able to push the case
<a name="line-563"></a>expression into the branches of any case in f's unfolding.  So, to
<a name="line-564"></a>reduce unnecessary code expansion, we just make the context look boring.
<a name="line-565"></a>This made a small compile-time perf improvement in perf/compiler/T6048,
<a name="line-566"></a>and it looks plausible to me.
<a name="line-567"></a>-}</span>
<a name="line-568"></a>
<a name="line-569"></a><a name="interestingCallContext"></a><span class='hs-definition'>interestingCallContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span>
<a name="line-570"></a><span class='hs-comment'>-- See Note [Interesting call context]</span>
<a name="line-571"></a><span class='hs-definition'>interestingCallContext</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span>
<a name="line-572"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>cont</span>
<a name="line-573"></a>  <span class='hs-keyword'>where</span>
<a name="line-574"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-575"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sm_case_case</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CaseCtxt</span>
<a name="line-576"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BoringCtxt</span>
<a name="line-577"></a>       <span class='hs-comment'>-- See Note [No case of case is boring]</span>
<a name="line-578"></a>
<a name="line-579"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValAppCtxt</span>
<a name="line-580"></a>        <span class='hs-comment'>-- Can happen if we have (f Int |&gt; co) y</span>
<a name="line-581"></a>        <span class='hs-comment'>-- If f has an INLINE prag we need to give it some</span>
<a name="line-582"></a>        <span class='hs-comment'>-- motivation to inline. See Note [Cast then apply]</span>
<a name="line-583"></a>        <span class='hs-comment'>-- in CoreUnfold</span>
<a name="line-584"></a>
<a name="line-585"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cci</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cci</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cci</span>
<a name="line-586"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BoringCtxt</span>
<a name="line-587"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cci</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cci</span>
<a name="line-588"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>k</span>
<a name="line-589"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>k</span>
<a name="line-590"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>k</span>
<a name="line-591"></a>        <span class='hs-comment'>-- If this call is the arg of a strict function, the context</span>
<a name="line-592"></a>        <span class='hs-comment'>-- is a bit interesting.  If we inline here, we may get useful</span>
<a name="line-593"></a>        <span class='hs-comment'>-- evaluation information to avoid repeated evals: e.g.</span>
<a name="line-594"></a>        <span class='hs-comment'>--      x + (y * z)</span>
<a name="line-595"></a>        <span class='hs-comment'>-- Here the contIsInteresting makes the '*' keener to inline,</span>
<a name="line-596"></a>        <span class='hs-comment'>-- which in turn exposes a constructor which makes the '+' inline.</span>
<a name="line-597"></a>        <span class='hs-comment'>-- Assuming that +,* aren't small enough to inline regardless.</span>
<a name="line-598"></a>        <span class='hs-comment'>--</span>
<a name="line-599"></a>        <span class='hs-comment'>-- It's also very important to inline in a strict context for things</span>
<a name="line-600"></a>        <span class='hs-comment'>-- like</span>
<a name="line-601"></a>        <span class='hs-comment'>--              foldr k z (f x)</span>
<a name="line-602"></a>        <span class='hs-comment'>-- Here, the context of (f x) is strict, and if f's unfolding is</span>
<a name="line-603"></a>        <span class='hs-comment'>-- a build it's *great* to inline it here.  So we must ensure that</span>
<a name="line-604"></a>        <span class='hs-comment'>-- the context for (f x) is not totally uninteresting.</span>
<a name="line-605"></a>
<a name="line-606"></a><a name="interestingArgContext"></a><span class='hs-definition'>interestingArgContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-607"></a><span class='hs-comment'>-- If the argument has form (f x y), where x,y are boring,</span>
<a name="line-608"></a><span class='hs-comment'>-- and f is marked INLINE, then we don't want to inline f.</span>
<a name="line-609"></a><span class='hs-comment'>-- But if the context of the argument is</span>
<a name="line-610"></a><span class='hs-comment'>--      g (f x y)</span>
<a name="line-611"></a><span class='hs-comment'>-- where g has rules, then we *do* want to inline f, in case it</span>
<a name="line-612"></a><span class='hs-comment'>-- exposes a rule that might fire.  Similarly, if the context is</span>
<a name="line-613"></a><span class='hs-comment'>--      h (g (f x x))</span>
<a name="line-614"></a><span class='hs-comment'>-- where h has rules, then we do want to inline f; hence the</span>
<a name="line-615"></a><span class='hs-comment'>-- call_cont argument to interestingArgContext</span>
<a name="line-616"></a><span class='hs-comment'>--</span>
<a name="line-617"></a><span class='hs-comment'>-- The ai-rules flag makes this happen; if it's</span>
<a name="line-618"></a><span class='hs-comment'>-- set, the inliner gets just enough keener to inline f</span>
<a name="line-619"></a><span class='hs-comment'>-- regardless of how boring f's arguments are, if it's marked INLINE</span>
<a name="line-620"></a><span class='hs-comment'>--</span>
<a name="line-621"></a><span class='hs-comment'>-- The alternative would be to *always* inline an INLINE function,</span>
<a name="line-622"></a><span class='hs-comment'>-- regardless of how boring its context is; but that seems overkill</span>
<a name="line-623"></a><span class='hs-comment'>-- For example, it'd mean that wrapper functions were always inlined</span>
<a name="line-624"></a><span class='hs-comment'>--</span>
<a name="line-625"></a><span class='hs-comment'>-- The call_cont passed to interestingArgContext is the context of</span>
<a name="line-626"></a><span class='hs-comment'>-- the call itself, e.g. g &lt;hole&gt; in the example above</span>
<a name="line-627"></a><span class='hs-definition'>interestingArgContext</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>call_cont</span>
<a name="line-628"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>notNull</span> <span class='hs-varid'>rules</span> <span class='hs-varop'>||</span> <span class='hs-varid'>enclosing_fn_has_rules</span>
<a name="line-629"></a>  <span class='hs-keyword'>where</span>
<a name="line-630"></a>    <span class='hs-varid'>enclosing_fn_has_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>call_cont</span>
<a name="line-631"></a>
<a name="line-632"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-633"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- Shouldn't really happen</span>
<a name="line-634"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- Ditto</span>
<a name="line-635"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cci</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cci</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>cci</span>
<a name="line-636"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>      <span class='hs-comment'>-- ??</span>
<a name="line-637"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>c</span>
<a name="line-638"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cci</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>cci</span>
<a name="line-639"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>c</span>
<a name="line-640"></a>
<a name="line-641"></a>    <span class='hs-varid'>interesting</span> <span class='hs-conid'>RuleArgCtxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-642"></a>    <span class='hs-varid'>interesting</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-643"></a>
<a name="line-644"></a>
<a name="line-645"></a><span class='hs-comment'>{- Note [Interesting arguments]
<a name="line-646"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-647"></a>An argument is interesting if it deserves a discount for unfoldings
<a name="line-648"></a>with a discount in that argument position.  The idea is to avoid
<a name="line-649"></a>unfolding a function that is applied only to variables that have no
<a name="line-650"></a>unfolding (i.e. they are probably lambda bound): f x y z There is
<a name="line-651"></a>little point in inlining f here.
<a name="line-652"></a>
<a name="line-653"></a>Generally, *values* (like (C a b) and (\x.e)) deserve discounts.  But
<a name="line-654"></a>we must look through lets, eg (let x = e in C a b), because the let will
<a name="line-655"></a>float, exposing the value, if we inline.  That makes it different to
<a name="line-656"></a>exprIsHNF.
<a name="line-657"></a>
<a name="line-658"></a>Before 2009 we said it was interesting if the argument had *any* structure
<a name="line-659"></a>at all; i.e. (hasSomeUnfolding v).  But does too much inlining; see Trac #3016.
<a name="line-660"></a>
<a name="line-661"></a>But we don't regard (f x y) as interesting, unless f is unsaturated.
<a name="line-662"></a>If it's saturated and f hasn't inlined, then it's probably not going
<a name="line-663"></a>to now!
<a name="line-664"></a>
<a name="line-665"></a>Note [Conlike is interesting]
<a name="line-666"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-667"></a>Consider
<a name="line-668"></a>        f d = ...((*) d x y)...
<a name="line-669"></a>        ... f (df d')...
<a name="line-670"></a>where df is con-like. Then we'd really like to inline 'f' so that the
<a name="line-671"></a>rule for (*) (df d) can fire.  To do this
<a name="line-672"></a>  a) we give a discount for being an argument of a class-op (eg (*) d)
<a name="line-673"></a>  b) we say that a con-like argument (eg (df d)) is interesting
<a name="line-674"></a>-}</span>
<a name="line-675"></a>
<a name="line-676"></a><a name="interestingArg"></a><span class='hs-definition'>interestingArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgSummary</span>
<a name="line-677"></a><span class='hs-comment'>-- See Note [Interesting arguments]</span>
<a name="line-678"></a><span class='hs-definition'>interestingArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-num'>0</span> <span class='hs-varid'>e</span>
<a name="line-679"></a>  <span class='hs-keyword'>where</span>
<a name="line-680"></a>    <span class='hs-comment'>-- n is # value args to which the expression is applied</span>
<a name="line-681"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-682"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>substId</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>of</span>
<a name="line-683"></a>           <span class='hs-conid'>DoneId</span> <span class='hs-varid'>v'</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go_var</span> <span class='hs-varid'>n</span> <span class='hs-varid'>v'</span>
<a name="line-684"></a>           <span class='hs-conid'>DoneEx</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>             <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-685"></a>           <span class='hs-conid'>ContEx</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>setSubstEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-686"></a>
<a name="line-687"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>
<a name="line-688"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TrivArg</span>
<a name="line-689"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TrivArg</span>
<a name="line-690"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fn</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>fn</span>
<a name="line-691"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fn</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>fn</span>
<a name="line-692"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span>
<a name="line-693"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-694"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>v</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-695"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-696"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span><span class='hs-varop'>&gt;</span><span class='hs-num'>0</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonTrivArg</span>     <span class='hs-comment'>-- (\x.b) e   is NonTriv</span>
<a name="line-697"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>
<a name="line-698"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonTrivArg</span>
<a name="line-699"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>of</span>
<a name="line-700"></a>                                   <span class='hs-conid'>ValueArg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ValueArg</span>
<a name="line-701"></a>                                   <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NonTrivArg</span>
<a name="line-702"></a>                               <span class='hs-keyword'>where</span>
<a name="line-703"></a>                                 <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addNewInScopeIds`</span> <span class='hs-varid'>bindersOf</span> <span class='hs-varid'>b</span>
<a name="line-704"></a>
<a name="line-705"></a>    <span class='hs-varid'>go_var</span> <span class='hs-varid'>n</span> <span class='hs-varid'>v</span>
<a name="line-706"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isConLikeId</span> <span class='hs-varid'>v</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-comment'>-- Experimenting with 'conlike' rather that</span>
<a name="line-707"></a>                                        <span class='hs-comment'>--    data constructors here</span>
<a name="line-708"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-comment'>-- Catches (eg) primops with arity but no unfolding</span>
<a name="line-709"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonTrivArg</span> <span class='hs-comment'>-- Saturated or unknown call</span>
<a name="line-710"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>conlike_unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-comment'>-- n==0; look for an interesting unfolding</span>
<a name="line-711"></a>                                        <span class='hs-comment'>-- See Note [Conlike is interesting]</span>
<a name="line-712"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TrivArg</span>    <span class='hs-comment'>-- n==0, no useful unfolding</span>
<a name="line-713"></a>       <span class='hs-keyword'>where</span>
<a name="line-714"></a>         <span class='hs-varid'>conlike_unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isConLikeUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-715"></a>
<a name="line-716"></a><span class='hs-comment'>{-
<a name="line-717"></a>************************************************************************
<a name="line-718"></a>*                                                                      *
<a name="line-719"></a>                  SimplMode
<a name="line-720"></a>*                                                                      *
<a name="line-721"></a>************************************************************************
<a name="line-722"></a>
<a name="line-723"></a>The SimplMode controls several switches; see its definition in
<a name="line-724"></a>CoreMonad
<a name="line-725"></a>        sm_rules      :: Bool     -- Whether RULES are enabled
<a name="line-726"></a>        sm_inline     :: Bool     -- Whether inlining is enabled
<a name="line-727"></a>        sm_case_case  :: Bool     -- Whether case-of-case is enabled
<a name="line-728"></a>        sm_eta_expand :: Bool     -- Whether eta-expansion is enabled
<a name="line-729"></a>-}</span>
<a name="line-730"></a>
<a name="line-731"></a><a name="simplEnvForGHCi"></a><span class='hs-definition'>simplEnvForGHCi</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-732"></a><span class='hs-definition'>simplEnvForGHCi</span> <span class='hs-varid'>dflags</span>
<a name="line-733"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSimplEnv</span> <span class='hs-varop'>$</span> <span class='hs-conid'>SimplMode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sm_names</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"GHCi"</span><span class='hs-keyglyph'>]</span>
<a name="line-734"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_phase</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InitialPhase</span>
<a name="line-735"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_dflags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dflags</span>
<a name="line-736"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_rules</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rules_on</span>
<a name="line-737"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-738"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eta_expand_on</span>
<a name="line-739"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_case_case</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-740"></a>  <span class='hs-keyword'>where</span>
<a name="line-741"></a>    <span class='hs-varid'>rules_on</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_EnableRewriteRules</span>   <span class='hs-varid'>dflags</span>
<a name="line-742"></a>    <span class='hs-varid'>eta_expand_on</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_DoLambdaEtaExpansion</span> <span class='hs-varid'>dflags</span>
<a name="line-743"></a>   <span class='hs-comment'>-- Do not do any inlining, in case we expose some unboxed</span>
<a name="line-744"></a>   <span class='hs-comment'>-- tuple stuff that confuses the bytecode interpreter</span>
<a name="line-745"></a>
<a name="line-746"></a><a name="updModeForStableUnfoldings"></a><span class='hs-definition'>updModeForStableUnfoldings</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplMode</span>
<a name="line-747"></a><span class='hs-comment'>-- See Note [Simplifying inside stable unfoldings]</span>
<a name="line-748"></a><span class='hs-definition'>updModeForStableUnfoldings</span> <span class='hs-varid'>inline_rule_act</span> <span class='hs-varid'>current_mode</span>
<a name="line-749"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>current_mode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sm_phase</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>phaseFromActivation</span> <span class='hs-varid'>inline_rule_act</span>
<a name="line-750"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_inline</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-751"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-752"></a>                     <span class='hs-comment'>-- sm_eta_expand: see Note [No eta expansion in stable unfoldings]</span>
<a name="line-753"></a>       <span class='hs-comment'>-- For sm_rules, just inherit; sm_rules might be "off"</span>
<a name="line-754"></a>       <span class='hs-comment'>-- because of -fno-enable-rewrite-rules</span>
<a name="line-755"></a>  <span class='hs-keyword'>where</span>
<a name="line-756"></a>    <span class='hs-varid'>phaseFromActivation</span> <span class='hs-layout'>(</span><span class='hs-conid'>ActiveAfter</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Phase</span> <span class='hs-varid'>n</span>
<a name="line-757"></a>    <span class='hs-varid'>phaseFromActivation</span> <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InitialPhase</span>
<a name="line-758"></a>
<a name="line-759"></a><a name="updModeForRules"></a><span class='hs-definition'>updModeForRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplMode</span>
<a name="line-760"></a><span class='hs-comment'>-- See Note [Simplifying rules]</span>
<a name="line-761"></a><span class='hs-definition'>updModeForRules</span> <span class='hs-varid'>current_mode</span>
<a name="line-762"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>current_mode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sm_phase</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InitialPhase</span>
<a name="line-763"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-764"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_rules</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-765"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-766"></a>
<a name="line-767"></a><span class='hs-comment'>{- Note [Simplifying rules]
<a name="line-768"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-769"></a>When simplifying a rule LHS, refrain from /any/ inlining or applying
<a name="line-770"></a>of other RULES.
<a name="line-771"></a>
<a name="line-772"></a>Doing anything to the LHS is plain confusing, because it means that what the
<a name="line-773"></a>rule matches is not what the user wrote. c.f. Trac #10595, and #10528.
<a name="line-774"></a>Moreover, inlining (or applying rules) on rule LHSs risks introducing
<a name="line-775"></a>Ticks into the LHS, which makes matching trickier. Trac #10665, #10745.
<a name="line-776"></a>
<a name="line-777"></a>Doing this to either side confounds tools like HERMIT, which seek to reason
<a name="line-778"></a>about and apply the RULES as originally written. See Trac #10829.
<a name="line-779"></a>
<a name="line-780"></a>Note [No eta expansion in stable unfoldings]
<a name="line-781"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-782"></a>If we have a stable unfolding
<a name="line-783"></a>
<a name="line-784"></a>  f :: Ord a =&gt; a -&gt; IO ()
<a name="line-785"></a>  -- Unfolding template
<a name="line-786"></a>  --    = /\a \(d:Ord a) (x:a). bla
<a name="line-787"></a>
<a name="line-788"></a>we do not want to eta-expand to
<a name="line-789"></a>
<a name="line-790"></a>  f :: Ord a =&gt; a -&gt; IO ()
<a name="line-791"></a>  -- Unfolding template
<a name="line-792"></a>  --    = (/\a \(d:Ord a) (x:a) (eta:State#). bla eta) |&gt; co
<a name="line-793"></a>
<a name="line-794"></a>because not specialisation of the overloading doesn't work properly
<a name="line-795"></a>(see Note [Specialisation shape] in Specialise), Trac #9509.
<a name="line-796"></a>
<a name="line-797"></a>So we disable eta-expansion in stable unfoldings.
<a name="line-798"></a>
<a name="line-799"></a>Note [Inlining in gentle mode]
<a name="line-800"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-801"></a>Something is inlined if
<a name="line-802"></a>   (i)   the sm_inline flag is on, AND
<a name="line-803"></a>   (ii)  the thing has an INLINE pragma, AND
<a name="line-804"></a>   (iii) the thing is inlinable in the earliest phase.
<a name="line-805"></a>
<a name="line-806"></a>Example of why (iii) is important:
<a name="line-807"></a>  {-# INLINE [~1] g #-}
<a name="line-808"></a>  g = ...
<a name="line-809"></a>
<a name="line-810"></a>  {-# INLINE f #-}
<a name="line-811"></a>  f x = g (g x)
<a name="line-812"></a>
<a name="line-813"></a>If we were to inline g into f's inlining, then an importing module would
<a name="line-814"></a>never be able to do
<a name="line-815"></a>        f e --&gt; g (g e) ---&gt; RULE fires
<a name="line-816"></a>because the stable unfolding for f has had g inlined into it.
<a name="line-817"></a>
<a name="line-818"></a>On the other hand, it is bad not to do ANY inlining into an
<a name="line-819"></a>stable unfolding, because then recursive knots in instance declarations
<a name="line-820"></a>don't get unravelled.
<a name="line-821"></a>
<a name="line-822"></a>However, *sometimes* SimplGently must do no call-site inlining at all
<a name="line-823"></a>(hence sm_inline = False).  Before full laziness we must be careful
<a name="line-824"></a>not to inline wrappers, because doing so inhibits floating
<a name="line-825"></a>    e.g. ...(case f x of ...)...
<a name="line-826"></a>    ==&gt; ...(case (case x of I# x# -&gt; fw x#) of ...)...
<a name="line-827"></a>    ==&gt; ...(case x of I# x# -&gt; case fw x# of ...)...
<a name="line-828"></a>and now the redex (f x) isn't floatable any more.
<a name="line-829"></a>
<a name="line-830"></a>The no-inlining thing is also important for Template Haskell.  You might be
<a name="line-831"></a>compiling in one-shot mode with -O2; but when TH compiles a splice before
<a name="line-832"></a>running it, we don't want to use -O2.  Indeed, we don't want to inline
<a name="line-833"></a>anything, because the byte-code interpreter might get confused about
<a name="line-834"></a>unboxed tuples and suchlike.
<a name="line-835"></a>
<a name="line-836"></a>Note [Simplifying inside stable unfoldings]
<a name="line-837"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-838"></a>We must take care with simplification inside stable unfoldings (which come from
<a name="line-839"></a>INLINE pragmas).
<a name="line-840"></a>
<a name="line-841"></a>First, consider the following example
<a name="line-842"></a>        let f = \pq -&gt; BIG
<a name="line-843"></a>        in
<a name="line-844"></a>        let g = \y -&gt; f y y
<a name="line-845"></a>            {-# INLINE g #-}
<a name="line-846"></a>        in ...g...g...g...g...g...
<a name="line-847"></a>Now, if that's the ONLY occurrence of f, it might be inlined inside g,
<a name="line-848"></a>and thence copied multiple times when g is inlined. HENCE we treat
<a name="line-849"></a>any occurrence in a stable unfolding as a multiple occurrence, not a single
<a name="line-850"></a>one; see OccurAnal.addRuleUsage.
<a name="line-851"></a>
<a name="line-852"></a>Second, we do want *do* to some modest rules/inlining stuff in stable
<a name="line-853"></a>unfoldings, partly to eliminate senseless crap, and partly to break
<a name="line-854"></a>the recursive knots generated by instance declarations.
<a name="line-855"></a>
<a name="line-856"></a>However, suppose we have
<a name="line-857"></a>        {-# INLINE &lt;act&gt; f #-}
<a name="line-858"></a>        f = &lt;rhs&gt;
<a name="line-859"></a>meaning "inline f in phases p where activation &lt;act&gt;(p) holds".
<a name="line-860"></a>Then what inlinings/rules can we apply to the copy of &lt;rhs&gt; captured in
<a name="line-861"></a>f's stable unfolding?  Our model is that literally &lt;rhs&gt; is substituted for
<a name="line-862"></a>f when it is inlined.  So our conservative plan (implemented by
<a name="line-863"></a>updModeForStableUnfoldings) is this:
<a name="line-864"></a>
<a name="line-865"></a>  -------------------------------------------------------------
<a name="line-866"></a>  When simplifying the RHS of an stable unfolding, set the phase
<a name="line-867"></a>  to the phase in which the stable unfolding first becomes active
<a name="line-868"></a>  -------------------------------------------------------------
<a name="line-869"></a>
<a name="line-870"></a>That ensures that
<a name="line-871"></a>
<a name="line-872"></a>  a) Rules/inlinings that *cease* being active before p will
<a name="line-873"></a>     not apply to the stable unfolding, consistent with it being
<a name="line-874"></a>     inlined in its *original* form in phase p.
<a name="line-875"></a>
<a name="line-876"></a>  b) Rules/inlinings that only become active *after* p will
<a name="line-877"></a>     not apply to the stable unfolding, again to be consistent with
<a name="line-878"></a>     inlining the *original* rhs in phase p.
<a name="line-879"></a>
<a name="line-880"></a>For example,
<a name="line-881"></a>        {-# INLINE f #-}
<a name="line-882"></a>        f x = ...g...
<a name="line-883"></a>
<a name="line-884"></a>        {-# NOINLINE [1] g #-}
<a name="line-885"></a>        g y = ...
<a name="line-886"></a>
<a name="line-887"></a>        {-# RULE h g = ... #-}
<a name="line-888"></a>Here we must not inline g into f's RHS, even when we get to phase 0,
<a name="line-889"></a>because when f is later inlined into some other module we want the
<a name="line-890"></a>rule for h to fire.
<a name="line-891"></a>
<a name="line-892"></a>Similarly, consider
<a name="line-893"></a>        {-# INLINE f #-}
<a name="line-894"></a>        f x = ...g...
<a name="line-895"></a>
<a name="line-896"></a>        g y = ...
<a name="line-897"></a>and suppose that there are auto-generated specialisations and a strictness
<a name="line-898"></a>wrapper for g.  The specialisations get activation AlwaysActive, and the
<a name="line-899"></a>strictness wrapper get activation (ActiveAfter 0).  So the strictness
<a name="line-900"></a>wrepper fails the test and won't be inlined into f's stable unfolding. That
<a name="line-901"></a>means f can inline, expose the specialised call to g, so the specialisation
<a name="line-902"></a>rules can fire.
<a name="line-903"></a>
<a name="line-904"></a>A note about wrappers
<a name="line-905"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-906"></a>It's also important not to inline a worker back into a wrapper.
<a name="line-907"></a>A wrapper looks like
<a name="line-908"></a>        wraper = inline_me (\x -&gt; ...worker... )
<a name="line-909"></a>Normally, the inline_me prevents the worker getting inlined into
<a name="line-910"></a>the wrapper (initially, the worker's only call site!).  But,
<a name="line-911"></a>if the wrapper is sure to be called, the strictness analyser will
<a name="line-912"></a>mark it 'demanded', so when the RHS is simplified, it'll get an ArgOf
<a name="line-913"></a>continuation.
<a name="line-914"></a>-}</span>
<a name="line-915"></a>
<a name="line-916"></a><a name="activeUnfolding"></a><span class='hs-definition'>activeUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-917"></a><span class='hs-definition'>activeUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span>
<a name="line-918"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCompulsoryUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-919"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- Even sm_inline can't override compulsory unfoldings</span>
<a name="line-920"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-921"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-922"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>sm_inline</span> <span class='hs-varid'>mode</span>
<a name="line-923"></a>      <span class='hs-comment'>-- `or` isStableUnfolding (realIdUnfolding id)</span>
<a name="line-924"></a>      <span class='hs-comment'>-- Inline things when</span>
<a name="line-925"></a>      <span class='hs-comment'>--  (a) they are active</span>
<a name="line-926"></a>      <span class='hs-comment'>--  (b) sm_inline says so, except that for stable unfoldings</span>
<a name="line-927"></a>      <span class='hs-comment'>--                         (ie pragmas) we inline anyway</span>
<a name="line-928"></a>  <span class='hs-keyword'>where</span>
<a name="line-929"></a>    <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span>
<a name="line-930"></a>
<a name="line-931"></a><a name="getUnfoldingInRuleMatch"></a><span class='hs-definition'>getUnfoldingInRuleMatch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeEnv</span>
<a name="line-932"></a><span class='hs-comment'>-- When matching in RULE, we want to "look through" an unfolding</span>
<a name="line-933"></a><span class='hs-comment'>-- (to see a constructor) if *rules* are on, even if *inlinings*</span>
<a name="line-934"></a><span class='hs-comment'>-- are not.  A notable example is DFuns, which really we want to</span>
<a name="line-935"></a><span class='hs-comment'>-- match in rules like (op dfun) in gentle mode. Another example</span>
<a name="line-936"></a><span class='hs-comment'>-- is 'otherwise' which we want exprIsConApp_maybe to be able to</span>
<a name="line-937"></a><span class='hs-comment'>-- see very early on</span>
<a name="line-938"></a><span class='hs-definition'>getUnfoldingInRuleMatch</span> <span class='hs-varid'>env</span>
<a name="line-939"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-varid'>id_unf</span><span class='hs-layout'>)</span>
<a name="line-940"></a>  <span class='hs-keyword'>where</span>
<a name="line-941"></a>    <span class='hs-varid'>in_scope</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seInScope</span> <span class='hs-varid'>env</span>
<a name="line-942"></a>    <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span>
<a name="line-943"></a>    <span class='hs-varid'>id_unf</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>unf_is_active</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>id</span>
<a name="line-944"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUnfolding</span>
<a name="line-945"></a>    <span class='hs-varid'>unf_is_active</span> <span class='hs-varid'>id</span>
<a name="line-946"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_rules</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- active_unfolding_minimal id</span>
<a name="line-947"></a>                             <span class='hs-varid'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-948"></a>        <span class='hs-comment'>-- Do we even need to test this?  I think this InScopeEnv</span>
<a name="line-949"></a>        <span class='hs-comment'>-- is only consulted if activeRule returns True, which</span>
<a name="line-950"></a>        <span class='hs-comment'>-- never happens if sm_rules is False</span>
<a name="line-951"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-952"></a>
<a name="line-953"></a><a name="activeRule"></a><span class='hs-comment'>----------------------</span>
<a name="line-954"></a><span class='hs-definition'>activeRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-955"></a><span class='hs-comment'>-- Nothing =&gt; No rules at all</span>
<a name="line-956"></a><span class='hs-definition'>activeRule</span> <span class='hs-varid'>env</span>
<a name="line-957"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_rules</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>     <span class='hs-comment'>-- Rewriting is off</span>
<a name="line-958"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span>
<a name="line-959"></a>  <span class='hs-keyword'>where</span>
<a name="line-960"></a>    <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span>
<a name="line-961"></a>
<a name="line-962"></a><span class='hs-comment'>{-
<a name="line-963"></a>************************************************************************
<a name="line-964"></a>*                                                                      *
<a name="line-965"></a>                  preInlineUnconditionally
<a name="line-966"></a>*                                                                      *
<a name="line-967"></a>************************************************************************
<a name="line-968"></a>
<a name="line-969"></a>preInlineUnconditionally
<a name="line-970"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-971"></a>@preInlineUnconditionally@ examines a bndr to see if it is used just
<a name="line-972"></a>once in a completely safe way, so that it is safe to discard the
<a name="line-973"></a>binding inline its RHS at the (unique) usage site, REGARDLESS of how
<a name="line-974"></a>big the RHS might be.  If this is the case we don't simplify the RHS
<a name="line-975"></a>first, but just inline it un-simplified.
<a name="line-976"></a>
<a name="line-977"></a>This is much better than first simplifying a perhaps-huge RHS and then
<a name="line-978"></a>inlining and re-simplifying it.  Indeed, it can be at least quadratically
<a name="line-979"></a>better.  Consider
<a name="line-980"></a>
<a name="line-981"></a>        x1 = e1
<a name="line-982"></a>        x2 = e2[x1]
<a name="line-983"></a>        x3 = e3[x2]
<a name="line-984"></a>        ...etc...
<a name="line-985"></a>        xN = eN[xN-1]
<a name="line-986"></a>
<a name="line-987"></a>We may end up simplifying e1 N times, e2 N-1 times, e3 N-3 times etc.
<a name="line-988"></a>This can happen with cascades of functions too:
<a name="line-989"></a>
<a name="line-990"></a>        f1 = \x1.e1
<a name="line-991"></a>        f2 = \xs.e2[f1]
<a name="line-992"></a>        f3 = \xs.e3[f3]
<a name="line-993"></a>        ...etc...
<a name="line-994"></a>
<a name="line-995"></a>THE MAIN INVARIANT is this:
<a name="line-996"></a>
<a name="line-997"></a>        ----  preInlineUnconditionally invariant -----
<a name="line-998"></a>   IF preInlineUnconditionally chooses to inline x = &lt;rhs&gt;
<a name="line-999"></a>   THEN doing the inlining should not change the occurrence
<a name="line-1000"></a>        info for the free vars of &lt;rhs&gt;
<a name="line-1001"></a>        ----------------------------------------------
<a name="line-1002"></a>
<a name="line-1003"></a>For example, it's tempting to look at trivial binding like
<a name="line-1004"></a>        x = y
<a name="line-1005"></a>and inline it unconditionally.  But suppose x is used many times,
<a name="line-1006"></a>but this is the unique occurrence of y.  Then inlining x would change
<a name="line-1007"></a>y's occurrence info, which breaks the invariant.  It matters: y
<a name="line-1008"></a>might have a BIG rhs, which will now be dup'd at every occurrenc of x.
<a name="line-1009"></a>
<a name="line-1010"></a>
<a name="line-1011"></a>Even RHSs labelled InlineMe aren't caught here, because there might be
<a name="line-1012"></a>no benefit from inlining at the call site.
<a name="line-1013"></a>
<a name="line-1014"></a>[Sept 01] Don't unconditionally inline a top-level thing, because that
<a name="line-1015"></a>can simply make a static thing into something built dynamically.  E.g.
<a name="line-1016"></a>        x = (a,b)
<a name="line-1017"></a>        main = \s -&gt; h x
<a name="line-1018"></a>
<a name="line-1019"></a>[Remember that we treat \s as a one-shot lambda.]  No point in
<a name="line-1020"></a>inlining x unless there is something interesting about the call site.
<a name="line-1021"></a>
<a name="line-1022"></a>But watch out: if you aren't careful, some useful foldr/build fusion
<a name="line-1023"></a>can be lost (most notably in spectral/hartel/parstof) because the
<a name="line-1024"></a>foldr didn't see the build.  Doing the dynamic allocation isn't a big
<a name="line-1025"></a>deal, in fact, but losing the fusion can be.  But the right thing here
<a name="line-1026"></a>seems to be to do a callSiteInline based on the fact that there is
<a name="line-1027"></a>something interesting about the call site (it's strict).  Hmm.  That
<a name="line-1028"></a>seems a bit fragile.
<a name="line-1029"></a>
<a name="line-1030"></a>Conclusion: inline top level things gaily until Phase 0 (the last
<a name="line-1031"></a>phase), at which point don't.
<a name="line-1032"></a>
<a name="line-1033"></a>Note [pre/postInlineUnconditionally in gentle mode]
<a name="line-1034"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1035"></a>Even in gentle mode we want to do preInlineUnconditionally.  The
<a name="line-1036"></a>reason is that too little clean-up happens if you don't inline
<a name="line-1037"></a>use-once things.  Also a bit of inlining is *good* for full laziness;
<a name="line-1038"></a>it can expose constant sub-expressions.  Example in
<a name="line-1039"></a>spectral/mandel/Mandel.hs, where the mandelset function gets a useful
<a name="line-1040"></a>let-float if you inline windowToViewport
<a name="line-1041"></a>
<a name="line-1042"></a>However, as usual for Gentle mode, do not inline things that are
<a name="line-1043"></a>inactive in the intial stages.  See Note [Gentle mode].
<a name="line-1044"></a>
<a name="line-1045"></a>Note [Stable unfoldings and preInlineUnconditionally]
<a name="line-1046"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1047"></a>Surprisingly, do not pre-inline-unconditionally Ids with INLINE pragmas!
<a name="line-1048"></a>Example
<a name="line-1049"></a>
<a name="line-1050"></a>   {-# INLINE f #-}
<a name="line-1051"></a>   f :: Eq a =&gt; a -&gt; a
<a name="line-1052"></a>   f x = ...
<a name="line-1053"></a>
<a name="line-1054"></a>   fInt :: Int -&gt; Int
<a name="line-1055"></a>   fInt = f Int dEqInt
<a name="line-1056"></a>
<a name="line-1057"></a>   ...fInt...fInt...fInt...
<a name="line-1058"></a>
<a name="line-1059"></a>Here f occurs just once, in the RHS of fInt. But if we inline it there
<a name="line-1060"></a>it might make fInt look big, and we'll lose the opportunity to inline f
<a name="line-1061"></a>at each of fInt's call sites.  The INLINE pragma will only inline when
<a name="line-1062"></a>the application is saturated for exactly this reason; and we don't
<a name="line-1063"></a>want PreInlineUnconditionally to second-guess it.  A live example is
<a name="line-1064"></a>Trac #3736.
<a name="line-1065"></a>    c.f. Note [Stable unfoldings and postInlineUnconditionally]
<a name="line-1066"></a>
<a name="line-1067"></a>Note [Top-level bottoming Ids]
<a name="line-1068"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1069"></a>Don't inline top-level Ids that are bottoming, even if they are used just
<a name="line-1070"></a>once, because FloatOut has gone to some trouble to extract them out.
<a name="line-1071"></a>Inlining them won't make the program run faster!
<a name="line-1072"></a>
<a name="line-1073"></a>Note [Do not inline CoVars unconditionally]
<a name="line-1074"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1075"></a>Coercion variables appear inside coercions, and the RHS of a let-binding
<a name="line-1076"></a>is a term (not a coercion) so we can't necessarily inline the latter in
<a name="line-1077"></a>the former.
<a name="line-1078"></a>-}</span>
<a name="line-1079"></a>
<a name="line-1080"></a><a name="preInlineUnconditionally"></a><span class='hs-definition'>preInlineUnconditionally</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1081"></a><span class='hs-comment'>-- Precondition: rhs satisfies the let/app invariant</span>
<a name="line-1082"></a><span class='hs-comment'>-- See Note [CoreSyn let/app invariant] in CoreSyn</span>
<a name="line-1083"></a><span class='hs-comment'>-- Reason: we don't want to inline single uses, or discard dead bindings,</span>
<a name="line-1084"></a><span class='hs-comment'>--         for unlifted, side-effect-ful bindings</span>
<a name="line-1085"></a><span class='hs-definition'>preInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-1086"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>pre_inline_unconditionally</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1087"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>active</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1088"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- Note [Stable unfoldings and preInlineUnconditionally]</span>
<a name="line-1089"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isBottomingId</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- Note [Top-level bottoming Ids]</span>
<a name="line-1090"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>bndr</span>                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- Note [Do not inline CoVars unconditionally]</span>
<a name="line-1091"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>bndr</span> <span class='hs-keyword'>of</span>
<a name="line-1092"></a>                  <span class='hs-conid'>IAmDead</span>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- Happens in ((\x.1) v)</span>
<a name="line-1093"></a>                  <span class='hs-varid'>occ</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_one_br</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-1094"></a>                                             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>try_once</span> <span class='hs-layout'>(</span><span class='hs-varid'>occ_in_lam</span> <span class='hs-varid'>occ</span><span class='hs-layout'>)</span>
<a name="line-1095"></a>                                                         <span class='hs-layout'>(</span><span class='hs-varid'>occ_int_cxt</span> <span class='hs-varid'>occ</span><span class='hs-layout'>)</span>
<a name="line-1096"></a>                  <span class='hs-keyword'>_</span>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1097"></a>  <span class='hs-keyword'>where</span>
<a name="line-1098"></a>    <span class='hs-varid'>pre_inline_unconditionally</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_SimplPreInlining</span> <span class='hs-layout'>(</span><span class='hs-varid'>seDynFlags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1099"></a>    <span class='hs-varid'>mode</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span>
<a name="line-1100"></a>    <span class='hs-varid'>active</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-varid'>act</span>
<a name="line-1101"></a>             <span class='hs-comment'>-- See Note [pre/postInlineUnconditionally in gentle mode]</span>
<a name="line-1102"></a>    <span class='hs-varid'>act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>bndr</span>
<a name="line-1103"></a>    <span class='hs-varid'>try_once</span> <span class='hs-varid'>in_lam</span> <span class='hs-varid'>int_cxt</span>     <span class='hs-comment'>-- There's one textual occurrence</span>
<a name="line-1104"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNotTopLevel</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varop'>||</span> <span class='hs-varid'>early_phase</span>
<a name="line-1105"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>int_cxt</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>canInlineInLam</span> <span class='hs-varid'>rhs</span>
<a name="line-1106"></a>
<a name="line-1107"></a><span class='hs-comment'>-- Be very careful before inlining inside a lambda, because (a) we must not</span>
<a name="line-1108"></a><span class='hs-comment'>-- invalidate occurrence information, and (b) we want to avoid pushing a</span>
<a name="line-1109"></a><span class='hs-comment'>-- single allocation (here) into multiple allocations (inside lambda).</span>
<a name="line-1110"></a><span class='hs-comment'>-- Inlining a *function* with a single *saturated* call would be ok, mind you.</span>
<a name="line-1111"></a><span class='hs-comment'>--      || (if is_cheap &amp;&amp; not (canInlineInLam rhs) then pprTrace "preinline" (ppr bndr &lt;+&gt; ppr rhs) ok else ok)</span>
<a name="line-1112"></a><span class='hs-comment'>--      where</span>
<a name="line-1113"></a><span class='hs-comment'>--              is_cheap = exprIsCheap rhs</span>
<a name="line-1114"></a><span class='hs-comment'>--              ok = is_cheap &amp;&amp; int_cxt</span>
<a name="line-1115"></a>
<a name="line-1116"></a>        <span class='hs-comment'>--      int_cxt         The context isn't totally boring</span>
<a name="line-1117"></a>        <span class='hs-comment'>-- E.g. let f = \ab.BIG in \y. map f xs</span>
<a name="line-1118"></a>        <span class='hs-comment'>--      Don't want to substitute for f, because then we allocate</span>
<a name="line-1119"></a>        <span class='hs-comment'>--      its closure every time the \y is called</span>
<a name="line-1120"></a>        <span class='hs-comment'>-- But: let f = \ab.BIG in \y. map (f y) xs</span>
<a name="line-1121"></a>        <span class='hs-comment'>--      Now we do want to substitute for f, even though it's not</span>
<a name="line-1122"></a>        <span class='hs-comment'>--      saturated, because we're going to allocate a closure for</span>
<a name="line-1123"></a>        <span class='hs-comment'>--      (f y) every time round the loop anyhow.</span>
<a name="line-1124"></a>
<a name="line-1125"></a>        <span class='hs-comment'>-- canInlineInLam =&gt; free vars of rhs are (Once in_lam) or Many,</span>
<a name="line-1126"></a>        <span class='hs-comment'>-- so substituting rhs inside a lambda doesn't change the occ info.</span>
<a name="line-1127"></a>        <span class='hs-comment'>-- Sadly, not quite the same as exprIsHNF.</span>
<a name="line-1128"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1129"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isRuntimeVar</span> <span class='hs-varid'>b</span> <span class='hs-varop'>||</span> <span class='hs-varid'>canInlineInLam</span> <span class='hs-varid'>e</span>
<a name="line-1130"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishIsCode</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>canInlineInLam</span> <span class='hs-varid'>e</span>
<a name="line-1131"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1132"></a>      <span class='hs-comment'>-- not ticks.  Counting ticks cannot be duplicated, and non-counting</span>
<a name="line-1133"></a>      <span class='hs-comment'>-- ticks around a Lam will disappear anyway.</span>
<a name="line-1134"></a>
<a name="line-1135"></a>    <span class='hs-varid'>early_phase</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-1136"></a>                    <span class='hs-conid'>Phase</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1137"></a>                    <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1138"></a><span class='hs-comment'>-- If we don't have this early_phase test, consider</span>
<a name="line-1139"></a><span class='hs-comment'>--      x = length [1,2,3]</span>
<a name="line-1140"></a><span class='hs-comment'>-- The full laziness pass carefully floats all the cons cells to</span>
<a name="line-1141"></a><span class='hs-comment'>-- top level, and preInlineUnconditionally floats them all back in.</span>
<a name="line-1142"></a><span class='hs-comment'>-- Result is (a) static allocation replaced by dynamic allocation</span>
<a name="line-1143"></a><span class='hs-comment'>--           (b) many simplifier iterations because this tickles</span>
<a name="line-1144"></a><span class='hs-comment'>--               a related problem; only one inlining per pass</span>
<a name="line-1145"></a><span class='hs-comment'>--</span>
<a name="line-1146"></a><span class='hs-comment'>-- On the other hand, I have seen cases where top-level fusion is</span>
<a name="line-1147"></a><span class='hs-comment'>-- lost if we don't inline top level thing (e.g. string constants)</span>
<a name="line-1148"></a><span class='hs-comment'>-- Hence the test for phase zero (which is the phase for all the final</span>
<a name="line-1149"></a><span class='hs-comment'>-- simplifications).  Until phase zero we take no special notice of</span>
<a name="line-1150"></a><span class='hs-comment'>-- top level things, but then we become more leery about inlining</span>
<a name="line-1151"></a><span class='hs-comment'>-- them.</span>
<a name="line-1152"></a>
<a name="line-1153"></a><span class='hs-comment'>{-
<a name="line-1154"></a>************************************************************************
<a name="line-1155"></a>*                                                                      *
<a name="line-1156"></a>                  postInlineUnconditionally
<a name="line-1157"></a>*                                                                      *
<a name="line-1158"></a>************************************************************************
<a name="line-1159"></a>
<a name="line-1160"></a>postInlineUnconditionally
<a name="line-1161"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1162"></a>@postInlineUnconditionally@ decides whether to unconditionally inline
<a name="line-1163"></a>a thing based on the form of its RHS; in particular if it has a
<a name="line-1164"></a>trivial RHS.  If so, we can inline and discard the binding altogether.
<a name="line-1165"></a>
<a name="line-1166"></a>NB: a loop breaker has must_keep_binding = True and non-loop-breakers
<a name="line-1167"></a>only have *forward* references. Hence, it's safe to discard the binding
<a name="line-1168"></a>
<a name="line-1169"></a>NOTE: This isn't our last opportunity to inline.  We're at the binding
<a name="line-1170"></a>site right now, and we'll get another opportunity when we get to the
<a name="line-1171"></a>occurrence(s)
<a name="line-1172"></a>
<a name="line-1173"></a>Note that we do this unconditional inlining only for trival RHSs.
<a name="line-1174"></a>Don't inline even WHNFs inside lambdas; doing so may simply increase
<a name="line-1175"></a>allocation when the function is called. This isn't the last chance; see
<a name="line-1176"></a>NOTE above.
<a name="line-1177"></a>
<a name="line-1178"></a>NB: Even inline pragmas (e.g. IMustBeINLINEd) are ignored here Why?
<a name="line-1179"></a>Because we don't even want to inline them into the RHS of constructor
<a name="line-1180"></a>arguments. See NOTE above
<a name="line-1181"></a>
<a name="line-1182"></a>NB: At one time even NOINLINE was ignored here: if the rhs is trivial
<a name="line-1183"></a>it's best to inline it anyway.  We often get a=E; b=a from desugaring,
<a name="line-1184"></a>with both a and b marked NOINLINE.  But that seems incompatible with
<a name="line-1185"></a>our new view that inlining is like a RULE, so I'm sticking to the 'active'
<a name="line-1186"></a>story for now.
<a name="line-1187"></a>-}</span>
<a name="line-1188"></a>
<a name="line-1189"></a><a name="postInlineUnconditionally"></a><span class='hs-definition'>postInlineUnconditionally</span>
<a name="line-1190"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-1191"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>            <span class='hs-comment'>-- The binder (*not* a CoVar), including its unfolding</span>
<a name="line-1192"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span>          <span class='hs-comment'>-- From the InId</span>
<a name="line-1193"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1194"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1195"></a><span class='hs-comment'>-- Precondition: rhs satisfies the let/app invariant</span>
<a name="line-1196"></a><span class='hs-comment'>-- See Note [CoreSyn let/app invariant] in CoreSyn</span>
<a name="line-1197"></a><span class='hs-comment'>-- Reason: we don't want to inline single uses, or discard dead bindings,</span>
<a name="line-1198"></a><span class='hs-comment'>--         for unlifted, side-effect-ful bindings</span>
<a name="line-1199"></a><span class='hs-definition'>postInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>occ_info</span> <span class='hs-varid'>rhs</span>
<a name="line-1200"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>active</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1201"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isWeakLoopBreaker</span> <span class='hs-varid'>occ_info</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- If it's a loop-breaker of any kind, don't inline</span>
<a name="line-1202"></a>                                        <span class='hs-comment'>-- because it might be referred to "earlier"</span>
<a name="line-1203"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableUnfolding</span> <span class='hs-varid'>unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- Note [Stable unfoldings and postInlineUnconditionally]</span>
<a name="line-1204"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- Note [Top level and postInlineUnconditionally]</span>
<a name="line-1205"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>rhs</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1206"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1207"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occ_info</span> <span class='hs-keyword'>of</span>
<a name="line-1208"></a>        <span class='hs-comment'>-- The point of examining occ_info here is that for *non-values*</span>
<a name="line-1209"></a>        <span class='hs-comment'>-- that occur outside a lambda, the call-site inliner won't have</span>
<a name="line-1210"></a>        <span class='hs-comment'>-- a chance (because it doesn't know that the thing</span>
<a name="line-1211"></a>        <span class='hs-comment'>-- only occurs once).   The pre-inliner won't have gotten</span>
<a name="line-1212"></a>        <span class='hs-comment'>-- it either, if the thing occurs in more than one branch</span>
<a name="line-1213"></a>        <span class='hs-comment'>-- So the main target is things like</span>
<a name="line-1214"></a>        <span class='hs-comment'>--      let x = f y in</span>
<a name="line-1215"></a>        <span class='hs-comment'>--      case v of</span>
<a name="line-1216"></a>        <span class='hs-comment'>--         True  -&gt; case x of ...</span>
<a name="line-1217"></a>        <span class='hs-comment'>--         False -&gt; case x of ...</span>
<a name="line-1218"></a>        <span class='hs-comment'>-- This is very important in practice; e.g. wheel-seive1 doubles</span>
<a name="line-1219"></a>        <span class='hs-comment'>-- in allocation if you miss this out</span>
<a name="line-1220"></a>      <span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_lam</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_int_cxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>int_cxt</span> <span class='hs-layout'>}</span>
<a name="line-1221"></a>               <span class='hs-comment'>-- OneOcc =&gt; no code-duplication issue</span>
<a name="line-1222"></a>        <span class='hs-keyglyph'>-&gt;</span>     <span class='hs-varid'>smallEnoughToInline</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>unfolding</span>     <span class='hs-comment'>-- Small enough to dup</span>
<a name="line-1223"></a>                        <span class='hs-comment'>-- ToDo: consider discount on smallEnoughToInline if int_cxt is true</span>
<a name="line-1224"></a>                        <span class='hs-comment'>--</span>
<a name="line-1225"></a>                        <span class='hs-comment'>-- NB: Do NOT inline arbitrarily big things, even if one_br is True</span>
<a name="line-1226"></a>                        <span class='hs-comment'>-- Reason: doing so risks exponential behaviour.  We simplify a big</span>
<a name="line-1227"></a>                        <span class='hs-comment'>--         expression, inline it, and simplify it again.  But if the</span>
<a name="line-1228"></a>                        <span class='hs-comment'>--         very same thing happens in the big expression, we get</span>
<a name="line-1229"></a>                        <span class='hs-comment'>--         exponential cost!</span>
<a name="line-1230"></a>                        <span class='hs-comment'>-- PRINCIPLE: when we've already simplified an expression once,</span>
<a name="line-1231"></a>                        <span class='hs-comment'>-- make sure that we only inline it if it's reasonably small.</span>
<a name="line-1232"></a>
<a name="line-1233"></a>           <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>in_lam</span> <span class='hs-varop'>||</span>
<a name="line-1234"></a>                        <span class='hs-comment'>-- Outside a lambda, we want to be reasonably aggressive</span>
<a name="line-1235"></a>                        <span class='hs-comment'>-- about inlining into multiple branches of case</span>
<a name="line-1236"></a>                        <span class='hs-comment'>-- e.g. let x = &lt;non-value&gt;</span>
<a name="line-1237"></a>                        <span class='hs-comment'>--      in case y of { C1 -&gt; ..x..; C2 -&gt; ..x..; C3 -&gt; ... }</span>
<a name="line-1238"></a>                        <span class='hs-comment'>-- Inlining can be a big win if C3 is the hot-spot, even if</span>
<a name="line-1239"></a>                        <span class='hs-comment'>-- the uses in C1, C2 are not 'interesting'</span>
<a name="line-1240"></a>                        <span class='hs-comment'>-- An example that gets worse if you add int_cxt here is 'clausify'</span>
<a name="line-1241"></a>
<a name="line-1242"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>isCheapUnfolding</span> <span class='hs-varid'>unfolding</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>int_cxt</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1243"></a>                        <span class='hs-comment'>-- isCheap =&gt; acceptable work duplication; in_lam may be true</span>
<a name="line-1244"></a>                        <span class='hs-comment'>-- int_cxt to prevent us inlining inside a lambda without some</span>
<a name="line-1245"></a>                        <span class='hs-comment'>-- good reason.  See the notes on int_cxt in preInlineUnconditionally</span>
<a name="line-1246"></a>
<a name="line-1247"></a>      <span class='hs-conid'>IAmDead</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- This happens; for example, the case_bndr during case of</span>
<a name="line-1248"></a>                        <span class='hs-comment'>-- known constructor:  case (a,b) of x { (p,q) -&gt; ... }</span>
<a name="line-1249"></a>                        <span class='hs-comment'>-- Here x isn't mentioned in the RHS, so we don't want to</span>
<a name="line-1250"></a>                        <span class='hs-comment'>-- create the (dead) let-binding  let x = (a,b) in ...</span>
<a name="line-1251"></a>
<a name="line-1252"></a>      <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1253"></a>
<a name="line-1254"></a><span class='hs-comment'>-- Here's an example that we don't handle well:</span>
<a name="line-1255"></a><span class='hs-comment'>--      let f = if b then Left (\x.BIG) else Right (\y.BIG)</span>
<a name="line-1256"></a><span class='hs-comment'>--      in \y. ....case f of {...} ....</span>
<a name="line-1257"></a><span class='hs-comment'>-- Here f is used just once, and duplicating the case work is fine (exprIsCheap).</span>
<a name="line-1258"></a><span class='hs-comment'>-- But</span>
<a name="line-1259"></a><span class='hs-comment'>--  - We can't preInlineUnconditionally because that woud invalidate</span>
<a name="line-1260"></a><span class='hs-comment'>--    the occ info for b.</span>
<a name="line-1261"></a><span class='hs-comment'>--  - We can't postInlineUnconditionally because the RHS is big, and</span>
<a name="line-1262"></a><span class='hs-comment'>--    that risks exponential behaviour</span>
<a name="line-1263"></a><span class='hs-comment'>--  - We can't call-site inline, because the rhs is big</span>
<a name="line-1264"></a><span class='hs-comment'>-- Alas!</span>
<a name="line-1265"></a>
<a name="line-1266"></a>  <span class='hs-keyword'>where</span>
<a name="line-1267"></a>    <span class='hs-varid'>unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>bndr</span>
<a name="line-1268"></a>    <span class='hs-varid'>dflags</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seDynFlags</span> <span class='hs-varid'>env</span>
<a name="line-1269"></a>    <span class='hs-varid'>active</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1270"></a>        <span class='hs-comment'>-- See Note [pre/postInlineUnconditionally in gentle mode]</span>
<a name="line-1271"></a>
<a name="line-1272"></a><span class='hs-comment'>{-
<a name="line-1273"></a>Note [Top level and postInlineUnconditionally]
<a name="line-1274"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1275"></a>We don't do postInlineUnconditionally for top-level things (even for
<a name="line-1276"></a>ones that are trivial):
<a name="line-1277"></a>
<a name="line-1278"></a>  * Doing so will inline top-level error expressions that have been
<a name="line-1279"></a>    carefully floated out by FloatOut.  More generally, it might
<a name="line-1280"></a>    replace static allocation with dynamic.
<a name="line-1281"></a>
<a name="line-1282"></a>  * Even for trivial expressions there's a problem.  Consider
<a name="line-1283"></a>      {-# RULE "foo" forall (xs::[T]). reverse xs = ruggle xs #-}
<a name="line-1284"></a>      blah xs = reverse xs
<a name="line-1285"></a>      ruggle = sort
<a name="line-1286"></a>    In one simplifier pass we might fire the rule, getting
<a name="line-1287"></a>      blah xs = ruggle xs
<a name="line-1288"></a>    but in *that* simplifier pass we must not do postInlineUnconditionally
<a name="line-1289"></a>    on 'ruggle' because then we'll have an unbound occurrence of 'ruggle'
<a name="line-1290"></a>
<a name="line-1291"></a>    If the rhs is trivial it'll be inlined by callSiteInline, and then
<a name="line-1292"></a>    the binding will be dead and discarded by the next use of OccurAnal
<a name="line-1293"></a>
<a name="line-1294"></a>  * There is less point, because the main goal is to get rid of local
<a name="line-1295"></a>    bindings used in multiple case branches.
<a name="line-1296"></a>
<a name="line-1297"></a>  * The inliner should inline trivial things at call sites anyway.
<a name="line-1298"></a>
<a name="line-1299"></a>  * The Id might be exported.  We could check for that separately,
<a name="line-1300"></a>    but since we aren't going to postInlineUnconditionally /any/
<a name="line-1301"></a>    top-level bindings, we don't need to test.
<a name="line-1302"></a>
<a name="line-1303"></a>Note [Stable unfoldings and postInlineUnconditionally]
<a name="line-1304"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1305"></a>Do not do postInlineUnconditionally if the Id has an stable unfolding,
<a name="line-1306"></a>otherwise we lose the unfolding.  Example
<a name="line-1307"></a>
<a name="line-1308"></a>     -- f has stable unfolding with rhs (e |&gt; co)
<a name="line-1309"></a>     --   where 'e' is big
<a name="line-1310"></a>     f = e |&gt; co
<a name="line-1311"></a>
<a name="line-1312"></a>Then there's a danger we'll optimise to
<a name="line-1313"></a>
<a name="line-1314"></a>     f' = e
<a name="line-1315"></a>     f = f' |&gt; co
<a name="line-1316"></a>
<a name="line-1317"></a>and now postInlineUnconditionally, losing the stable unfolding on f.  Now f'
<a name="line-1318"></a>won't inline because 'e' is too big.
<a name="line-1319"></a>
<a name="line-1320"></a>    c.f. Note [Stable unfoldings and preInlineUnconditionally]
<a name="line-1321"></a>
<a name="line-1322"></a>
<a name="line-1323"></a>************************************************************************
<a name="line-1324"></a>*                                                                      *
<a name="line-1325"></a>        Rebuilding a lambda
<a name="line-1326"></a>*                                                                      *
<a name="line-1327"></a>************************************************************************
<a name="line-1328"></a>-}</span>
<a name="line-1329"></a>
<a name="line-1330"></a><a name="mkLam"></a><span class='hs-definition'>mkLam</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1331"></a><span class='hs-comment'>-- mkLam tries three things</span>
<a name="line-1332"></a><span class='hs-comment'>--      a) eta reduction, if that gives a trivial expression</span>
<a name="line-1333"></a><span class='hs-comment'>--      b) eta expansion [only if there are some value lambdas]</span>
<a name="line-1334"></a>
<a name="line-1335"></a><span class='hs-definition'>mkLam</span> <span class='hs-sel'>_env</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span> <span class='hs-sel'>_cont</span>
<a name="line-1336"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>body</span>
<a name="line-1337"></a><span class='hs-definition'>mkLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1338"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-1339"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-layout'>}</span>
<a name="line-1340"></a>  <span class='hs-keyword'>where</span>
<a name="line-1341"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1342"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1343"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-varid'>bad</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-1344"></a>        <span class='hs-comment'>-- Note [Casts and lambdas]</span>
<a name="line-1345"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lam</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1346"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCast</span> <span class='hs-varid'>lam</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkPiCos</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1347"></a>      <span class='hs-keyword'>where</span>
<a name="line-1348"></a>        <span class='hs-varid'>co_vars</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfCo</span> <span class='hs-varid'>co</span>
<a name="line-1349"></a>        <span class='hs-varid'>bad</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>co_vars</span>
<a name="line-1350"></a>
<a name="line-1351"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1352"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>bndrs1</span><span class='hs-layout'>)</span> <span class='hs-varid'>body1</span>
<a name="line-1353"></a>      <span class='hs-keyword'>where</span>
<a name="line-1354"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>bndrs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>body</span>
<a name="line-1355"></a>
<a name="line-1356"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1357"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>t</span>
<a name="line-1358"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTick</span> <span class='hs-varid'>t</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>expr</span>
<a name="line-1359"></a>
<a name="line-1360"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1361"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_DoEtaReduction</span> <span class='hs-varid'>dflags</span>
<a name="line-1362"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>etad_lam</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryEtaReduce</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1363"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>EtaReduction</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1364"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>etad_lam</span> <span class='hs-layout'>}</span>
<a name="line-1365"></a>
<a name="line-1366"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>contIsRhs</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- See Note [Eta-expanding lambdas]</span>
<a name="line-1367"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1368"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isRuntimeVar</span> <span class='hs-varid'>bndrs</span>
<a name="line-1369"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>body_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprEtaExpandArity</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>body</span>
<a name="line-1370"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>body_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>
<a name="line-1371"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>EtaExpansion</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1372"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>etaExpand</span> <span class='hs-varid'>body_arity</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1373"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>traceSmpl</span> <span class='hs-str'>"eta expand"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"before"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1374"></a>                                          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"after"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1375"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-1376"></a>
<a name="line-1377"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1378"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1379"></a>
<a name="line-1380"></a><span class='hs-comment'>{-
<a name="line-1381"></a>Note [Eta expanding lambdas]
<a name="line-1382"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1383"></a>In general we *do* want to eta-expand lambdas. Consider
<a name="line-1384"></a>   f (\x -&gt; case x of (a,b) -&gt; \s -&gt; blah)
<a name="line-1385"></a>where 's' is a state token, and hence can be eta expanded.  This
<a name="line-1386"></a>showed up in the code for GHc.IO.Handle.Text.hPutChar, a rather
<a name="line-1387"></a>important function!
<a name="line-1388"></a>
<a name="line-1389"></a>The eta-expansion will never happen unless we do it now.  (Well, it's
<a name="line-1390"></a>possible that CorePrep will do it, but CorePrep only has a half-baked
<a name="line-1391"></a>eta-expander that can't deal with casts.  So it's much better to do it
<a name="line-1392"></a>here.)
<a name="line-1393"></a>
<a name="line-1394"></a>However, when the lambda is let-bound, as the RHS of a let, we have a
<a name="line-1395"></a>better eta-expander (in the form of tryEtaExpandRhs), so we don't
<a name="line-1396"></a>bother to try expansion in mkLam in that case; hence the contIsRhs
<a name="line-1397"></a>guard.
<a name="line-1398"></a>
<a name="line-1399"></a>NB: We check the SimplEnv (sm_eta_expand), not DynFlags.
<a name="line-1400"></a>    See Note [No eta expansion in stable unfoldings]
<a name="line-1401"></a>
<a name="line-1402"></a>Note [Casts and lambdas]
<a name="line-1403"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1404"></a>Consider
<a name="line-1405"></a>        (\x. (\y. e) `cast` g1) `cast` g2
<a name="line-1406"></a>There is a danger here that the two lambdas look separated, and the
<a name="line-1407"></a>full laziness pass might float an expression to between the two.
<a name="line-1408"></a>
<a name="line-1409"></a>So this equation in mkLam' floats the g1 out, thus:
<a name="line-1410"></a>        (\x. e `cast` g1)  --&gt;  (\x.e) `cast` (tx -&gt; g1)
<a name="line-1411"></a>where x:tx.
<a name="line-1412"></a>
<a name="line-1413"></a>In general, this floats casts outside lambdas, where (I hope) they
<a name="line-1414"></a>might meet and cancel with some other cast:
<a name="line-1415"></a>        \x. e `cast` co   ===&gt;   (\x. e) `cast` (tx -&gt; co)
<a name="line-1416"></a>        /\a. e `cast` co  ===&gt;   (/\a. e) `cast` (/\a. co)
<a name="line-1417"></a>        /\g. e `cast` co  ===&gt;   (/\g. e) `cast` (/\g. co)
<a name="line-1418"></a>                          (if not (g `in` co))
<a name="line-1419"></a>
<a name="line-1420"></a>Notice that it works regardless of 'e'.  Originally it worked only
<a name="line-1421"></a>if 'e' was itself a lambda, but in some cases that resulted in
<a name="line-1422"></a>fruitless iteration in the simplifier.  A good example was when
<a name="line-1423"></a>compiling Text.ParserCombinators.ReadPrec, where we had a definition
<a name="line-1424"></a>like    (\x. Get `cast` g)
<a name="line-1425"></a>where Get is a constructor with nonzero arity.  Then mkLam eta-expanded
<a name="line-1426"></a>the Get, and the next iteration eta-reduced it, and then eta-expanded
<a name="line-1427"></a>it again.
<a name="line-1428"></a>
<a name="line-1429"></a>Note also the side condition for the case of coercion binders.
<a name="line-1430"></a>It does not make sense to transform
<a name="line-1431"></a>        /\g. e `cast` g  ==&gt;  (/\g.e) `cast` (/\g.g)
<a name="line-1432"></a>because the latter is not well-kinded.
<a name="line-1433"></a>
<a name="line-1434"></a>************************************************************************
<a name="line-1435"></a>*                                                                      *
<a name="line-1436"></a>              Eta expansion
<a name="line-1437"></a>*                                                                      *
<a name="line-1438"></a>************************************************************************
<a name="line-1439"></a>-}</span>
<a name="line-1440"></a>
<a name="line-1441"></a><a name="tryEtaExpandRhs"></a><span class='hs-definition'>tryEtaExpandRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1442"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arity</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1443"></a><span class='hs-comment'>-- See Note [Eta-expanding at let bindings]</span>
<a name="line-1444"></a><span class='hs-comment'>-- If tryEtaExpandRhs rhs = (n, is_bot, rhs') then</span>
<a name="line-1445"></a><span class='hs-comment'>--   (a) rhs' has manifest arity</span>
<a name="line-1446"></a><span class='hs-comment'>--   (b) if is_bot is True then rhs' applied to n args is guaranteed bottom</span>
<a name="line-1447"></a><span class='hs-definition'>tryEtaExpandRhs</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-1448"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>bndr</span>
<a name="line-1449"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>manifestArity</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1450"></a>    <span class='hs-comment'>-- Note [Do not eta-expand join points]</span>
<a name="line-1451"></a>
<a name="line-1452"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1453"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_bot</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try_expand</span>
<a name="line-1454"></a>
<a name="line-1455"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-varid'>new_arity</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>old_id_arity</span><span class='hs-layout'>,</span>
<a name="line-1456"></a>               <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Arity decrease:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>old_id_arity</span>
<a name="line-1457"></a>                <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>old_arity</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_arity</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1458"></a>                        <span class='hs-comment'>-- Note [Arity decrease] in Simplify</span>
<a name="line-1459"></a>         <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_bot</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1460"></a>  <span class='hs-keyword'>where</span>
<a name="line-1461"></a>    <span class='hs-varid'>try_expand</span>
<a name="line-1462"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>rhs</span>
<a name="line-1463"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprArity</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1464"></a>
<a name="line-1465"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-varid'>mode</span>      <span class='hs-comment'>-- Provided eta-expansion is on</span>
<a name="line-1466"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>new_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>old_arity</span>   <span class='hs-comment'>-- And the current manifest arity isn't enough</span>
<a name="line-1467"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>EtaExpansion</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1468"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_bot</span><span class='hs-layout'>,</span> <span class='hs-varid'>etaExpand</span> <span class='hs-varid'>new_arity</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1469"></a>
<a name="line-1470"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1471"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>old_arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_bot</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>new_arity</span> <span class='hs-varop'>==</span> <span class='hs-varid'>old_arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1472"></a>
<a name="line-1473"></a>    <span class='hs-varid'>dflags</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sm_dflags</span> <span class='hs-varid'>mode</span>
<a name="line-1474"></a>    <span class='hs-varid'>old_arity</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprArity</span> <span class='hs-varid'>rhs</span> <span class='hs-comment'>-- See Note [Do not expand eta-expand PAPs]</span>
<a name="line-1475"></a>    <span class='hs-varid'>old_id_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>bndr</span>
<a name="line-1476"></a>
<a name="line-1477"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>new_arity1</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_bot</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findRhsArity</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>old_arity</span>
<a name="line-1478"></a>    <span class='hs-varid'>new_arity2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idCallArity</span> <span class='hs-varid'>bndr</span>
<a name="line-1479"></a>    <span class='hs-varid'>new_arity</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>max</span> <span class='hs-varid'>new_arity1</span> <span class='hs-varid'>new_arity2</span>
<a name="line-1480"></a>
<a name="line-1481"></a><span class='hs-comment'>{-
<a name="line-1482"></a>Note [Eta-expanding at let bindings]
<a name="line-1483"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1484"></a>We now eta expand at let-bindings, which is where the payoff comes.
<a name="line-1485"></a>The most significant thing is that we can do a simple arity analysis
<a name="line-1486"></a>(in CoreArity.findRhsArity), which we can't do for free-floating lambdas
<a name="line-1487"></a>
<a name="line-1488"></a>One useful consequence of not eta-expanding lambdas is this example:
<a name="line-1489"></a>   genMap :: C a =&gt; ...
<a name="line-1490"></a>   {-# INLINE genMap #-}
<a name="line-1491"></a>   genMap f xs = ...
<a name="line-1492"></a>
<a name="line-1493"></a>   myMap :: D a =&gt; ...
<a name="line-1494"></a>   {-# INLINE myMap #-}
<a name="line-1495"></a>   myMap = genMap
<a name="line-1496"></a>
<a name="line-1497"></a>Notice that 'genMap' should only inline if applied to two arguments.
<a name="line-1498"></a>In the stable unfolding for myMap we'll have the unfolding
<a name="line-1499"></a>    (\d -&gt; genMap Int (..d..))
<a name="line-1500"></a>We do not want to eta-expand to
<a name="line-1501"></a>    (\d f xs -&gt; genMap Int (..d..) f xs)
<a name="line-1502"></a>because then 'genMap' will inline, and it really shouldn't: at least
<a name="line-1503"></a>as far as the programmer is concerned, it's not applied to two
<a name="line-1504"></a>arguments!
<a name="line-1505"></a>
<a name="line-1506"></a>Note [Do not eta-expand join points]
<a name="line-1507"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1508"></a>Similarly to CPR (see Note [Don't CPR join points] in WorkWrap), a join point
<a name="line-1509"></a>stands well to gain from its outer binding's eta-expansion, and eta-expanding a
<a name="line-1510"></a>join point is fraught with issues like how to deal with a cast:
<a name="line-1511"></a>
<a name="line-1512"></a>    let join $j1 :: IO ()
<a name="line-1513"></a>             $j1 = ...
<a name="line-1514"></a>             $j2 :: Int -&gt; IO ()
<a name="line-1515"></a>             $j2 n = if n &gt; 0 then $j1
<a name="line-1516"></a>                              else ...
<a name="line-1517"></a>
<a name="line-1518"></a>    =&gt;
<a name="line-1519"></a>
<a name="line-1520"></a>    let join $j1 :: IO ()
<a name="line-1521"></a>             $j1 = (\eta -&gt; ...)
<a name="line-1522"></a>                     `cast` N:IO :: State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1523"></a>                                 ~  IO ()
<a name="line-1524"></a>             $j2 :: Int -&gt; IO ()
<a name="line-1525"></a>             $j2 n = (\eta -&gt; if n &gt; 0 then $j1
<a name="line-1526"></a>                                       else ...)
<a name="line-1527"></a>                     `cast` N:IO :: State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1528"></a>                                 ~  IO ()
<a name="line-1529"></a>
<a name="line-1530"></a>The cast here can't be pushed inside the lambda (since it's not casting to a
<a name="line-1531"></a>function type), so the lambda has to stay, but it can't because it contains a
<a name="line-1532"></a>reference to a join point. In fact, $j2 can't be eta-expanded at all. Rather
<a name="line-1533"></a>than try and detect this situation (and whatever other situations crop up!), we
<a name="line-1534"></a>don't bother; again, any surrounding eta-expansion will improve these join
<a name="line-1535"></a>points anyway, since an outer cast can *always* be pushed inside. By the time
<a name="line-1536"></a>CorePrep comes around, the code is very likely to look more like this:
<a name="line-1537"></a>
<a name="line-1538"></a>    let join $j1 :: State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1539"></a>             $j1 = (...) eta
<a name="line-1540"></a>             $j2 :: Int -&gt; State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1541"></a>             $j2 = if n &gt; 0 then $j1
<a name="line-1542"></a>                            else (...) eta
<a name="line-1543"></a>
<a name="line-1544"></a>Note [Do not eta-expand PAPs]
<a name="line-1545"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1546"></a>We used to have old_arity = manifestArity rhs, which meant that we
<a name="line-1547"></a>would eta-expand even PAPs.  But this gives no particular advantage,
<a name="line-1548"></a>and can lead to a massive blow-up in code size, exhibited by Trac #9020.
<a name="line-1549"></a>Suppose we have a PAP
<a name="line-1550"></a>    foo :: IO ()
<a name="line-1551"></a>    foo = returnIO ()
<a name="line-1552"></a>Then we can eta-expand do
<a name="line-1553"></a>    foo = (\eta. (returnIO () |&gt; sym g) eta) |&gt; g
<a name="line-1554"></a>where
<a name="line-1555"></a>    g :: IO () ~ State# RealWorld -&gt; (# State# RealWorld, () #)
<a name="line-1556"></a>
<a name="line-1557"></a>But there is really no point in doing this, and it generates masses of
<a name="line-1558"></a>coercions and whatnot that eventually disappear again. For T9020, GHC
<a name="line-1559"></a>allocated 6.6G beore, and 0.8G afterwards; and residency dropped from
<a name="line-1560"></a>1.8G to 45M.
<a name="line-1561"></a>
<a name="line-1562"></a>But note that this won't eta-expand, say
<a name="line-1563"></a>  f = \g -&gt; map g
<a name="line-1564"></a>Does it matter not eta-expanding such functions?  I'm not sure.  Perhaps
<a name="line-1565"></a>strictness analysis will have less to bite on?
<a name="line-1566"></a>
<a name="line-1567"></a>
<a name="line-1568"></a>************************************************************************
<a name="line-1569"></a>*                                                                      *
<a name="line-1570"></a>\subsection{Floating lets out of big lambdas}
<a name="line-1571"></a>*                                                                      *
<a name="line-1572"></a>************************************************************************
<a name="line-1573"></a>
<a name="line-1574"></a>Note [Floating and type abstraction]
<a name="line-1575"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1576"></a>Consider this:
<a name="line-1577"></a>        x = /\a. C e1 e2
<a name="line-1578"></a>We'd like to float this to
<a name="line-1579"></a>        y1 = /\a. e1
<a name="line-1580"></a>        y2 = /\a. e2
<a name="line-1581"></a>        x  = /\a. C (y1 a) (y2 a)
<a name="line-1582"></a>for the usual reasons: we want to inline x rather vigorously.
<a name="line-1583"></a>
<a name="line-1584"></a>You may think that this kind of thing is rare.  But in some programs it is
<a name="line-1585"></a>common.  For example, if you do closure conversion you might get:
<a name="line-1586"></a>
<a name="line-1587"></a>        data a :-&gt; b = forall e. (e -&gt; a -&gt; b) :$ e
<a name="line-1588"></a>
<a name="line-1589"></a>        f_cc :: forall a. a :-&gt; a
<a name="line-1590"></a>        f_cc = /\a. (\e. id a) :$ ()
<a name="line-1591"></a>
<a name="line-1592"></a>Now we really want to inline that f_cc thing so that the
<a name="line-1593"></a>construction of the closure goes away.
<a name="line-1594"></a>
<a name="line-1595"></a>So I have elaborated simplLazyBind to understand right-hand sides that look
<a name="line-1596"></a>like
<a name="line-1597"></a>        /\ a1..an. body
<a name="line-1598"></a>
<a name="line-1599"></a>and treat them specially. The real work is done in SimplUtils.abstractFloats,
<a name="line-1600"></a>but there is quite a bit of plumbing in simplLazyBind as well.
<a name="line-1601"></a>
<a name="line-1602"></a>The same transformation is good when there are lets in the body:
<a name="line-1603"></a>
<a name="line-1604"></a>        /\abc -&gt; let(rec) x = e in b
<a name="line-1605"></a>   ==&gt;
<a name="line-1606"></a>        let(rec) x' = /\abc -&gt; let x = x' a b c in e
<a name="line-1607"></a>        in
<a name="line-1608"></a>        /\abc -&gt; let x = x' a b c in b
<a name="line-1609"></a>
<a name="line-1610"></a>This is good because it can turn things like:
<a name="line-1611"></a>
<a name="line-1612"></a>        let f = /\a -&gt; letrec g = ... g ... in g
<a name="line-1613"></a>into
<a name="line-1614"></a>        letrec g' = /\a -&gt; ... g' a ...
<a name="line-1615"></a>        in
<a name="line-1616"></a>        let f = /\ a -&gt; g' a
<a name="line-1617"></a>
<a name="line-1618"></a>which is better.  In effect, it means that big lambdas don't impede
<a name="line-1619"></a>let-floating.
<a name="line-1620"></a>
<a name="line-1621"></a>This optimisation is CRUCIAL in eliminating the junk introduced by
<a name="line-1622"></a>desugaring mutually recursive definitions.  Don't eliminate it lightly!
<a name="line-1623"></a>
<a name="line-1624"></a>[May 1999]  If we do this transformation *regardless* then we can
<a name="line-1625"></a>end up with some pretty silly stuff.  For example,
<a name="line-1626"></a>
<a name="line-1627"></a>        let
<a name="line-1628"></a>            st = /\ s -&gt; let { x1=r1 ; x2=r2 } in ...
<a name="line-1629"></a>        in ..
<a name="line-1630"></a>becomes
<a name="line-1631"></a>        let y1 = /\s -&gt; r1
<a name="line-1632"></a>            y2 = /\s -&gt; r2
<a name="line-1633"></a>            st = /\s -&gt; ...[y1 s/x1, y2 s/x2]
<a name="line-1634"></a>        in ..
<a name="line-1635"></a>
<a name="line-1636"></a>Unless the "..." is a WHNF there is really no point in doing this.
<a name="line-1637"></a>Indeed it can make things worse.  Suppose x1 is used strictly,
<a name="line-1638"></a>and is of the form
<a name="line-1639"></a>
<a name="line-1640"></a>        x1* = case f y of { (a,b) -&gt; e }
<a name="line-1641"></a>
<a name="line-1642"></a>If we abstract this wrt the tyvar we then can't do the case inline
<a name="line-1643"></a>as we would normally do.
<a name="line-1644"></a>
<a name="line-1645"></a>That's why the whole transformation is part of the same process that
<a name="line-1646"></a>floats let-bindings and constructor arguments out of RHSs.  In particular,
<a name="line-1647"></a>it is guarded by the doFloatFromRhs call in simplLazyBind.
<a name="line-1648"></a>
<a name="line-1649"></a>Note [Which type variables to abstract over]
<a name="line-1650"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1651"></a>Abstract only over the type variables free in the rhs wrt which the
<a name="line-1652"></a>new binding is abstracted.  Note that
<a name="line-1653"></a>
<a name="line-1654"></a>  * The naive approach of abstracting wrt the
<a name="line-1655"></a>    tyvars free in the Id's /type/ fails. Consider:
<a name="line-1656"></a>        /\ a b -&gt; let t :: (a,b) = (e1, e2)
<a name="line-1657"></a>                      x :: a     = fst t
<a name="line-1658"></a>                  in ...
<a name="line-1659"></a>    Here, b isn't free in x's type, but we must nevertheless
<a name="line-1660"></a>    abstract wrt b as well, because t's type mentions b.
<a name="line-1661"></a>    Since t is floated too, we'd end up with the bogus:
<a name="line-1662"></a>         poly_t = /\ a b -&gt; (e1, e2)
<a name="line-1663"></a>         poly_x = /\ a   -&gt; fst (poly_t a *b*)
<a name="line-1664"></a>
<a name="line-1665"></a>  * We must do closeOverKinds.  Example (Trac #10934):
<a name="line-1666"></a>       f = /\k (f:k-&gt;*) (a:k). let t = AccFailure @ (f a) in ...
<a name="line-1667"></a>    Here we want to float 't', but we must remember to abstract over
<a name="line-1668"></a>    'k' as well, even though it is not explicitly mentioned in the RHS,
<a name="line-1669"></a>    otherwise we get
<a name="line-1670"></a>       t = /\ (f:k-&gt;*) (a:k). AccFailure @ (f a)
<a name="line-1671"></a>    which is obviously bogus.
<a name="line-1672"></a>-}</span>
<a name="line-1673"></a>
<a name="line-1674"></a><a name="abstractFloats"></a><span class='hs-definition'>abstractFloats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplFloats</span>
<a name="line-1675"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>OutBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1676"></a><span class='hs-definition'>abstractFloats</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>main_tvs</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>body</span>
<a name="line-1677"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>notNull</span> <span class='hs-varid'>body_floats</span> <span class='hs-layout'>)</span>
<a name="line-1678"></a>    <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isNilOL</span> <span class='hs-layout'>(</span><span class='hs-varid'>sfJoinFloats</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1679"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>float_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAccumLM</span> <span class='hs-varid'>abstract</span> <span class='hs-varid'>empty_subst</span> <span class='hs-varid'>body_floats</span>
<a name="line-1680"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_binds</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-varid'>substExpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"abstract_floats1"</span><span class='hs-layout'>)</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1681"></a>  <span class='hs-keyword'>where</span>
<a name="line-1682"></a>    <span class='hs-varid'>is_top_lvl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>
<a name="line-1683"></a>    <span class='hs-varid'>main_tv_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>main_tvs</span>
<a name="line-1684"></a>    <span class='hs-varid'>body_floats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>letFloatBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>sfLetFloats</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span>
<a name="line-1685"></a>    <span class='hs-varid'>empty_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-varid'>mkEmptySubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>sfInScope</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span>
<a name="line-1686"></a>
<a name="line-1687"></a>    <span class='hs-varid'>abstract</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutBind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-conid'>Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutBind</span><span class='hs-layout'>)</span>
<a name="line-1688"></a>    <span class='hs-varid'>abstract</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1689"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_app</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_poly1</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>id</span>
<a name="line-1690"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id2</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_poly2</span> <span class='hs-varid'>poly_id1</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs'</span>
<a name="line-1691"></a>                 <span class='hs-varid'>subst'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-varid'>extendIdSubst</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>id</span> <span class='hs-varid'>poly_app</span>
<a name="line-1692"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>poly_id2</span> <span class='hs-varid'>poly_rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1693"></a>      <span class='hs-keyword'>where</span>
<a name="line-1694"></a>        <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-varid'>substExpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"abstract_floats2"</span><span class='hs-layout'>)</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>rhs</span>
<a name="line-1695"></a>
<a name="line-1696"></a>        <span class='hs-comment'>-- tvs_here: see Note [Which type variables to abstract over]</span>
<a name="line-1697"></a>        <span class='hs-varid'>tvs_here</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toposortTyVars</span> <span class='hs-varop'>$</span>
<a name="line-1698"></a>                   <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>main_tv_set</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1699"></a>                   <span class='hs-varid'>closeOverKindsList</span> <span class='hs-varop'>$</span>
<a name="line-1700"></a>                   <span class='hs-varid'>exprSomeFreeVarsList</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>rhs'</span>
<a name="line-1701"></a>
<a name="line-1702"></a>    <span class='hs-varid'>abstract</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span>
<a name="line-1703"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_apps</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndUnzipM</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_poly1</span> <span class='hs-varid'>tvs_here</span><span class='hs-layout'>)</span> <span class='hs-varid'>ids</span>
<a name="line-1704"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>subst'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-varid'>extendSubstList</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>ids</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>poly_apps</span><span class='hs-layout'>)</span>
<a name="line-1705"></a>                  <span class='hs-varid'>poly_pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mk_poly2</span> <span class='hs-varid'>poly_id</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs'</span>
<a name="line-1706"></a>                               <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>poly_ids</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>rhss</span>
<a name="line-1707"></a>                               <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreSubst</span><span class='hs-varop'>.</span><span class='hs-varid'>substExpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"abstract_floats"</span><span class='hs-layout'>)</span>
<a name="line-1708"></a>                                                                <span class='hs-varid'>subst'</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>]</span>
<a name="line-1709"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rec</span> <span class='hs-varid'>poly_pairs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1710"></a>       <span class='hs-keyword'>where</span>
<a name="line-1711"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>ids</span><span class='hs-layout'>,</span><span class='hs-varid'>rhss</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>prs</span>
<a name="line-1712"></a>                <span class='hs-comment'>-- For a recursive group, it's a bit of a pain to work out the minimal</span>
<a name="line-1713"></a>                <span class='hs-comment'>-- set of tyvars over which to abstract:</span>
<a name="line-1714"></a>                <span class='hs-comment'>--      /\ a b c.  let x = ...a... in</span>
<a name="line-1715"></a>                <span class='hs-comment'>--                 letrec { p = ...x...q...</span>
<a name="line-1716"></a>                <span class='hs-comment'>--                          q = .....p...b... } in</span>
<a name="line-1717"></a>                <span class='hs-comment'>--                 ...</span>
<a name="line-1718"></a>                <span class='hs-comment'>-- Since 'x' is abstracted over 'a', the {p,q} group must be abstracted</span>
<a name="line-1719"></a>                <span class='hs-comment'>-- over 'a' (because x is replaced by (poly_x a)) as well as 'b'.</span>
<a name="line-1720"></a>                <span class='hs-comment'>-- Since it's a pain, we just use the whole set, which is always safe</span>
<a name="line-1721"></a>                <span class='hs-comment'>--</span>
<a name="line-1722"></a>                <span class='hs-comment'>-- If you ever want to be more selective, remember this bizarre case too:</span>
<a name="line-1723"></a>                <span class='hs-comment'>--      x::a = x</span>
<a name="line-1724"></a>                <span class='hs-comment'>-- Here, we must abstract 'x' over 'a'.</span>
<a name="line-1725"></a>         <span class='hs-varid'>tvs_here</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toposortTyVars</span> <span class='hs-varid'>main_tvs</span>
<a name="line-1726"></a>
<a name="line-1727"></a>    <span class='hs-varid'>mk_poly1</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1728"></a>    <span class='hs-varid'>mk_poly1</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>var</span>
<a name="line-1729"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-1730"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span>  <span class='hs-varid'>poly_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setNameUnique</span> <span class='hs-layout'>(</span><span class='hs-varid'>idName</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span>           <span class='hs-comment'>-- Keep same name</span>
<a name="line-1731"></a>                  <span class='hs-varid'>poly_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInvForAllTys</span> <span class='hs-varid'>tvs_here</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- But new type of course</span>
<a name="line-1732"></a>                  <span class='hs-varid'>poly_id</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>transferPolyIdInfo</span> <span class='hs-varid'>var</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varop'>$</span> <span class='hs-comment'>-- Note [transferPolyIdInfo] in Id.hs</span>
<a name="line-1733"></a>                              <span class='hs-varid'>mkLocalIdOrCoVar</span> <span class='hs-varid'>poly_name</span> <span class='hs-varid'>poly_ty</span>
<a name="line-1734"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>poly_id</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>tvs_here</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1735"></a>                <span class='hs-comment'>-- In the olden days, it was crucial to copy the occInfo of the original var,</span>
<a name="line-1736"></a>                <span class='hs-comment'>-- because we were looking at occurrence-analysed but as yet unsimplified code!</span>
<a name="line-1737"></a>                <span class='hs-comment'>-- In particular, we mustn't lose the loop breakers.  BUT NOW we are looking</span>
<a name="line-1738"></a>                <span class='hs-comment'>-- at already simplified code, so it doesn't matter</span>
<a name="line-1739"></a>                <span class='hs-comment'>--</span>
<a name="line-1740"></a>                <span class='hs-comment'>-- It's even right to retain single-occurrence or dead-var info:</span>
<a name="line-1741"></a>                <span class='hs-comment'>-- Suppose we started with  /\a -&gt; let x = E in B</span>
<a name="line-1742"></a>                <span class='hs-comment'>-- where x occurs once in B. Then we transform to:</span>
<a name="line-1743"></a>                <span class='hs-comment'>--      let x' = /\a -&gt; E in /\a -&gt; let x* = x' a in B</span>
<a name="line-1744"></a>                <span class='hs-comment'>-- where x* has an INLINE prag on it.  Now, once x* is inlined,</span>
<a name="line-1745"></a>                <span class='hs-comment'>-- the occurrences of x' will be just the occurrences originally</span>
<a name="line-1746"></a>                <span class='hs-comment'>-- pinned on x.</span>
<a name="line-1747"></a>
<a name="line-1748"></a>    <span class='hs-varid'>mk_poly2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1749"></a>    <span class='hs-varid'>mk_poly2</span> <span class='hs-varid'>poly_id</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs</span>
<a name="line-1750"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>unf</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_rhs</span><span class='hs-layout'>)</span>
<a name="line-1751"></a>      <span class='hs-keyword'>where</span>
<a name="line-1752"></a>        <span class='hs-varid'>poly_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs</span>
<a name="line-1753"></a>        <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUnfolding</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>InlineRhs</span> <span class='hs-varid'>is_top_lvl</span> <span class='hs-conid'>False</span> <span class='hs-varid'>poly_rhs</span>
<a name="line-1754"></a>
<a name="line-1755"></a>        <span class='hs-comment'>-- We want the unfolding.  Consider</span>
<a name="line-1756"></a>        <span class='hs-comment'>--      let</span>
<a name="line-1757"></a>        <span class='hs-comment'>--            x = /\a. let y = ... in Just y</span>
<a name="line-1758"></a>        <span class='hs-comment'>--      in body</span>
<a name="line-1759"></a>        <span class='hs-comment'>-- Then we float the y-binding out (via abstractFloats and addPolyBind)</span>
<a name="line-1760"></a>        <span class='hs-comment'>-- but 'x' may well then be inlined in 'body' in which case we'd like the</span>
<a name="line-1761"></a>        <span class='hs-comment'>-- opportunity to inline 'y' too.</span>
<a name="line-1762"></a>
<a name="line-1763"></a><span class='hs-comment'>{-
<a name="line-1764"></a>Note [Abstract over coercions]
<a name="line-1765"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1766"></a>If a coercion variable (g :: a ~ Int) is free in the RHS, then so is the
<a name="line-1767"></a>type variable a.  Rather than sort this mess out, we simply bale out and abstract
<a name="line-1768"></a>wrt all the type variables if any of them are coercion variables.
<a name="line-1769"></a>
<a name="line-1770"></a>
<a name="line-1771"></a>Historical note: if you use let-bindings instead of a substitution, beware of this:
<a name="line-1772"></a>
<a name="line-1773"></a>                -- Suppose we start with:
<a name="line-1774"></a>                --
<a name="line-1775"></a>                --      x = /\ a -&gt; let g = G in E
<a name="line-1776"></a>                --
<a name="line-1777"></a>                -- Then we'll float to get
<a name="line-1778"></a>                --
<a name="line-1779"></a>                --      x = let poly_g = /\ a -&gt; G
<a name="line-1780"></a>                --          in /\ a -&gt; let g = poly_g a in E
<a name="line-1781"></a>                --
<a name="line-1782"></a>                -- But now the occurrence analyser will see just one occurrence
<a name="line-1783"></a>                -- of poly_g, not inside a lambda, so the simplifier will
<a name="line-1784"></a>                -- PreInlineUnconditionally poly_g back into g!  Badk to square 1!
<a name="line-1785"></a>                -- (I used to think that the "don't inline lone occurrences" stuff
<a name="line-1786"></a>                --  would stop this happening, but since it's the *only* occurrence,
<a name="line-1787"></a>                --  PreInlineUnconditionally kicks in first!)
<a name="line-1788"></a>                --
<a name="line-1789"></a>                -- Solution: put an INLINE note on g's RHS, so that poly_g seems
<a name="line-1790"></a>                --           to appear many times.  (NB: mkInlineMe eliminates
<a name="line-1791"></a>                --           such notes on trivial RHSs, so do it manually.)
<a name="line-1792"></a>
<a name="line-1793"></a>************************************************************************
<a name="line-1794"></a>*                                                                      *
<a name="line-1795"></a>                prepareAlts
<a name="line-1796"></a>*                                                                      *
<a name="line-1797"></a>************************************************************************
<a name="line-1798"></a>
<a name="line-1799"></a>prepareAlts tries these things:
<a name="line-1800"></a>
<a name="line-1801"></a>1.  Eliminate alternatives that cannot match, including the
<a name="line-1802"></a>    DEFAULT alternative.
<a name="line-1803"></a>
<a name="line-1804"></a>2.  If the DEFAULT alternative can match only one possible constructor,
<a name="line-1805"></a>    then make that constructor explicit.
<a name="line-1806"></a>    e.g.
<a name="line-1807"></a>        case e of x { DEFAULT -&gt; rhs }
<a name="line-1808"></a>     ===&gt;
<a name="line-1809"></a>        case e of x { (a,b) -&gt; rhs }
<a name="line-1810"></a>    where the type is a single constructor type.  This gives better code
<a name="line-1811"></a>    when rhs also scrutinises x or e.
<a name="line-1812"></a>
<a name="line-1813"></a>3. Returns a list of the constructors that cannot holds in the
<a name="line-1814"></a>   DEFAULT alternative (if there is one)
<a name="line-1815"></a>
<a name="line-1816"></a>Here "cannot match" includes knowledge from GADTs
<a name="line-1817"></a>
<a name="line-1818"></a>It's a good idea to do this stuff before simplifying the alternatives, to
<a name="line-1819"></a>avoid simplifying alternatives we know can't happen, and to come up with
<a name="line-1820"></a>the list of constructors that are handled, to put into the IdInfo of the
<a name="line-1821"></a>case binder, for use when simplifying the alternatives.
<a name="line-1822"></a>
<a name="line-1823"></a>Eliminating the default alternative in (1) isn't so obvious, but it can
<a name="line-1824"></a>happen:
<a name="line-1825"></a>
<a name="line-1826"></a>data Colour = Red | Green | Blue
<a name="line-1827"></a>
<a name="line-1828"></a>f x = case x of
<a name="line-1829"></a>        Red -&gt; ..
<a name="line-1830"></a>        Green -&gt; ..
<a name="line-1831"></a>        DEFAULT -&gt; h x
<a name="line-1832"></a>
<a name="line-1833"></a>h y = case y of
<a name="line-1834"></a>        Blue -&gt; ..
<a name="line-1835"></a>        DEFAULT -&gt; [ case y of ... ]
<a name="line-1836"></a>
<a name="line-1837"></a>If we inline h into f, the default case of the inlined h can't happen.
<a name="line-1838"></a>If we don't notice this, we may end up filtering out *all* the cases
<a name="line-1839"></a>of the inner case y, which give us nowhere to go!
<a name="line-1840"></a>-}</span>
<a name="line-1841"></a>
<a name="line-1842"></a><a name="prepareAlts"></a><span class='hs-definition'>prepareAlts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1843"></a><span class='hs-comment'>-- The returned alternatives can be empty, none are possible</span>
<a name="line-1844"></a><span class='hs-definition'>prepareAlts</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>alts</span>
<a name="line-1845"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-1846"></a>           <span class='hs-comment'>-- Case binder is needed just for its type. Note that as an</span>
<a name="line-1847"></a>           <span class='hs-comment'>--   OutId, it has maximum information; this is important.</span>
<a name="line-1848"></a>           <span class='hs-comment'>--   Test simpl013 is an example</span>
<a name="line-1849"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>us</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-1850"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>idcs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts1</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterAlts</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>imposs_cons</span> <span class='hs-varid'>alts</span>
<a name="line-1851"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>yes2</span><span class='hs-layout'>,</span>  <span class='hs-varid'>alts2</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>refineDefaultAlt</span> <span class='hs-varid'>us</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>idcs1</span> <span class='hs-varid'>alts1</span>
<a name="line-1852"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>yes3</span><span class='hs-layout'>,</span> <span class='hs-varid'>idcs3</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts3</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineIdenticalAlts</span> <span class='hs-varid'>idcs1</span> <span class='hs-varid'>alts2</span>
<a name="line-1853"></a>             <span class='hs-comment'>-- "idcs" stands for "impossible default data constructors"</span>
<a name="line-1854"></a>             <span class='hs-comment'>-- i.e. the constructors that can't match the default case</span>
<a name="line-1855"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-varid'>yes2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>FillInCaseDefault</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-1856"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-varid'>yes3</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltMerge</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-1857"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>idcs3</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1858"></a>
<a name="line-1859"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- Not a data type, so nothing interesting happens</span>
<a name="line-1860"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-1861"></a>  <span class='hs-keyword'>where</span>
<a name="line-1862"></a>    <span class='hs-varid'>imposs_cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>of</span>
<a name="line-1863"></a>                    <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>otherCons</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1864"></a>                    <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-1865"></a>
<a name="line-1866"></a>
<a name="line-1867"></a><span class='hs-comment'>{-
<a name="line-1868"></a>************************************************************************
<a name="line-1869"></a>*                                                                      *
<a name="line-1870"></a>                mkCase
<a name="line-1871"></a>*                                                                      *
<a name="line-1872"></a>************************************************************************
<a name="line-1873"></a>
<a name="line-1874"></a>mkCase tries these things
<a name="line-1875"></a>
<a name="line-1876"></a>* Note [Nerge nested cases]
<a name="line-1877"></a>* Note [Eliminate identity case]
<a name="line-1878"></a>* Note [Scrutinee constant folding]
<a name="line-1879"></a>
<a name="line-1880"></a>Note [Merge Nested Cases]
<a name="line-1881"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1882"></a>       case e of b {             ==&gt;   case e of b {
<a name="line-1883"></a>         p1 -&gt; rhs1                      p1 -&gt; rhs1
<a name="line-1884"></a>         ...                             ...
<a name="line-1885"></a>         pm -&gt; rhsm                      pm -&gt; rhsm
<a name="line-1886"></a>         _  -&gt; case b of b' {            pn -&gt; let b'=b in rhsn
<a name="line-1887"></a>                     pn -&gt; rhsn          ...
<a name="line-1888"></a>                     ...                 po -&gt; let b'=b in rhso
<a name="line-1889"></a>                     po -&gt; rhso          _  -&gt; let b'=b in rhsd
<a name="line-1890"></a>                     _  -&gt; rhsd
<a name="line-1891"></a>       }
<a name="line-1892"></a>
<a name="line-1893"></a>which merges two cases in one case when -- the default alternative of
<a name="line-1894"></a>the outer case scrutises the same variable as the outer case. This
<a name="line-1895"></a>transformation is called Case Merging.  It avoids that the same
<a name="line-1896"></a>variable is scrutinised multiple times.
<a name="line-1897"></a>
<a name="line-1898"></a>Note [Eliminate Identity Case]
<a name="line-1899"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1900"></a>        case e of               ===&gt; e
<a name="line-1901"></a>                True  -&gt; True;
<a name="line-1902"></a>                False -&gt; False
<a name="line-1903"></a>
<a name="line-1904"></a>and similar friends.
<a name="line-1905"></a>
<a name="line-1906"></a>Note [Scrutinee Constant Folding]
<a name="line-1907"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1908"></a>     case x op# k# of _ {  ===&gt; case x of _ {
<a name="line-1909"></a>        a1# -&gt; e1                  (a1# inv_op# k#) -&gt; e1
<a name="line-1910"></a>        a2# -&gt; e2                  (a2# inv_op# k#) -&gt; e2
<a name="line-1911"></a>        ...                        ...
<a name="line-1912"></a>        DEFAULT -&gt; ed              DEFAULT -&gt; ed
<a name="line-1913"></a>
<a name="line-1914"></a>     where (x op# k#) inv_op# k# == x
<a name="line-1915"></a>
<a name="line-1916"></a>And similarly for commuted arguments and for some unary operations.
<a name="line-1917"></a>
<a name="line-1918"></a>The purpose of this transformation is not only to avoid an arithmetic
<a name="line-1919"></a>operation at runtime but to allow other transformations to apply in cascade.
<a name="line-1920"></a>
<a name="line-1921"></a>Example with the "Merge Nested Cases" optimization (from #12877):
<a name="line-1922"></a>
<a name="line-1923"></a>      main = case t of t0
<a name="line-1924"></a>         0##     -&gt; ...
<a name="line-1925"></a>         DEFAULT -&gt; case t0 `minusWord#` 1## of t1
<a name="line-1926"></a>            0##    -&gt; ...
<a name="line-1927"></a>            DEFAUT -&gt; case t1 `minusWord#` 1## of t2
<a name="line-1928"></a>               0##     -&gt; ...
<a name="line-1929"></a>               DEFAULT -&gt; case t2 `minusWord#` 1## of _
<a name="line-1930"></a>                  0##     -&gt; ...
<a name="line-1931"></a>                  DEFAULT -&gt; ...
<a name="line-1932"></a>
<a name="line-1933"></a>  becomes:
<a name="line-1934"></a>
<a name="line-1935"></a>      main = case t of _
<a name="line-1936"></a>      0##     -&gt; ...
<a name="line-1937"></a>      1##     -&gt; ...
<a name="line-1938"></a>      2##     -&gt; ...
<a name="line-1939"></a>      3##     -&gt; ...
<a name="line-1940"></a>      DEFAULT -&gt; ...
<a name="line-1941"></a>
<a name="line-1942"></a>There are some wrinkles
<a name="line-1943"></a>
<a name="line-1944"></a>* Do not apply caseRules if there is just a single DEFAULT alternative
<a name="line-1945"></a>     case e +# 3# of b { DEFAULT -&gt; rhs }
<a name="line-1946"></a>  If we applied the transformation here we would (stupidly) get
<a name="line-1947"></a>     case a of b' { DEFAULT -&gt; let b = e +# 3# in rhs }
<a name="line-1948"></a>  and now the process may repeat, because that let will really
<a name="line-1949"></a>  be a case.
<a name="line-1950"></a>
<a name="line-1951"></a>* The type of the scrutinee might change.  E.g.
<a name="line-1952"></a>        case tagToEnum (x :: Int#) of (b::Bool)
<a name="line-1953"></a>          False -&gt; e1
<a name="line-1954"></a>          True -&gt; e2
<a name="line-1955"></a>  ==&gt;
<a name="line-1956"></a>        case x of (b'::Int#)
<a name="line-1957"></a>          DEFAULT -&gt; e1
<a name="line-1958"></a>          1#      -&gt; e2
<a name="line-1959"></a>
<a name="line-1960"></a>* The case binder may be used in the right hand sides, so we need
<a name="line-1961"></a>  to make a local binding for it, if it is alive.  e.g.
<a name="line-1962"></a>         case e +# 10# of b
<a name="line-1963"></a>           DEFAULT -&gt; blah...b...
<a name="line-1964"></a>           44#     -&gt; blah2...b...
<a name="line-1965"></a>  ===&gt;
<a name="line-1966"></a>         case e of b'
<a name="line-1967"></a>           DEFAULT -&gt; let b = b' +# 10# in blah...b...
<a name="line-1968"></a>           34#     -&gt; let b = 44# in blah2...b...
<a name="line-1969"></a>
<a name="line-1970"></a>  Note that in the non-DEFAULT cases we know what to bind 'b' to,
<a name="line-1971"></a>  whereas in the DEFAULT case we must reconstruct the original value.
<a name="line-1972"></a>  But NB: we use b'; we do not duplicate 'e'.
<a name="line-1973"></a>
<a name="line-1974"></a>* In dataToTag we might need to make up some fake binders;
<a name="line-1975"></a>  see Note [caseRules for dataToTag] in PrelRules
<a name="line-1976"></a>-}</span>
<a name="line-1977"></a>
<a name="line-1978"></a><a name="mkCase"></a><span class='hs-definition'>mkCase</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase1</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase3</span>
<a name="line-1979"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-1980"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>
<a name="line-1981"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutAlt</span><span class='hs-keyglyph'>]</span>               <span class='hs-comment'>-- Alternatives in standard (increasing) order</span>
<a name="line-1982"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1983"></a>
<a name="line-1984"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-1985"></a><span class='hs-comment'>--      1. Merge Nested Cases</span>
<a name="line-1986"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-1987"></a>
<a name="line-1988"></a><span class='hs-definition'>mkCase</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>outer_bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>DEFAULT</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>deflt_rhs</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>outer_alts</span><span class='hs-layout'>)</span>
<a name="line-1989"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_CaseMerge</span> <span class='hs-varid'>dflags</span>
<a name="line-1990"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ticks</span><span class='hs-layout'>,</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>inner_scrut_var</span><span class='hs-layout'>)</span> <span class='hs-varid'>inner_bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>inner_alts</span><span class='hs-layout'>)</span>
<a name="line-1991"></a>       <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>stripTicksTop</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>deflt_rhs</span>
<a name="line-1992"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>inner_scrut_var</span> <span class='hs-varop'>==</span> <span class='hs-varid'>outer_bndr</span>
<a name="line-1993"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>CaseMerge</span> <span class='hs-varid'>outer_bndr</span><span class='hs-layout'>)</span>
<a name="line-1994"></a>
<a name="line-1995"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wrap_alt</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>outer_bndr</span> <span class='hs-varop'>`notElem`</span> <span class='hs-varid'>args</span> <span class='hs-layout'>)</span>
<a name="line-1996"></a>                                          <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_rhs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1997"></a>                <span class='hs-comment'>-- Simplifier's no-shadowing invariant should ensure</span>
<a name="line-1998"></a>                <span class='hs-comment'>-- that outer_bndr is not shadowed by the inner patterns</span>
<a name="line-1999"></a>              <span class='hs-varid'>wrap_rhs</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>inner_bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>outer_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-2000"></a>                <span class='hs-comment'>-- The let is OK even for unboxed binders,</span>
<a name="line-2001"></a>
<a name="line-2002"></a>              <span class='hs-varid'>wrapped_alts</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>inner_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inner_alts</span>
<a name="line-2003"></a>                           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>wrap_alt</span> <span class='hs-varid'>inner_alts</span>
<a name="line-2004"></a>
<a name="line-2005"></a>              <span class='hs-varid'>merged_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mergeAlts</span> <span class='hs-varid'>outer_alts</span> <span class='hs-varid'>wrapped_alts</span>
<a name="line-2006"></a>                <span class='hs-comment'>-- NB: mergeAlts gives priority to the left</span>
<a name="line-2007"></a>                <span class='hs-comment'>--      case x of</span>
<a name="line-2008"></a>                <span class='hs-comment'>--        A -&gt; e1</span>
<a name="line-2009"></a>                <span class='hs-comment'>--        DEFAULT -&gt; case x of</span>
<a name="line-2010"></a>                <span class='hs-comment'>--                      A -&gt; e2</span>
<a name="line-2011"></a>                <span class='hs-comment'>--                      B -&gt; e3</span>
<a name="line-2012"></a>                <span class='hs-comment'>-- When we merge, we must ensure that e1 takes</span>
<a name="line-2013"></a>                <span class='hs-comment'>-- precedence over e2 as the value for A!</span>
<a name="line-2014"></a>
<a name="line-2015"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>fmap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTicks</span> <span class='hs-varid'>ticks</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2016"></a>          <span class='hs-varid'>mkCase1</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>outer_bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>merged_alts</span>
<a name="line-2017"></a>        <span class='hs-layout'>}</span>
<a name="line-2018"></a>        <span class='hs-comment'>-- Warning: don't call mkCase recursively!</span>
<a name="line-2019"></a>        <span class='hs-comment'>-- Firstly, there's no point, because inner alts have already had</span>
<a name="line-2020"></a>        <span class='hs-comment'>-- mkCase applied to them, so they won't have a case in their default</span>
<a name="line-2021"></a>        <span class='hs-comment'>-- Secondly, if you do, you get an infinite loop, because the bindCaseBndr</span>
<a name="line-2022"></a>        <span class='hs-comment'>-- in munge_rhs may put a case into the DEFAULT branch!</span>
<a name="line-2023"></a>
<a name="line-2024"></a><span class='hs-definition'>mkCase</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCase1</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2025"></a>
<a name="line-2026"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2027"></a><span class='hs-comment'>--      2. Eliminate Identity Case</span>
<a name="line-2028"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2029"></a>
<a name="line-2030"></a><a name="mkCase1"></a><span class='hs-definition'>mkCase1</span> <span class='hs-sel'>_dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>alts</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Identity case</span>
<a name="line-2031"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all</span> <span class='hs-varid'>identity_alt</span> <span class='hs-varid'>alts</span>
<a name="line-2032"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>CaseIdentity</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2033"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTicks</span> <span class='hs-varid'>ticks</span> <span class='hs-varop'>$</span> <span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2034"></a>  <span class='hs-keyword'>where</span>
<a name="line-2035"></a>    <span class='hs-varid'>ticks</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>stripTicksT</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varop'>.</span> <span class='hs-varid'>thdOf3</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2036"></a>    <span class='hs-varid'>identity_alt</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_eq</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span>
<a name="line-2037"></a>
<a name="line-2038"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span>        <span class='hs-comment'>-- See Note [RHS casts]</span>
<a name="line-2039"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyCoVarsOfCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>check_eq</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span>
<a name="line-2040"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>args</span>
<a name="line-2041"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>t</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>check_eq</span> <span class='hs-varid'>e</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>args</span>
<a name="line-2042"></a>
<a name="line-2043"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit'</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lit</span> <span class='hs-varop'>==</span> <span class='hs-varid'>lit'</span>
<a name="line-2044"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>case_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2045"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-2046"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-varid'>args</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span>
<a name="line-2047"></a>                                             <span class='hs-comment'>-- Optimisation only</span>
<a name="line-2048"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-varid'>rhs</span>        <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cheapEqExpr'</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>$</span>
<a name="line-2049"></a>                                             <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>con</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>args</span>
<a name="line-2050"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-keyword'>_</span>          <span class='hs-keyword'>_</span>             <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2051"></a>
<a name="line-2052"></a>    <span class='hs-varid'>arg_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2053"></a>
<a name="line-2054"></a>        <span class='hs-comment'>-- Note [RHS casts]</span>
<a name="line-2055"></a>        <span class='hs-comment'>-- ~~~~~~~~~~~~~~~~</span>
<a name="line-2056"></a>        <span class='hs-comment'>-- We've seen this:</span>
<a name="line-2057"></a>        <span class='hs-comment'>--      case e of x { _ -&gt; x `cast` c }</span>
<a name="line-2058"></a>        <span class='hs-comment'>-- And we definitely want to eliminate this case, to give</span>
<a name="line-2059"></a>        <span class='hs-comment'>--      e `cast` c</span>
<a name="line-2060"></a>        <span class='hs-comment'>-- So we throw away the cast from the RHS, and reconstruct</span>
<a name="line-2061"></a>        <span class='hs-comment'>-- it at the other end.  All the RHS casts must be the same</span>
<a name="line-2062"></a>        <span class='hs-comment'>-- if (all identity_alt alts) holds.</span>
<a name="line-2063"></a>        <span class='hs-comment'>--</span>
<a name="line-2064"></a>        <span class='hs-comment'>-- Don't worry about nested casts, because the simplifier combines them</span>
<a name="line-2065"></a>
<a name="line-2066"></a>    <span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-2067"></a>    <span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scrut</span>
<a name="line-2068"></a>
<a name="line-2069"></a><span class='hs-definition'>mkCase1</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCase2</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2070"></a>
<a name="line-2071"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2072"></a><span class='hs-comment'>--      2. Scrutinee Constant Folding</span>
<a name="line-2073"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2074"></a>
<a name="line-2075"></a><a name="mkCase2"></a><span class='hs-definition'>mkCase2</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2076"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-comment'>-- See Note [Scrutinee Constant Folding]</span>
<a name="line-2077"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>alts</span> <span class='hs-keyword'>of</span>  <span class='hs-comment'>-- Not if there is just a DEFAULT alterantive</span>
<a name="line-2078"></a>      <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DEFAULT</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2079"></a>      <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2080"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_CaseFolding</span> <span class='hs-varid'>dflags</span>
<a name="line-2081"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>scrut'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tx_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>mk_orig</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>caseRules</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span>
<a name="line-2082"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bndr'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newId</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"lwild"</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span>
<a name="line-2083"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>alts'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>tx_alt</span> <span class='hs-varid'>tx_con</span> <span class='hs-varid'>mk_orig</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span>
<a name="line-2084"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mkCase3</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>bndr'</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varop'>$</span>
<a name="line-2085"></a>         <span class='hs-varid'>add_default</span> <span class='hs-layout'>(</span><span class='hs-varid'>re_sort</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>
<a name="line-2086"></a>       <span class='hs-layout'>}</span>
<a name="line-2087"></a>
<a name="line-2088"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2089"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCase3</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2090"></a>  <span class='hs-keyword'>where</span>
<a name="line-2091"></a>    <span class='hs-comment'>-- We need to keep the correct association between the scrutinee and its</span>
<a name="line-2092"></a>    <span class='hs-comment'>-- binder if the latter isn't dead. Hence we wrap rhs of alternatives with</span>
<a name="line-2093"></a>    <span class='hs-comment'>-- "let bndr = ... in":</span>
<a name="line-2094"></a>    <span class='hs-comment'>--</span>
<a name="line-2095"></a>    <span class='hs-comment'>--     case v + 10 of y        =====&gt; case v of y</span>
<a name="line-2096"></a>    <span class='hs-comment'>--        20      -&gt; e1                 10      -&gt; let y = 20     in e1</span>
<a name="line-2097"></a>    <span class='hs-comment'>--        DEFAULT -&gt; e2                 DEFAULT -&gt; let y = v + 10 in e2</span>
<a name="line-2098"></a>    <span class='hs-comment'>--</span>
<a name="line-2099"></a>    <span class='hs-comment'>-- Other transformations give: =====&gt; case v of y'</span>
<a name="line-2100"></a>    <span class='hs-comment'>--                                      10      -&gt; let y = 20      in e1</span>
<a name="line-2101"></a>    <span class='hs-comment'>--                                      DEFAULT -&gt; let y = y' + 10 in e2</span>
<a name="line-2102"></a>    <span class='hs-comment'>--</span>
<a name="line-2103"></a>    <span class='hs-comment'>-- This wrapping is done in tx_alt; we use mk_orig, returned by caseRules,</span>
<a name="line-2104"></a>    <span class='hs-comment'>-- to construct an expression equivalent to the original one, for use</span>
<a name="line-2105"></a>    <span class='hs-comment'>-- in the DEFAULT case</span>
<a name="line-2106"></a>
<a name="line-2107"></a>    <span class='hs-varid'>tx_alt</span> <span class='hs-varid'>tx_con</span> <span class='hs-varid'>mk_orig</span> <span class='hs-varid'>new_bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2108"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>con'</span><span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNullaryRepDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-2109"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- For non-nullary data cons we must invent some fake binders</span>
<a name="line-2110"></a>        <span class='hs-comment'>-- See Note [caseRules for dataToTag] in PrelRules</span>
<a name="line-2111"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>us</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-2112"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepInstPat</span> <span class='hs-varid'>us</span> <span class='hs-varid'>dc</span>
<a name="line-2113"></a>                                         <span class='hs-layout'>(</span><span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2114"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>con'</span><span class='hs-layout'>,</span> <span class='hs-varid'>ex_tvs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2115"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2116"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>con'</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-2117"></a>      <span class='hs-keyword'>where</span>
<a name="line-2118"></a>        <span class='hs-varid'>con'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tx_con</span> <span class='hs-varid'>con</span>
<a name="line-2119"></a>
<a name="line-2120"></a>        <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-2121"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bindNonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>orig_val</span> <span class='hs-varid'>rhs</span>
<a name="line-2122"></a>
<a name="line-2123"></a>        <span class='hs-varid'>orig_val</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>con</span> <span class='hs-keyword'>of</span>
<a name="line-2124"></a>                      <span class='hs-conid'>DEFAULT</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mk_orig</span> <span class='hs-varid'>new_bndr</span>
<a name="line-2125"></a>                      <span class='hs-conid'>LitAlt</span> <span class='hs-varid'>l</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>l</span>
<a name="line-2126"></a>                      <span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>dc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs</span>
<a name="line-2127"></a>
<a name="line-2128"></a>
<a name="line-2129"></a>    <span class='hs-varid'>re_sort</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Re-sort the alternatives to</span>
<a name="line-2130"></a>    <span class='hs-varid'>re_sort</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sortBy</span> <span class='hs-varid'>cmpAlt</span> <span class='hs-varid'>alts</span>  <span class='hs-comment'>-- preserve the #case_invariants#</span>
<a name="line-2131"></a>
<a name="line-2132"></a>    <span class='hs-varid'>add_default</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span>
<a name="line-2133"></a>    <span class='hs-comment'>-- TagToEnum may change a boolean True/False set of alternatives</span>
<a name="line-2134"></a>    <span class='hs-comment'>-- to LitAlt 0#/1# alterantives.  But literal alternatives always</span>
<a name="line-2135"></a>    <span class='hs-comment'>-- have a DEFAULT (I think).  So add it.</span>
<a name="line-2136"></a>    <span class='hs-varid'>add_default</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>DEFAULT</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>alts</span>
<a name="line-2137"></a>    <span class='hs-varid'>add_default</span> <span class='hs-varid'>alts</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts</span>
<a name="line-2138"></a>
<a name="line-2139"></a><a name="mkCase3"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2140"></a><span class='hs-comment'>--      Catch-all</span>
<a name="line-2141"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2142"></a><span class='hs-definition'>mkCase3</span> <span class='hs-sel'>_dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2143"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2144"></a>
<a name="line-2145"></a><span class='hs-comment'>{-
<a name="line-2146"></a>Note [Dead binders]
<a name="line-2147"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-2148"></a>Note that dead-ness is maintained by the simplifier, so that it is
<a name="line-2149"></a>accurate after simplification as well as before.
<a name="line-2150"></a>
<a name="line-2151"></a>
<a name="line-2152"></a>Note [Cascading case merge]
<a name="line-2153"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2154"></a>Case merging should cascade in one sweep, because it
<a name="line-2155"></a>happens bottom-up
<a name="line-2156"></a>
<a name="line-2157"></a>      case e of a {
<a name="line-2158"></a>        DEFAULT -&gt; case a of b
<a name="line-2159"></a>                      DEFAULT -&gt; case b of c {
<a name="line-2160"></a>                                     DEFAULT -&gt; e
<a name="line-2161"></a>                                     A -&gt; ea
<a name="line-2162"></a>                      B -&gt; eb
<a name="line-2163"></a>        C -&gt; ec
<a name="line-2164"></a>==&gt;
<a name="line-2165"></a>      case e of a {
<a name="line-2166"></a>        DEFAULT -&gt; case a of b
<a name="line-2167"></a>                      DEFAULT -&gt; let c = b in e
<a name="line-2168"></a>                      A -&gt; let c = b in ea
<a name="line-2169"></a>                      B -&gt; eb
<a name="line-2170"></a>        C -&gt; ec
<a name="line-2171"></a>==&gt;
<a name="line-2172"></a>      case e of a {
<a name="line-2173"></a>        DEFAULT -&gt; let b = a in let c = b in e
<a name="line-2174"></a>        A -&gt; let b = a in let c = b in ea
<a name="line-2175"></a>        B -&gt; let b = a in eb
<a name="line-2176"></a>        C -&gt; ec
<a name="line-2177"></a>
<a name="line-2178"></a>
<a name="line-2179"></a>However here's a tricky case that we still don't catch, and I don't
<a name="line-2180"></a>see how to catch it in one pass:
<a name="line-2181"></a>
<a name="line-2182"></a>  case x of c1 { I# a1 -&gt;
<a name="line-2183"></a>  case a1 of c2 -&gt;
<a name="line-2184"></a>    0 -&gt; ...
<a name="line-2185"></a>    DEFAULT -&gt; case x of c3 { I# a2 -&gt;
<a name="line-2186"></a>               case a2 of ...
<a name="line-2187"></a>
<a name="line-2188"></a>After occurrence analysis (and its binder-swap) we get this
<a name="line-2189"></a>
<a name="line-2190"></a>  case x of c1 { I# a1 -&gt;
<a name="line-2191"></a>  let x = c1 in         -- Binder-swap addition
<a name="line-2192"></a>  case a1 of c2 -&gt;
<a name="line-2193"></a>    0 -&gt; ...
<a name="line-2194"></a>    DEFAULT -&gt; case x of c3 { I# a2 -&gt;
<a name="line-2195"></a>               case a2 of ...
<a name="line-2196"></a>
<a name="line-2197"></a>When we simplify the inner case x, we'll see that
<a name="line-2198"></a>x=c1=I# a1.  So we'll bind a2 to a1, and get
<a name="line-2199"></a>
<a name="line-2200"></a>  case x of c1 { I# a1 -&gt;
<a name="line-2201"></a>  case a1 of c2 -&gt;
<a name="line-2202"></a>    0 -&gt; ...
<a name="line-2203"></a>    DEFAULT -&gt; case a1 of ...
<a name="line-2204"></a>
<a name="line-2205"></a>This is corect, but we can't do a case merge in this sweep
<a name="line-2206"></a>because c2 /= a1.  Reason: the binding c1=I# a1 went inwards
<a name="line-2207"></a>without getting changed to c1=I# c2.
<a name="line-2208"></a>
<a name="line-2209"></a>I don't think this is worth fixing, even if I knew how. It'll
<a name="line-2210"></a>all come out in the next pass anyway.
<a name="line-2211"></a>-}</span>
</pre></body>
</html>
