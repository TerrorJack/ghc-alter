<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcDerivInfer.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The University of Glasgow 2006
<a name="line-3"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-4"></a>
<a name="line-5"></a>
<a name="line-6"></a>Functions for inferring (and simplifying) the context for derived instances.
<a name="line-7"></a>-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-10"></a><span class='hs-comment'>{-# LANGUAGE MultiWayIf #-}</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcDerivInfer</span> <span class='hs-layout'>(</span><span class='hs-varid'>inferConstraints</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyInstanceContexts</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-20"></a><span class='hs-comment'>-- import DynFlags</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ErrUtils</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Inst</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelNames</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcDerivUtils</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEnv</span>
<a name="line-27"></a><span class='hs-comment'>-- import TcErrors (reportAllUnsolved)</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcGenFunctor</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcGenGenerics</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcMType</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnMonad</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSimplify</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcValidity</span> <span class='hs-layout'>(</span><span class='hs-varid'>validDerivPred</span><span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcUnify</span> <span class='hs-layout'>(</span><span class='hs-varid'>buildImplicationFor</span><span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unify</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcUnifyTy</span><span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-43"></a>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span><span class='hs-varop'>.</span><span class='hs-conid'>Class</span>  <span class='hs-layout'>(</span><span class='hs-varid'>lift</span><span class='hs-layout'>)</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span><span class='hs-varop'>.</span><span class='hs-conid'>Reader</span> <span class='hs-layout'>(</span><span class='hs-varid'>ask</span><span class='hs-layout'>)</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span>
<a name="line-49"></a>
<a name="line-50"></a><span class='hs-comment'>----------------------</span>
<a name="line-51"></a>
<a name="line-52"></a><a name="inferConstraints"></a><span class='hs-definition'>inferConstraints</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DerivSpecMechanism</span>
<a name="line-53"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DerivM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-54"></a><span class='hs-comment'>-- inferConstraints figures out the constraints needed for the</span>
<a name="line-55"></a><span class='hs-comment'>-- instance declaration generated by a 'deriving' clause on a</span>
<a name="line-56"></a><span class='hs-comment'>-- data type declaration. It also returns the new in-scope type</span>
<a name="line-57"></a><span class='hs-comment'>-- variables and instance types, in case they were changed due to</span>
<a name="line-58"></a><span class='hs-comment'>-- the presence of functor-like constraints.</span>
<a name="line-59"></a><span class='hs-comment'>-- See Note [Inferring the instance context]</span>
<a name="line-60"></a>
<a name="line-61"></a><span class='hs-comment'>-- e.g. inferConstraints</span>
<a name="line-62"></a><span class='hs-comment'>--        C Int (T [a])    -- Class and inst_tys</span>
<a name="line-63"></a><span class='hs-comment'>--        :RTList a        -- Rep tycon and its arg tys</span>
<a name="line-64"></a><span class='hs-comment'>-- where T [a] ~R :RTList a</span>
<a name="line-65"></a><span class='hs-comment'>--</span>
<a name="line-66"></a><span class='hs-comment'>-- Generate a sufficiently large set of constraints that typechecking the</span>
<a name="line-67"></a><span class='hs-comment'>-- generated method definitions should succeed.   This set will be simplified</span>
<a name="line-68"></a><span class='hs-comment'>-- before being used in the instance declaration</span>
<a name="line-69"></a><span class='hs-definition'>inferConstraints</span> <span class='hs-varid'>mechanism</span>
<a name="line-70"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-conid'>DerivEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>denv_tc</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-71"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>denv_tc_args</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_args</span>
<a name="line-72"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>denv_cls</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>main_cls</span>
<a name="line-73"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>denv_cls_tys</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_tys</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ask</span>
<a name="line-74"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>is_anyclass</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isDerivSpecAnyClass</span> <span class='hs-varid'>mechanism</span>
<a name="line-75"></a>             <span class='hs-varid'>infer_constraints</span>
<a name="line-76"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_anyclass</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inferConstraintsDAC</span> <span class='hs-varid'>inst_tys</span>
<a name="line-77"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inferConstraintsDataConArgs</span> <span class='hs-varid'>inst_ty</span> <span class='hs-varid'>inst_tys</span>
<a name="line-78"></a>
<a name="line-79"></a>             <span class='hs-varid'>inst_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tc_args</span>
<a name="line-80"></a>             <span class='hs-varid'>inst_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_tys</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>inst_ty</span><span class='hs-keyglyph'>]</span>
<a name="line-81"></a>
<a name="line-82"></a>             <span class='hs-comment'>-- Constraints arising from superclasses</span>
<a name="line-83"></a>             <span class='hs-comment'>-- See Note [Superclasses of derived instance]</span>
<a name="line-84"></a>             <span class='hs-varid'>cls_tvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTyVars</span> <span class='hs-varid'>main_cls</span>
<a name="line-85"></a>             <span class='hs-varid'>sc_constraints</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>cls_tvs</span> <span class='hs-varid'>inst_tys</span>
<a name="line-86"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inst_tys</span> <span class='hs-layout'>)</span>
<a name="line-87"></a>                              <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkThetaOrigin</span> <span class='hs-conid'>DerivOrigin</span> <span class='hs-conid'>TypeLevel</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-varop'>$</span>
<a name="line-88"></a>                                <span class='hs-varid'>substTheta</span> <span class='hs-varid'>cls_subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>classSCTheta</span> <span class='hs-varid'>main_cls</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-89"></a>             <span class='hs-varid'>cls_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>cls_tvs</span> <span class='hs-varid'>inst_tys</span> <span class='hs-layout'>)</span>
<a name="line-90"></a>                         <span class='hs-varid'>zipTvSubst</span> <span class='hs-varid'>cls_tvs</span> <span class='hs-varid'>inst_tys</span>
<a name="line-91"></a>
<a name="line-92"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>inferred_constraints</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>infer_constraints</span>
<a name="line-93"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"inferConstraints"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-94"></a>              <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inst_tys'</span>
<a name="line-95"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inferred_constraints</span>
<a name="line-96"></a>              <span class='hs-keyglyph'>]</span>
<a name="line-97"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>sc_constraints</span> <span class='hs-varop'>++</span> <span class='hs-varid'>inferred_constraints</span>
<a name="line-98"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>tvs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys'</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-99"></a>
<a name="line-100"></a><a name="inferConstraintsDataConArgs"></a><span class='hs-comment'>-- | Like 'inferConstraints', but used only in the case of deriving strategies</span>
<a name="line-101"></a><span class='hs-comment'>-- where the constraints are inferred by inspecting the fields of each data</span>
<a name="line-102"></a><span class='hs-comment'>-- constructor (i.e., stock- and newtype-deriving).</span>
<a name="line-103"></a><span class='hs-definition'>inferConstraintsDataConArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-104"></a>                            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DerivM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-105"></a><span class='hs-definition'>inferConstraintsDataConArgs</span> <span class='hs-varid'>inst_ty</span> <span class='hs-varid'>inst_tys</span>
<a name="line-106"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-conid'>DerivEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>denv_tvs</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-107"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>denv_rep_tc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rep_tc</span>
<a name="line-108"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>denv_rep_tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rep_tc_args</span>
<a name="line-109"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>denv_cls</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>main_cls</span>
<a name="line-110"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>denv_cls_tys</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_tys</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ask</span>
<a name="line-111"></a>
<a name="line-112"></a>       <span class='hs-keyword'>let</span> <span class='hs-varid'>tc_binders</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConBinders</span> <span class='hs-varid'>rep_tc</span>
<a name="line-113"></a>           <span class='hs-varid'>choose_level</span> <span class='hs-varid'>bndr</span>
<a name="line-114"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNamedTyConBinder</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>KindLevel</span>
<a name="line-115"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TypeLevel</span>
<a name="line-116"></a>           <span class='hs-varid'>t_or_ks</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>choose_level</span> <span class='hs-varid'>tc_binders</span> <span class='hs-varop'>++</span> <span class='hs-varid'>repeat</span> <span class='hs-conid'>TypeLevel</span>
<a name="line-117"></a>              <span class='hs-comment'>-- want to report *kind* errors when possible</span>
<a name="line-118"></a>
<a name="line-119"></a>              <span class='hs-comment'>-- Constraints arising from the arguments of each constructor</span>
<a name="line-120"></a>           <span class='hs-varid'>con_arg_constraints</span>
<a name="line-121"></a>             <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>CtOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeOrKind</span>
<a name="line-122"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-123"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>TCvSubst</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-124"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-125"></a>           <span class='hs-varid'>con_arg_constraints</span> <span class='hs-varid'>get_arg_constraints</span>
<a name="line-126"></a>             <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>predss</span><span class='hs-layout'>,</span> <span class='hs-varid'>mbSubsts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span>
<a name="line-127"></a>                     <span class='hs-keyglyph'>[</span> <span class='hs-varid'>preds_and_mbSubst</span>
<a name="line-128"></a>                     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>data_con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>rep_tc</span>
<a name="line-129"></a>                     <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_n</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_t_or_k</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-130"></a>                         <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip3</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>t_or_ks</span> <span class='hs-varop'>$</span>
<a name="line-131"></a>                            <span class='hs-varid'>dataConInstOrigArgTys</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>all_rep_tc_args</span>
<a name="line-132"></a>                       <span class='hs-comment'>-- No constraints for unlifted types</span>
<a name="line-133"></a>                       <span class='hs-comment'>-- See Note [Deriving and unboxed types]</span>
<a name="line-134"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-135"></a>                     <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>orig</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DerivOriginDC</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>arg_n</span>
<a name="line-136"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>preds_and_mbSubst</span>
<a name="line-137"></a>                         <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>get_arg_constraints</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>arg_t_or_k</span> <span class='hs-varid'>arg_ty</span>
<a name="line-138"></a>                     <span class='hs-keyglyph'>]</span>
<a name="line-139"></a>                   <span class='hs-varid'>preds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-varid'>predss</span>
<a name="line-140"></a>                   <span class='hs-comment'>-- If the constraints require a subtype to be of kind</span>
<a name="line-141"></a>                   <span class='hs-comment'>-- (* -&gt; *) (which is the case for functor-like</span>
<a name="line-142"></a>                   <span class='hs-comment'>-- constraints), then we explicitly unify the subtype's</span>
<a name="line-143"></a>                   <span class='hs-comment'>-- kinds with (* -&gt; *).</span>
<a name="line-144"></a>                   <span class='hs-comment'>-- See Note [Inferring the instance context]</span>
<a name="line-145"></a>                   <span class='hs-varid'>subst</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>composeTCvSubst</span>
<a name="line-146"></a>                                         <span class='hs-varid'>emptyTCvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>catMaybes</span> <span class='hs-varid'>mbSubsts</span><span class='hs-layout'>)</span>
<a name="line-147"></a>                   <span class='hs-varid'>unmapped_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`notElemTCvSubst`</span> <span class='hs-varid'>subst</span>
<a name="line-148"></a>                                             <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span> <span class='hs-varop'>`isInScope`</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span>
<a name="line-149"></a>                   <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>substTyVarBndr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>unmapped_tvs</span>
<a name="line-150"></a>                   <span class='hs-varid'>preds'</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>substPredOrigin</span> <span class='hs-varid'>subst'</span><span class='hs-layout'>)</span> <span class='hs-varid'>preds</span>
<a name="line-151"></a>                   <span class='hs-varid'>inst_tys'</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTys</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>inst_tys</span>
<a name="line-152"></a>                   <span class='hs-varid'>tvs'</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfTypesWellScoped</span> <span class='hs-varid'>inst_tys'</span>
<a name="line-153"></a>               <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>mkThetaOriginFromPreds</span> <span class='hs-varid'>preds'</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys'</span><span class='hs-layout'>)</span>
<a name="line-154"></a>
<a name="line-155"></a>           <span class='hs-varid'>is_generic</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>genClassKey</span>
<a name="line-156"></a>           <span class='hs-varid'>is_generic1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>gen1ClassKey</span>
<a name="line-157"></a>           <span class='hs-comment'>-- is_functor_like: see Note [Inferring the instance context]</span>
<a name="line-158"></a>           <span class='hs-varid'>is_functor_like</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>inst_ty</span> <span class='hs-varop'>`tcEqKind`</span> <span class='hs-varid'>typeToTypeKind</span>
<a name="line-159"></a>                          <span class='hs-varop'>||</span> <span class='hs-varid'>is_generic1</span>
<a name="line-160"></a>
<a name="line-161"></a>           <span class='hs-varid'>get_gen1_constraints</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeOrKind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-162"></a>                                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>TCvSubst</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-163"></a>           <span class='hs-varid'>get_gen1_constraints</span> <span class='hs-varid'>functor_cls</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>ty</span>
<a name="line-164"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_functor_like_constraints</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>functor_cls</span> <span class='hs-varop'>$</span>
<a name="line-165"></a>                <span class='hs-varid'>get_gen1_constrained_tys</span> <span class='hs-varid'>last_tv</span> <span class='hs-varid'>ty</span>
<a name="line-166"></a>
<a name="line-167"></a>           <span class='hs-varid'>get_std_constrained_tys</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeOrKind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-168"></a>                                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>TCvSubst</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-169"></a>           <span class='hs-varid'>get_std_constrained_tys</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>ty</span>
<a name="line-170"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_functor_like</span>
<a name="line-171"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_functor_like_constraints</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>$</span>
<a name="line-172"></a>                 <span class='hs-varid'>deepSubtypesContaining</span> <span class='hs-varid'>last_tv</span> <span class='hs-varid'>ty</span>
<a name="line-173"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-174"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mk_cls_pred</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>main_cls</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span>
<a name="line-175"></a>                  <span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-176"></a>
<a name="line-177"></a>           <span class='hs-varid'>mk_functor_like_constraints</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeOrKind</span>
<a name="line-178"></a>                                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-179"></a>                                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>TCvSubst</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-180"></a>           <span class='hs-comment'>-- 'cls' is usually main_cls (Functor or Traversable etc), but if</span>
<a name="line-181"></a>           <span class='hs-comment'>-- main_cls = Generic1, then 'cls' can be Functor; see</span>
<a name="line-182"></a>           <span class='hs-comment'>-- get_gen1_constraints</span>
<a name="line-183"></a>           <span class='hs-comment'>--</span>
<a name="line-184"></a>           <span class='hs-comment'>-- For each type, generate two constraints,</span>
<a name="line-185"></a>           <span class='hs-comment'>-- [cls ty, kind(ty) ~ (*-&gt;*)], and a kind substitution that results</span>
<a name="line-186"></a>           <span class='hs-comment'>-- from unifying  kind(ty) with * -&gt; *. If the unification is</span>
<a name="line-187"></a>           <span class='hs-comment'>-- successful, it will ensure that the resulting instance is well</span>
<a name="line-188"></a>           <span class='hs-comment'>-- kinded. If not, the second constraint will result in an error</span>
<a name="line-189"></a>           <span class='hs-comment'>-- message which points out the kind mismatch.</span>
<a name="line-190"></a>           <span class='hs-comment'>-- See Note [Inferring the instance context]</span>
<a name="line-191"></a>           <span class='hs-varid'>mk_functor_like_constraints</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>cls</span>
<a name="line-192"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ki</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>in</span>
<a name="line-193"></a>                             <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mk_cls_pred</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>ty</span>
<a name="line-194"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>mkPredOrigin</span> <span class='hs-varid'>orig</span> <span class='hs-conid'>KindLevel</span>
<a name="line-195"></a>                                   <span class='hs-layout'>(</span><span class='hs-varid'>mkPrimEqPred</span> <span class='hs-varid'>ki</span> <span class='hs-varid'>typeToTypeKind</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-196"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>tcUnifyTy</span> <span class='hs-varid'>ki</span> <span class='hs-varid'>typeToTypeKind</span>
<a name="line-197"></a>                             <span class='hs-layout'>)</span>
<a name="line-198"></a>
<a name="line-199"></a>           <span class='hs-varid'>rep_tc_tvs</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>rep_tc</span>
<a name="line-200"></a>           <span class='hs-varid'>last_tv</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>last</span> <span class='hs-varid'>rep_tc_tvs</span>
<a name="line-201"></a>           <span class='hs-comment'>-- When we first gather up the constraints to solve, most of them</span>
<a name="line-202"></a>           <span class='hs-comment'>-- contain rep_tc_tvs, i.e., the type variables from the derived</span>
<a name="line-203"></a>           <span class='hs-comment'>-- datatype's type constructor. We don't want these type variables</span>
<a name="line-204"></a>           <span class='hs-comment'>-- to appear in the final instance declaration, so we must</span>
<a name="line-205"></a>           <span class='hs-comment'>-- substitute each type variable with its counterpart in the derived</span>
<a name="line-206"></a>           <span class='hs-comment'>-- instance. rep_tc_args lists each of these counterpart types in</span>
<a name="line-207"></a>           <span class='hs-comment'>-- the same order as the type variables.</span>
<a name="line-208"></a>           <span class='hs-varid'>all_rep_tc_args</span>
<a name="line-209"></a>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rep_tc_args</span> <span class='hs-varop'>++</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span>
<a name="line-210"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>rep_tc_args</span><span class='hs-layout'>)</span> <span class='hs-varid'>rep_tc_tvs</span><span class='hs-layout'>)</span>
<a name="line-211"></a>
<a name="line-212"></a>               <span class='hs-comment'>-- Stupid constraints</span>
<a name="line-213"></a>           <span class='hs-varid'>stupid_constraints</span>
<a name="line-214"></a>             <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkThetaOrigin</span> <span class='hs-conid'>DerivOrigin</span> <span class='hs-conid'>TypeLevel</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-varop'>$</span>
<a name="line-215"></a>                 <span class='hs-varid'>substTheta</span> <span class='hs-varid'>tc_subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConStupidTheta</span> <span class='hs-varid'>rep_tc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-216"></a>           <span class='hs-varid'>tc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See the comment with all_rep_tc_args for an</span>
<a name="line-217"></a>                      <span class='hs-comment'>-- explanation of this assertion</span>
<a name="line-218"></a>                      <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>rep_tc_tvs</span> <span class='hs-varid'>all_rep_tc_args</span> <span class='hs-layout'>)</span>
<a name="line-219"></a>                      <span class='hs-varid'>zipTvSubst</span> <span class='hs-varid'>rep_tc_tvs</span> <span class='hs-varid'>all_rep_tc_args</span>
<a name="line-220"></a>
<a name="line-221"></a>           <span class='hs-comment'>-- Extra Data constraints</span>
<a name="line-222"></a>           <span class='hs-comment'>-- The Data class (only) requires that for</span>
<a name="line-223"></a>           <span class='hs-comment'>--    instance (...) =&gt; Data (T t1 t2)</span>
<a name="line-224"></a>           <span class='hs-comment'>-- IF   t1:*, t2:*</span>
<a name="line-225"></a>           <span class='hs-comment'>-- THEN (Data t1, Data t2) are among the (...) constraints</span>
<a name="line-226"></a>           <span class='hs-comment'>-- Reason: when the IF holds, we generate a method</span>
<a name="line-227"></a>           <span class='hs-comment'>--             dataCast2 f = gcast2 f</span>
<a name="line-228"></a>           <span class='hs-comment'>--         and we need the Data constraints to typecheck the method</span>
<a name="line-229"></a>           <span class='hs-varid'>extra_constraints</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkThetaOriginFromPreds</span> <span class='hs-varid'>constrs</span><span class='hs-keyglyph'>]</span>
<a name="line-230"></a>             <span class='hs-keyword'>where</span>
<a name="line-231"></a>               <span class='hs-varid'>constrs</span>
<a name="line-232"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>dataClassKey</span>
<a name="line-233"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>isLiftedTypeKind</span> <span class='hs-varop'>.</span> <span class='hs-varid'>typeKind</span><span class='hs-layout'>)</span> <span class='hs-varid'>rep_tc_args</span>
<a name="line-234"></a>                 <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mk_cls_pred</span> <span class='hs-conid'>DerivOrigin</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>main_cls</span> <span class='hs-varid'>ty</span>
<a name="line-235"></a>                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>t_or_k</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip</span> <span class='hs-varid'>t_or_ks</span> <span class='hs-varid'>rep_tc_args</span><span class='hs-keyglyph'>]</span>
<a name="line-236"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-237"></a>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-238"></a>
<a name="line-239"></a>           <span class='hs-varid'>mk_cls_pred</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>ty</span>
<a name="line-240"></a>                <span class='hs-comment'>-- Don't forget to apply to cls_tys' too</span>
<a name="line-241"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkPredOrigin</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>t_or_k</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls_tys'</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-242"></a>           <span class='hs-varid'>cls_tys'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_generic1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-243"></a>                      <span class='hs-comment'>-- In the awkward Generic1 case, cls_tys' should be</span>
<a name="line-244"></a>                      <span class='hs-comment'>-- empty, since we are applying the class Functor.</span>
<a name="line-245"></a>
<a name="line-246"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_tys</span>
<a name="line-247"></a>
<a name="line-248"></a>       <span class='hs-keyword'>if</span>    <span class='hs-comment'>-- Generic constraints are easy</span>
<a name="line-249"></a>          <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>is_generic</span>
<a name="line-250"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span>
<a name="line-251"></a>
<a name="line-252"></a>             <span class='hs-comment'>-- Generic1 needs Functor</span>
<a name="line-253"></a>             <span class='hs-comment'>-- See Note [Getting base classes]</span>
<a name="line-254"></a>          <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>is_generic1</span>
<a name="line-255"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>rep_tc_tvs</span> <span class='hs-varop'>`lengthExceeds`</span> <span class='hs-num'>0</span> <span class='hs-layout'>)</span>
<a name="line-256"></a>              <span class='hs-comment'>-- Generic1 has a single kind variable</span>
<a name="line-257"></a>              <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>cls_tys</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-num'>1</span> <span class='hs-layout'>)</span>
<a name="line-258"></a>              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>functorClass</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tcLookupClass</span> <span class='hs-varid'>functorClassName</span>
<a name="line-259"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-varid'>con_arg_constraints</span>
<a name="line-260"></a>                        <span class='hs-varop'>$</span> <span class='hs-varid'>get_gen1_constraints</span> <span class='hs-varid'>functorClass</span> <span class='hs-layout'>}</span>
<a name="line-261"></a>
<a name="line-262"></a>             <span class='hs-comment'>-- The others are a bit more complicated</span>
<a name="line-263"></a>          <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>otherwise</span>
<a name="line-264"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- See the comment with all_rep_tc_args for an explanation of</span>
<a name="line-265"></a>              <span class='hs-comment'>-- this assertion</span>
<a name="line-266"></a>              <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>rep_tc_tvs</span> <span class='hs-varid'>all_rep_tc_args</span>
<a name="line-267"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rep_tc</span>
<a name="line-268"></a>                       <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rep_tc_tvs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>all_rep_tc_args</span> <span class='hs-layout'>)</span>
<a name="line-269"></a>                <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_constraints</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys'</span><span class='hs-layout'>)</span>
<a name="line-270"></a>                           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con_arg_constraints</span> <span class='hs-varid'>get_std_constrained_tys</span>
<a name="line-271"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"inferConstraintsDataConArgs"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-272"></a>                          <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>main_cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inst_tys'</span>
<a name="line-273"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_constraints</span>
<a name="line-274"></a>                          <span class='hs-keyglyph'>]</span>
<a name="line-275"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>stupid_constraints</span> <span class='hs-varop'>++</span> <span class='hs-varid'>extra_constraints</span>
<a name="line-276"></a>                                                 <span class='hs-varop'>++</span> <span class='hs-varid'>arg_constraints</span>
<a name="line-277"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>tvs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-278"></a>
<a name="line-279"></a><a name="typeToTypeKind"></a><span class='hs-definition'>typeToTypeKind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Kind</span>
<a name="line-280"></a><span class='hs-definition'>typeToTypeKind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftedTypeKind</span> <span class='hs-varop'>`mkFunTy`</span> <span class='hs-varid'>liftedTypeKind</span>
<a name="line-281"></a>
<a name="line-282"></a><a name="inferConstraintsDAC"></a><span class='hs-comment'>-- | Like 'inferConstraints', but used only in the case of @DeriveAnyClass@,</span>
<a name="line-283"></a><span class='hs-comment'>-- which gathers its constraints based on the type signatures of the class's</span>
<a name="line-284"></a><span class='hs-comment'>-- methods instead of the types of the data constructor's field.</span>
<a name="line-285"></a><span class='hs-comment'>--</span>
<a name="line-286"></a><span class='hs-comment'>-- See Note [Gathering and simplifying constraints for DeriveAnyClass]</span>
<a name="line-287"></a><span class='hs-comment'>-- for an explanation of how these constraints are used to determine the</span>
<a name="line-288"></a><span class='hs-comment'>-- derived instance context.</span>
<a name="line-289"></a><span class='hs-definition'>inferConstraintsDAC</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DerivM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-290"></a><span class='hs-definition'>inferConstraintsDAC</span> <span class='hs-varid'>inst_tys</span>
<a name="line-291"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-conid'>DerivEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>denv_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-292"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>denv_cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ask</span>
<a name="line-293"></a>
<a name="line-294"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>gen_dms</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>sel_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>dm_ty</span><span class='hs-layout'>)</span>
<a name="line-295"></a>                       <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>sel_id</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>GenericDM</span> <span class='hs-varid'>dm_ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classOpItems</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>]</span>
<a name="line-296"></a>
<a name="line-297"></a>             <span class='hs-varid'>cls_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTyVars</span> <span class='hs-varid'>cls</span>
<a name="line-298"></a>             <span class='hs-varid'>empty_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-299"></a>
<a name="line-300"></a>             <span class='hs-varid'>do_one_meth</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>ThetaOrigin</span>
<a name="line-301"></a>               <span class='hs-comment'>-- (Id,Type) are the selector Id and the generic default method type</span>
<a name="line-302"></a>               <span class='hs-comment'>-- NB: the latter is /not/ quantified over the class variables</span>
<a name="line-303"></a>               <span class='hs-comment'>-- See Note [Gathering and simplifying constraints for DeriveAnyClass]</span>
<a name="line-304"></a>             <span class='hs-varid'>do_one_meth</span> <span class='hs-layout'>(</span><span class='hs-varid'>sel_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>gen_dm_ty</span><span class='hs-layout'>)</span>
<a name="line-305"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>sel_tvs</span><span class='hs-layout'>,</span> <span class='hs-sel'>_cls_pred</span><span class='hs-layout'>,</span> <span class='hs-varid'>meth_ty</span><span class='hs-layout'>)</span>
<a name="line-306"></a>                                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitMethodTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>sel_id</span><span class='hs-layout'>)</span>
<a name="line-307"></a>                          <span class='hs-varid'>meth_ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTyWith</span> <span class='hs-varid'>sel_tvs</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>meth_ty</span>
<a name="line-308"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>meth_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>meth_theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>meth_tau</span><span class='hs-layout'>)</span>
<a name="line-309"></a>                                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitNestedSigmaTys</span> <span class='hs-varid'>meth_ty'</span>
<a name="line-310"></a>
<a name="line-311"></a>                          <span class='hs-varid'>gen_dm_ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTyWith</span> <span class='hs-varid'>cls_tvs</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>gen_dm_ty</span>
<a name="line-312"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>dm_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>dm_theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>dm_tau</span><span class='hs-layout'>)</span>
<a name="line-313"></a>                                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitNestedSigmaTys</span> <span class='hs-varid'>gen_dm_ty'</span>
<a name="line-314"></a>
<a name="line-315"></a>                    <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-sel'>_meta_tvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushTcLevelM_</span> <span class='hs-varop'>$</span>
<a name="line-316"></a>                                            <span class='hs-varid'>newMetaTyVarsX</span> <span class='hs-varid'>empty_subst</span> <span class='hs-varid'>dm_tvs</span>
<a name="line-317"></a>                      <span class='hs-comment'>-- Yuk: the pushTcLevel is to match the one in mk_wanteds</span>
<a name="line-318"></a>                      <span class='hs-comment'>--      simplifyDeriv.  If we don't, the unification</span>
<a name="line-319"></a>                      <span class='hs-comment'>--      variables will bogusly be untouchable.</span>
<a name="line-320"></a>
<a name="line-321"></a>                    <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dm_theta'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTheta</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>dm_theta</span>
<a name="line-322"></a>                          <span class='hs-varid'>tau_eq</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkPrimEqPred</span> <span class='hs-varid'>meth_tau</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>dm_tau</span><span class='hs-layout'>)</span>
<a name="line-323"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkThetaOrigin</span> <span class='hs-conid'>DerivOrigin</span> <span class='hs-conid'>TypeLevel</span>
<a name="line-324"></a>                                <span class='hs-varid'>meth_tvs</span> <span class='hs-varid'>meth_theta</span> <span class='hs-layout'>(</span><span class='hs-varid'>tau_eq</span><span class='hs-conop'>:</span><span class='hs-varid'>dm_theta'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-325"></a>
<a name="line-326"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>theta_origins</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>pushTcLevelM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>mapM</span> <span class='hs-varid'>do_one_meth</span> <span class='hs-varid'>gen_dms</span><span class='hs-layout'>)</span>
<a name="line-327"></a>            <span class='hs-comment'>-- Yuk: the pushTcLevel is to match the one wrapping the call</span>
<a name="line-328"></a>            <span class='hs-comment'>--      to mk_wanteds in simplifyDeriv.  If we omit this, the</span>
<a name="line-329"></a>            <span class='hs-comment'>--      unification variables will wrongly be untouchable.</span>
<a name="line-330"></a>
<a name="line-331"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>theta_origins</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-332"></a>
<a name="line-333"></a><span class='hs-comment'>{- Note [Inferring the instance context]
<a name="line-334"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-335"></a>There are two sorts of 'deriving':
<a name="line-336"></a>
<a name="line-337"></a>  * InferTheta: the deriving clause for a data type
<a name="line-338"></a>      data T a = T1 a deriving( Eq )
<a name="line-339"></a>    Here we must infer an instance context,
<a name="line-340"></a>    and generate instance declaration
<a name="line-341"></a>      instance Eq a =&gt; Eq (T a) where ...
<a name="line-342"></a>
<a name="line-343"></a>  * CheckTheta: standalone deriving
<a name="line-344"></a>      deriving instance Eq a =&gt; Eq (T a)
<a name="line-345"></a>    Here we only need to fill in the bindings;
<a name="line-346"></a>    the instance context is user-supplied
<a name="line-347"></a>
<a name="line-348"></a>For a deriving clause (InferTheta) we must figure out the
<a name="line-349"></a>instance context (inferConstraintsDataConArgs). Suppose we are inferring
<a name="line-350"></a>the instance context for
<a name="line-351"></a>    C t1 .. tn (T s1 .. sm)
<a name="line-352"></a>There are two cases
<a name="line-353"></a>
<a name="line-354"></a>  * (T s1 .. sm) :: *         (the normal case)
<a name="line-355"></a>    Then we behave like Eq and guess (C t1 .. tn t)
<a name="line-356"></a>    for each data constructor arg of type t.  More
<a name="line-357"></a>    details below.
<a name="line-358"></a>
<a name="line-359"></a>  * (T s1 .. sm) :: * -&gt; *    (the functor-like case)
<a name="line-360"></a>    Then we behave like Functor.
<a name="line-361"></a>
<a name="line-362"></a>In both cases we produce a bunch of un-simplified constraints
<a name="line-363"></a>and them simplify them in simplifyInstanceContexts; see
<a name="line-364"></a>Note [Simplifying the instance context].
<a name="line-365"></a>
<a name="line-366"></a>In the functor-like case, we may need to unify some kind variables with * in
<a name="line-367"></a>order for the generated instance to be well-kinded. An example from
<a name="line-368"></a>Trac #10524:
<a name="line-369"></a>
<a name="line-370"></a>  newtype Compose (f :: k2 -&gt; *) (g :: k1 -&gt; k2) (a :: k1)
<a name="line-371"></a>    = Compose (f (g a)) deriving Functor
<a name="line-372"></a>
<a name="line-373"></a>Earlier in the deriving pipeline, GHC unifies the kind of Compose f g
<a name="line-374"></a>(k1 -&gt; *) with the kind of Functor's argument (* -&gt; *), so k1 := *. But this
<a name="line-375"></a>alone isn't enough, since k2 wasn't unified with *:
<a name="line-376"></a>
<a name="line-377"></a>  instance (Functor (f :: k2 -&gt; *), Functor (g :: * -&gt; k2)) =&gt;
<a name="line-378"></a>    Functor (Compose f g) where ...
<a name="line-379"></a>
<a name="line-380"></a>The two Functor constraints are ill-kinded. To ensure this doesn't happen, we:
<a name="line-381"></a>
<a name="line-382"></a>  1. Collect all of a datatype's subtypes which require functor-like
<a name="line-383"></a>     constraints.
<a name="line-384"></a>  2. For each subtype, create a substitution by unifying the subtype's kind
<a name="line-385"></a>     with (* -&gt; *).
<a name="line-386"></a>  3. Compose all the substitutions into one, then apply that substitution to
<a name="line-387"></a>     all of the in-scope type variables and the instance types.
<a name="line-388"></a>
<a name="line-389"></a>Note [Getting base classes]
<a name="line-390"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-391"></a>Functor and Typeable are defined in package 'base', and that is not available
<a name="line-392"></a>when compiling 'ghc-prim'.  So we must be careful that 'deriving' for stuff in
<a name="line-393"></a>ghc-prim does not use Functor or Typeable implicitly via these lookups.
<a name="line-394"></a>
<a name="line-395"></a>Note [Deriving and unboxed types]
<a name="line-396"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-397"></a>We have some special hacks to support things like
<a name="line-398"></a>   data T = MkT Int# deriving ( Show )
<a name="line-399"></a>
<a name="line-400"></a>Specifically, we use TcGenDeriv.box to box the Int# into an Int
<a name="line-401"></a>(which we know how to show), and append a '#'. Parenthesis are not required
<a name="line-402"></a>for unboxed values (`MkT -3#` is a valid expression).
<a name="line-403"></a>
<a name="line-404"></a>Note [Superclasses of derived instance]
<a name="line-405"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-406"></a>In general, a derived instance decl needs the superclasses of the derived
<a name="line-407"></a>class too.  So if we have
<a name="line-408"></a>        data T a = ...deriving( Ord )
<a name="line-409"></a>then the initial context for Ord (T a) should include Eq (T a).  Often this is
<a name="line-410"></a>redundant; we'll also generate an Ord constraint for each constructor argument,
<a name="line-411"></a>and that will probably generate enough constraints to make the Eq (T a) constraint
<a name="line-412"></a>be satisfied too.  But not always; consider:
<a name="line-413"></a>
<a name="line-414"></a> data S a = S
<a name="line-415"></a> instance Eq (S a)
<a name="line-416"></a> instance Ord (S a)
<a name="line-417"></a>
<a name="line-418"></a> data T a = MkT (S a) deriving( Ord )
<a name="line-419"></a> instance Num a =&gt; Eq (T a)
<a name="line-420"></a>
<a name="line-421"></a>The derived instance for (Ord (T a)) must have a (Num a) constraint!
<a name="line-422"></a>Similarly consider:
<a name="line-423"></a>        data T a = MkT deriving( Data )
<a name="line-424"></a>Here there *is* no argument field, but we must nevertheless generate
<a name="line-425"></a>a context for the Data instances:
<a name="line-426"></a>        instance Typeable a =&gt; Data (T a) where ...
<a name="line-427"></a>
<a name="line-428"></a>
<a name="line-429"></a>************************************************************************
<a name="line-430"></a>*                                                                      *
<a name="line-431"></a>         Finding the fixed point of deriving equations
<a name="line-432"></a>*                                                                      *
<a name="line-433"></a>************************************************************************
<a name="line-434"></a>
<a name="line-435"></a>Note [Simplifying the instance context]
<a name="line-436"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-437"></a>Consider
<a name="line-438"></a>
<a name="line-439"></a>        data T a b = C1 (Foo a) (Bar b)
<a name="line-440"></a>                   | C2 Int (T b a)
<a name="line-441"></a>                   | C3 (T a a)
<a name="line-442"></a>                   deriving (Eq)
<a name="line-443"></a>
<a name="line-444"></a>We want to come up with an instance declaration of the form
<a name="line-445"></a>
<a name="line-446"></a>        instance (Ping a, Pong b, ...) =&gt; Eq (T a b) where
<a name="line-447"></a>                x == y = ...
<a name="line-448"></a>
<a name="line-449"></a>It is pretty easy, albeit tedious, to fill in the code "...".  The
<a name="line-450"></a>trick is to figure out what the context for the instance decl is,
<a name="line-451"></a>namely Ping, Pong and friends.
<a name="line-452"></a>
<a name="line-453"></a>Let's call the context reqd for the T instance of class C at types
<a name="line-454"></a>(a,b, ...)  C (T a b).  Thus:
<a name="line-455"></a>
<a name="line-456"></a>        Eq (T a b) = (Ping a, Pong b, ...)
<a name="line-457"></a>
<a name="line-458"></a>Now we can get a (recursive) equation from the data decl.  This part
<a name="line-459"></a>is done by inferConstraintsDataConArgs.
<a name="line-460"></a>
<a name="line-461"></a>        Eq (T a b) = Eq (Foo a) u Eq (Bar b)    -- From C1
<a name="line-462"></a>                   u Eq (T b a) u Eq Int        -- From C2
<a name="line-463"></a>                   u Eq (T a a)                 -- From C3
<a name="line-464"></a>
<a name="line-465"></a>
<a name="line-466"></a>Foo and Bar may have explicit instances for Eq, in which case we can
<a name="line-467"></a>just substitute for them.  Alternatively, either or both may have
<a name="line-468"></a>their Eq instances given by deriving clauses, in which case they
<a name="line-469"></a>form part of the system of equations.
<a name="line-470"></a>
<a name="line-471"></a>Now all we need do is simplify and solve the equations, iterating to
<a name="line-472"></a>find the least fixpoint.  This is done by simplifyInstanceConstraints.
<a name="line-473"></a>Notice that the order of the arguments can
<a name="line-474"></a>switch around, as here in the recursive calls to T.
<a name="line-475"></a>
<a name="line-476"></a>Let's suppose Eq (Foo a) = Eq a, and Eq (Bar b) = Ping b.
<a name="line-477"></a>
<a name="line-478"></a>We start with:
<a name="line-479"></a>
<a name="line-480"></a>        Eq (T a b) = {}         -- The empty set
<a name="line-481"></a>
<a name="line-482"></a>Next iteration:
<a name="line-483"></a>        Eq (T a b) = Eq (Foo a) u Eq (Bar b)    -- From C1
<a name="line-484"></a>                   u Eq (T b a) u Eq Int        -- From C2
<a name="line-485"></a>                   u Eq (T a a)                 -- From C3
<a name="line-486"></a>
<a name="line-487"></a>        After simplification:
<a name="line-488"></a>                   = Eq a u Ping b u {} u {} u {}
<a name="line-489"></a>                   = Eq a u Ping b
<a name="line-490"></a>
<a name="line-491"></a>Next iteration:
<a name="line-492"></a>
<a name="line-493"></a>        Eq (T a b) = Eq (Foo a) u Eq (Bar b)    -- From C1
<a name="line-494"></a>                   u Eq (T b a) u Eq Int        -- From C2
<a name="line-495"></a>                   u Eq (T a a)                 -- From C3
<a name="line-496"></a>
<a name="line-497"></a>        After simplification:
<a name="line-498"></a>                   = Eq a u Ping b
<a name="line-499"></a>                   u (Eq b u Ping a)
<a name="line-500"></a>                   u (Eq a u Ping a)
<a name="line-501"></a>
<a name="line-502"></a>                   = Eq a u Ping b u Eq b u Ping a
<a name="line-503"></a>
<a name="line-504"></a>The next iteration gives the same result, so this is the fixpoint.  We
<a name="line-505"></a>need to make a canonical form of the RHS to ensure convergence.  We do
<a name="line-506"></a>this by simplifying the RHS to a form in which
<a name="line-507"></a>
<a name="line-508"></a>        - the classes constrain only tyvars
<a name="line-509"></a>        - the list is sorted by tyvar (major key) and then class (minor key)
<a name="line-510"></a>        - no duplicates, of course
<a name="line-511"></a>
<a name="line-512"></a>Note [Deterministic simplifyInstanceContexts]
<a name="line-513"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-514"></a>Canonicalisation uses nonDetCmpType which is nondeterministic. Sorting
<a name="line-515"></a>with nonDetCmpType puts the returned lists in a nondeterministic order.
<a name="line-516"></a>If we were to return them, we'd get class constraints in
<a name="line-517"></a>nondeterministic order.
<a name="line-518"></a>
<a name="line-519"></a>Consider:
<a name="line-520"></a>
<a name="line-521"></a>  data ADT a b = Z a b deriving Eq
<a name="line-522"></a>
<a name="line-523"></a>The generated code could be either:
<a name="line-524"></a>
<a name="line-525"></a>  instance (Eq a, Eq b) =&gt; Eq (Z a b) where
<a name="line-526"></a>
<a name="line-527"></a>Or:
<a name="line-528"></a>
<a name="line-529"></a>  instance (Eq b, Eq a) =&gt; Eq (Z a b) where
<a name="line-530"></a>
<a name="line-531"></a>To prevent the order from being nondeterministic we only
<a name="line-532"></a>canonicalize when comparing and return them in the same order as
<a name="line-533"></a>simplifyDeriv returned them.
<a name="line-534"></a>See also Note [nonDetCmpType nondeterminism]
<a name="line-535"></a>-}</span>
<a name="line-536"></a>
<a name="line-537"></a>
<a name="line-538"></a><a name="simplifyInstanceContexts"></a><span class='hs-definition'>simplifyInstanceContexts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>DerivSpec</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaOrigin</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<a name="line-539"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>DerivSpec</span> <span class='hs-conid'>ThetaType</span><span class='hs-keyglyph'>]</span>
<a name="line-540"></a><span class='hs-comment'>-- Used only for deriving clauses (InferTheta)</span>
<a name="line-541"></a><span class='hs-comment'>-- not for standalone deriving</span>
<a name="line-542"></a><span class='hs-comment'>-- See Note [Simplifying the instance context]</span>
<a name="line-543"></a>
<a name="line-544"></a><span class='hs-definition'>simplifyInstanceContexts</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
<a name="line-545"></a>
<a name="line-546"></a><span class='hs-definition'>simplifyInstanceContexts</span> <span class='hs-varid'>infer_specs</span>
<a name="line-547"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInstanceContexts"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>pprDerivSpec</span> <span class='hs-varid'>infer_specs</span><span class='hs-layout'>)</span>
<a name="line-548"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>iterate_deriv</span> <span class='hs-num'>1</span> <span class='hs-varid'>initial_solutions</span> <span class='hs-layout'>}</span>
<a name="line-549"></a>  <span class='hs-keyword'>where</span>
<a name="line-550"></a>    <span class='hs-comment'>------------------------------------------------------------------</span>
<a name="line-551"></a>        <span class='hs-comment'>-- The initial solutions for the equations claim that each</span>
<a name="line-552"></a>        <span class='hs-comment'>-- instance has an empty context; this solution is certainly</span>
<a name="line-553"></a>        <span class='hs-comment'>-- in canonical form.</span>
<a name="line-554"></a>    <span class='hs-varid'>initial_solutions</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaType</span><span class='hs-keyglyph'>]</span>
<a name="line-555"></a>    <span class='hs-varid'>initial_solutions</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>infer_specs</span> <span class='hs-keyglyph'>]</span>
<a name="line-556"></a>
<a name="line-557"></a>    <span class='hs-comment'>------------------------------------------------------------------</span>
<a name="line-558"></a>        <span class='hs-comment'>-- iterate_deriv calculates the next batch of solutions,</span>
<a name="line-559"></a>        <span class='hs-comment'>-- compares it with the current one; finishes if they are the</span>
<a name="line-560"></a>        <span class='hs-comment'>-- same, otherwise recurses with the new solutions.</span>
<a name="line-561"></a>        <span class='hs-comment'>-- It fails if any iteration fails</span>
<a name="line-562"></a>    <span class='hs-varid'>iterate_deriv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>DerivSpec</span> <span class='hs-conid'>ThetaType</span><span class='hs-keyglyph'>]</span>
<a name="line-563"></a>    <span class='hs-varid'>iterate_deriv</span> <span class='hs-varid'>n</span> <span class='hs-varid'>current_solns</span>
<a name="line-564"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>20</span>  <span class='hs-comment'>-- Looks as if we are in an infinite loop</span>
<a name="line-565"></a>                <span class='hs-comment'>-- This can happen if we have -XUndecidableInstances</span>
<a name="line-566"></a>                <span class='hs-comment'>-- (See TcSimplify.tcSimplifyDeriv.)</span>
<a name="line-567"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"solveDerivEqns: probable loop"</span>
<a name="line-568"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>pprDerivSpec</span> <span class='hs-varid'>infer_specs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>current_solns</span><span class='hs-layout'>)</span>
<a name="line-569"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-570"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>      <span class='hs-comment'>-- Extend the inst info from the explicit instance decls</span>
<a name="line-571"></a>                  <span class='hs-comment'>-- with the current set of solutions, and simplify each RHS</span>
<a name="line-572"></a>             <span class='hs-varid'>inst_specs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipWithM</span> <span class='hs-varid'>newDerivClsInst</span> <span class='hs-varid'>current_solns</span> <span class='hs-varid'>infer_specs</span>
<a name="line-573"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>new_solns</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>checkNoErrs</span> <span class='hs-varop'>$</span>
<a name="line-574"></a>                          <span class='hs-varid'>extendLocalInstEnv</span> <span class='hs-varid'>inst_specs</span> <span class='hs-varop'>$</span>
<a name="line-575"></a>                          <span class='hs-varid'>mapM</span> <span class='hs-varid'>gen_soln</span> <span class='hs-varid'>infer_specs</span>
<a name="line-576"></a>
<a name="line-577"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-layout'>(</span><span class='hs-varid'>current_solns</span> <span class='hs-varop'>`eqSolution`</span> <span class='hs-varid'>new_solns</span><span class='hs-layout'>)</span> <span class='hs-keyword'>then</span>
<a name="line-578"></a>                <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>spec</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ds_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>soln</span> <span class='hs-layout'>}</span>
<a name="line-579"></a>                       <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec</span><span class='hs-layout'>,</span> <span class='hs-varid'>soln</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip</span> <span class='hs-varid'>infer_specs</span> <span class='hs-varid'>current_solns</span> <span class='hs-keyglyph'>]</span>
<a name="line-580"></a>             <span class='hs-keyword'>else</span>
<a name="line-581"></a>                <span class='hs-varid'>iterate_deriv</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_solns</span> <span class='hs-layout'>}</span>
<a name="line-582"></a>
<a name="line-583"></a>    <span class='hs-varid'>eqSolution</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqListBy</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqListBy</span> <span class='hs-varid'>eqType</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>canSolution</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>canSolution</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-584"></a>       <span class='hs-comment'>-- Canonicalise for comparison</span>
<a name="line-585"></a>       <span class='hs-comment'>-- See Note [Deterministic simplifyInstanceContexts]</span>
<a name="line-586"></a>    <span class='hs-varid'>canSolution</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>sortBy</span> <span class='hs-varid'>nonDetCmpType</span><span class='hs-layout'>)</span>
<a name="line-587"></a>    <span class='hs-comment'>------------------------------------------------------------------</span>
<a name="line-588"></a>    <span class='hs-varid'>gen_soln</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DerivSpec</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaOrigin</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>ThetaType</span>
<a name="line-589"></a>    <span class='hs-varid'>gen_soln</span> <span class='hs-layout'>(</span><span class='hs-conid'>DS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ds_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyvars</span>
<a name="line-590"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ds_cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>clas</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deriv_rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-591"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span>  <span class='hs-varop'>$</span>
<a name="line-592"></a>        <span class='hs-varid'>addErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>derivInstCtxt</span> <span class='hs-varid'>the_pred</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-593"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>theta</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyDeriv</span> <span class='hs-varid'>the_pred</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>deriv_rhs</span>
<a name="line-594"></a>                <span class='hs-comment'>-- checkValidInstance tyvars theta clas inst_tys</span>
<a name="line-595"></a>                <span class='hs-comment'>-- Not necessary; see Note [Exotic derived instance contexts]</span>
<a name="line-596"></a>
<a name="line-597"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"TcDeriv"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>deriv_rhs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-598"></a>                <span class='hs-comment'>-- Claim: the result instance declaration is guaranteed valid</span>
<a name="line-599"></a>                <span class='hs-comment'>-- Hence no need to call:</span>
<a name="line-600"></a>                <span class='hs-comment'>--   checkValidInstance tyvars theta clas inst_tys</span>
<a name="line-601"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>}</span>
<a name="line-602"></a>      <span class='hs-keyword'>where</span>
<a name="line-603"></a>        <span class='hs-varid'>the_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span>
<a name="line-604"></a>
<a name="line-605"></a><a name="derivInstCtxt"></a><span class='hs-definition'>derivInstCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MsgDoc</span>
<a name="line-606"></a><span class='hs-definition'>derivInstCtxt</span> <span class='hs-varid'>pred</span>
<a name="line-607"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"When deriving the instance for"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-608"></a>
<a name="line-609"></a><span class='hs-comment'>{-
<a name="line-610"></a>***********************************************************************************
<a name="line-611"></a>*                                                                                 *
<a name="line-612"></a>*            Simplify derived constraints
<a name="line-613"></a>*                                                                                 *
<a name="line-614"></a>***********************************************************************************
<a name="line-615"></a>-}</span>
<a name="line-616"></a>
<a name="line-617"></a><a name="simplifyDeriv"></a><span class='hs-comment'>-- | Given @instance (wanted) =&gt; C inst_ty@, simplify 'wanted' as much</span>
<a name="line-618"></a><span class='hs-comment'>-- as possible. Fail if not possible.</span>
<a name="line-619"></a><span class='hs-definition'>simplifyDeriv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-comment'>-- ^ @C inst_ty@, head of the instance we are</span>
<a name="line-620"></a>                          <span class='hs-comment'>-- deriving.  Only used for SkolemInfo.</span>
<a name="line-621"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- ^ The tyvars bound by @inst_ty@.</span>
<a name="line-622"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ThetaOrigin</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ Given and wanted constraints</span>
<a name="line-623"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>ThetaType</span> <span class='hs-comment'>-- ^ Needed constraints (after simplification),</span>
<a name="line-624"></a>                               <span class='hs-comment'>-- i.e. @['PredType']@.</span>
<a name="line-625"></a><span class='hs-definition'>simplifyDeriv</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>thetas</span>
<a name="line-626"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>skol_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs_skols</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstSkolTyVars</span> <span class='hs-varid'>tvs</span> <span class='hs-comment'>-- Skolemize</span>
<a name="line-627"></a>                <span class='hs-comment'>-- The constraint solving machinery</span>
<a name="line-628"></a>                <span class='hs-comment'>-- expects *TcTyVars* not TyVars.</span>
<a name="line-629"></a>                <span class='hs-comment'>-- We use *non-overlappable* (vanilla) skolems</span>
<a name="line-630"></a>                <span class='hs-comment'>-- See Note [Overlap and deriving]</span>
<a name="line-631"></a>
<a name="line-632"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>skol_set</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tvs_skols</span>
<a name="line-633"></a>             <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DerivSkol</span> <span class='hs-varid'>pred</span>
<a name="line-634"></a>             <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"deriving"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-635"></a>
<a name="line-636"></a>             <span class='hs-varid'>mk_given_ev</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>EvVar</span>
<a name="line-637"></a>             <span class='hs-varid'>mk_given_ev</span> <span class='hs-varid'>given</span> <span class='hs-keyglyph'>=</span>
<a name="line-638"></a>               <span class='hs-keyword'>let</span> <span class='hs-varid'>given_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>skol_subst</span> <span class='hs-varid'>given</span>
<a name="line-639"></a>               <span class='hs-keyword'>in</span> <span class='hs-varid'>newEvVar</span> <span class='hs-varid'>given_pred</span>
<a name="line-640"></a>
<a name="line-641"></a>             <span class='hs-varid'>mk_wanted_ct</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-642"></a>             <span class='hs-varid'>mk_wanted_ct</span> <span class='hs-layout'>(</span><span class='hs-conid'>PredOrigin</span> <span class='hs-varid'>wanted</span> <span class='hs-varid'>o</span> <span class='hs-varid'>t_or_k</span><span class='hs-layout'>)</span>
<a name="line-643"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>newWanted</span> <span class='hs-varid'>o</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>t_or_k</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTyUnchecked</span> <span class='hs-varid'>skol_subst</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-644"></a>
<a name="line-645"></a>             <span class='hs-comment'>-- Create the implications we need to solve. For stock and newtype</span>
<a name="line-646"></a>             <span class='hs-comment'>-- deriving, these implication constraints will be simple class</span>
<a name="line-647"></a>             <span class='hs-comment'>-- constraints like (C a, Ord b).</span>
<a name="line-648"></a>             <span class='hs-comment'>-- But with DeriveAnyClass, we make an implication constraint.</span>
<a name="line-649"></a>             <span class='hs-comment'>-- See Note [Gathering and simplifying constraints for DeriveAnyClass]</span>
<a name="line-650"></a>             <span class='hs-varid'>mk_wanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-651"></a>             <span class='hs-varid'>mk_wanteds</span> <span class='hs-layout'>(</span><span class='hs-conid'>ThetaOrigin</span> <span class='hs-layout'>{</span> <span class='hs-varid'>to_tvs</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>local_skols</span>
<a name="line-652"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>to_givens</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens</span>
<a name="line-653"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>to_wanted_origins</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-654"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>local_skols</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-varid'>givens</span>
<a name="line-655"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wanted_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>mk_wanted_ct</span> <span class='hs-varid'>wanteds</span>
<a name="line-656"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSimpleWC</span> <span class='hs-varid'>wanted_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-657"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-658"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>given_evs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>mk_given_ev</span> <span class='hs-varid'>givens</span>
<a name="line-659"></a>                    <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanted_cts</span><span class='hs-layout'>,</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushTcLevelM</span> <span class='hs-varop'>$</span>
<a name="line-660"></a>                                             <span class='hs-varid'>mapM</span> <span class='hs-varid'>mk_wanted_ct</span> <span class='hs-varid'>wanteds</span>
<a name="line-661"></a>                    <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>buildImplicationFor</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>local_skols</span>
<a name="line-662"></a>                                                   <span class='hs-varid'>given_evs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSimpleWC</span> <span class='hs-varid'>wanted_cts</span><span class='hs-layout'>)</span>
<a name="line-663"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkImplicWC</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-664"></a>
<a name="line-665"></a>       <span class='hs-comment'>-- See [STEP DAC BUILD]</span>
<a name="line-666"></a>       <span class='hs-comment'>-- Generate the implication constraints constraints to solve with the</span>
<a name="line-667"></a>       <span class='hs-comment'>-- skolemized variables</span>
<a name="line-668"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanteds</span><span class='hs-layout'>,</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushTcLevelM</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>mk_wanteds</span> <span class='hs-varid'>thetas</span>
<a name="line-669"></a>
<a name="line-670"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyDeriv inputs"</span> <span class='hs-varop'>$</span>
<a name="line-671"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>pprTyVars</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>thetas</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>,</span> <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>]</span>
<a name="line-672"></a>
<a name="line-673"></a>       <span class='hs-comment'>-- See [STEP DAC SOLVE]</span>
<a name="line-674"></a>       <span class='hs-comment'>-- Simplify the constraints</span>
<a name="line-675"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solved_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSDeriveds</span> <span class='hs-varop'>$</span> <span class='hs-varid'>solveWantedsAndDrop</span>
<a name="line-676"></a>                                          <span class='hs-varop'>$</span> <span class='hs-varid'>unionsWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-677"></a>
<a name="line-678"></a>       <span class='hs-comment'>-- See [STEP DAC HOIST]</span>
<a name="line-679"></a>       <span class='hs-comment'>-- Split the resulting constraints into bad and good constraints,</span>
<a name="line-680"></a>       <span class='hs-comment'>-- building an @unsolved :: WantedConstraints@ representing all</span>
<a name="line-681"></a>       <span class='hs-comment'>-- the constraints we can't just shunt to the predicates.</span>
<a name="line-682"></a>       <span class='hs-comment'>-- See Note [Exotic derived instance contexts]</span>
<a name="line-683"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>residual_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>approximateWC</span> <span class='hs-conid'>True</span> <span class='hs-varid'>solved_implics</span>
<a name="line-684"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>bad</span><span class='hs-layout'>,</span> <span class='hs-varid'>good</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBagWith</span> <span class='hs-varid'>get_good</span> <span class='hs-varid'>residual_simple</span>
<a name="line-685"></a>
<a name="line-686"></a>             <span class='hs-varid'>get_good</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>Ct</span> <span class='hs-conid'>PredType</span>
<a name="line-687"></a>             <span class='hs-varid'>get_good</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>validDerivPred</span> <span class='hs-varid'>skol_set</span> <span class='hs-varid'>p</span>
<a name="line-688"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>isWantedCt</span> <span class='hs-varid'>ct</span>
<a name="line-689"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>p</span>
<a name="line-690"></a>                          <span class='hs-comment'>-- TODO: This is wrong</span>
<a name="line-691"></a>                          <span class='hs-comment'>-- NB re 'isWantedCt': residual_wanted may contain</span>
<a name="line-692"></a>                          <span class='hs-comment'>-- unsolved CtDerived and we stick them into the</span>
<a name="line-693"></a>                          <span class='hs-comment'>-- bad set so that reportUnsolved may decide what</span>
<a name="line-694"></a>                          <span class='hs-comment'>-- to do with them</span>
<a name="line-695"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-696"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>ct</span>
<a name="line-697"></a>                           <span class='hs-keyword'>where</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-698"></a>
<a name="line-699"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyDeriv outputs"</span> <span class='hs-varop'>$</span>
<a name="line-700"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tvs_skols</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>residual_simple</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>good</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bad</span> <span class='hs-keyglyph'>]</span>
<a name="line-701"></a>
<a name="line-702"></a>       <span class='hs-comment'>-- Return the good unsolved constraints (unskolemizing on the way out.)</span>
<a name="line-703"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>min_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>good</span><span class='hs-layout'>)</span>
<a name="line-704"></a>             <span class='hs-comment'>-- An important property of mkMinimalBySCs (used above) is that in</span>
<a name="line-705"></a>             <span class='hs-comment'>-- addition to removing constraints that are made redundant by</span>
<a name="line-706"></a>             <span class='hs-comment'>-- superclass relationships, it also removes _duplicate_</span>
<a name="line-707"></a>             <span class='hs-comment'>-- constraints.</span>
<a name="line-708"></a>             <span class='hs-comment'>-- See Note [Gathering and simplifying constraints for</span>
<a name="line-709"></a>             <span class='hs-comment'>--           DeriveAnyClass]</span>
<a name="line-710"></a>             <span class='hs-varid'>subst_skol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipTvSubst</span> <span class='hs-varid'>tvs_skols</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>tvs</span>
<a name="line-711"></a>                          <span class='hs-comment'>-- The reverse substitution (sigh)</span>
<a name="line-712"></a>
<a name="line-713"></a>       <span class='hs-comment'>-- See [STEP DAC RESIDUAL]</span>
<a name="line-714"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>min_theta_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>newEvVar</span> <span class='hs-varid'>min_theta</span>
<a name="line-715"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>leftover_implic</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>buildImplicationFor</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>tvs_skols</span>
<a name="line-716"></a>                                   <span class='hs-varid'>min_theta_vars</span> <span class='hs-varid'>solved_implics</span>
<a name="line-717"></a>       <span class='hs-comment'>-- This call to simplifyTop is purely for error reporting</span>
<a name="line-718"></a>       <span class='hs-comment'>-- See Note [Error reporting for deriving clauses]</span>
<a name="line-719"></a>       <span class='hs-comment'>-- See also Note [Exotic derived instance contexts], which are caught</span>
<a name="line-720"></a>       <span class='hs-comment'>-- in this line of code.</span>
<a name="line-721"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplifyTopImplic</span> <span class='hs-varid'>leftover_implic</span>
<a name="line-722"></a>
<a name="line-723"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTheta</span> <span class='hs-varid'>subst_skol</span> <span class='hs-varid'>min_theta</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-724"></a>
<a name="line-725"></a><span class='hs-comment'>{-
<a name="line-726"></a>Note [Overlap and deriving]
<a name="line-727"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-728"></a>Consider some overlapping instances:
<a name="line-729"></a>  data Show a =&gt; Show [a] where ..
<a name="line-730"></a>  data Show [Char] where ...
<a name="line-731"></a>
<a name="line-732"></a>Now a data type with deriving:
<a name="line-733"></a>  data T a = MkT [a] deriving( Show )
<a name="line-734"></a>
<a name="line-735"></a>We want to get the derived instance
<a name="line-736"></a>  instance Show [a] =&gt; Show (T a) where...
<a name="line-737"></a>and NOT
<a name="line-738"></a>  instance Show a =&gt; Show (T a) where...
<a name="line-739"></a>so that the (Show (T Char)) instance does the Right Thing
<a name="line-740"></a>
<a name="line-741"></a>It's very like the situation when we're inferring the type
<a name="line-742"></a>of a function
<a name="line-743"></a>   f x = show [x]
<a name="line-744"></a>and we want to infer
<a name="line-745"></a>   f :: Show [a] =&gt; a -&gt; String
<a name="line-746"></a>
<a name="line-747"></a>BOTTOM LINE: use vanilla, non-overlappable skolems when inferring
<a name="line-748"></a>             the context for the derived instance.
<a name="line-749"></a>             Hence tcInstSkolTyVars not tcInstSuperSkolTyVars
<a name="line-750"></a>
<a name="line-751"></a>Note [Gathering and simplifying constraints for DeriveAnyClass]
<a name="line-752"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-753"></a>DeriveAnyClass works quite differently from stock and newtype deriving in
<a name="line-754"></a>the way it gathers and simplifies constraints to be used in a derived
<a name="line-755"></a>instance's context. Stock and newtype deriving gather constraints by looking
<a name="line-756"></a>at the data constructors of the data type for which we are deriving an
<a name="line-757"></a>instance. But DeriveAnyClass doesn't need to know about a data type's
<a name="line-758"></a>definition at all!
<a name="line-759"></a>
<a name="line-760"></a>To see why, consider this example of DeriveAnyClass:
<a name="line-761"></a>
<a name="line-762"></a>  class Foo a where
<a name="line-763"></a>    bar :: forall b. Ix b =&gt; a -&gt; b -&gt; String
<a name="line-764"></a>    default bar :: (Show a, Ix c) =&gt; a -&gt; c -&gt; String
<a name="line-765"></a>    bar x y = show x ++ show (range (y,y))
<a name="line-766"></a>
<a name="line-767"></a>    baz :: Eq a =&gt; a -&gt; a -&gt; Bool
<a name="line-768"></a>    default baz :: (Ord a, Show a) =&gt; a -&gt; a -&gt; Bool
<a name="line-769"></a>    baz x y = compare x y == EQ
<a name="line-770"></a>
<a name="line-771"></a>Because 'bar' and 'baz' have default signatures, this generates a top-level
<a name="line-772"></a>definition for these generic default methods
<a name="line-773"></a>
<a name="line-774"></a>  $gdm_bar :: forall a. Foo a
<a name="line-775"></a>           =&gt; forall c. (Show a, Ix c)
<a name="line-776"></a>           =&gt; a -&gt; c -&gt; String
<a name="line-777"></a>  $gdm_bar x y = show x ++ show (range (y,y))
<a name="line-778"></a>
<a name="line-779"></a>(and similarly for baz).  Now consider a 'deriving' clause
<a name="line-780"></a>  data Maybe s = ... deriving Foo
<a name="line-781"></a>
<a name="line-782"></a>This derives an instance of the form:
<a name="line-783"></a>  instance (CX) =&gt; Foo (Maybe s) where
<a name="line-784"></a>    bar = $gdm_bar
<a name="line-785"></a>    baz = $gdm_baz
<a name="line-786"></a>
<a name="line-787"></a>Now it is GHC's job to fill in a suitable instance context (CX).  If
<a name="line-788"></a>GHC were typechecking the binding
<a name="line-789"></a>   bar = $gdm bar
<a name="line-790"></a>it would
<a name="line-791"></a>   * skolemise the expected type of bar
<a name="line-792"></a>   * instantiate the type of $dm_bar with meta-type variables
<a name="line-793"></a>   * build an implication constraint
<a name="line-794"></a>
<a name="line-795"></a>[STEP DAC BUILD]
<a name="line-796"></a>So that's what we do.  We build the constraint (call it C1)
<a name="line-797"></a>
<a name="line-798"></a>   forall b. Ix b =&gt; (Show (Maybe s), Ix cc,
<a name="line-799"></a>                      Maybe s -&gt; b -&gt; String
<a name="line-800"></a>                          ~ Maybe s -&gt; cc -&gt; String)
<a name="line-801"></a>
<a name="line-802"></a>The 'cc' is a unification variable that comes from instantiating
<a name="line-803"></a>$dm_bar's type.  The equality constraint comes from marrying up
<a name="line-804"></a>the instantiated type of $dm_bar with the specified type of bar.
<a name="line-805"></a>Notice that the type variables from the instance, 's' in this case,
<a name="line-806"></a>are global to this constraint.
<a name="line-807"></a>
<a name="line-808"></a>Similarly for 'baz', givng the constraint C2
<a name="line-809"></a>
<a name="line-810"></a>   forall. Eq (Maybe s) =&gt; (Ord a, Show a,
<a name="line-811"></a>                            Maybe s -&gt; Maybe s -&gt; Bool
<a name="line-812"></a>                                ~ Maybe s -&gt; Maybe s -&gt; Bool)
<a name="line-813"></a>
<a name="line-814"></a>In this case baz has no local quantification, so the implication
<a name="line-815"></a>constraint has no local skolems and there are no unification
<a name="line-816"></a>variables.
<a name="line-817"></a>
<a name="line-818"></a>[STEP DAC SOLVE]
<a name="line-819"></a>We can combine these two implication constraints into a single
<a name="line-820"></a>constraint (C1, C2), and simplify, unifying cc:=b, to get:
<a name="line-821"></a>
<a name="line-822"></a>   forall b. Ix b =&gt; Show a
<a name="line-823"></a>   /\
<a name="line-824"></a>   forall. Eq (Maybe s) =&gt; (Ord a, Show a)
<a name="line-825"></a>
<a name="line-826"></a>[STEP DAC HOIST]
<a name="line-827"></a>Let's call that (C1', C2').  Now we need to hoist the unsolved
<a name="line-828"></a>constraints out of the implications to become our candidate for
<a name="line-829"></a>(CX). That is done by approximateWC, which will return:
<a name="line-830"></a>
<a name="line-831"></a>  (Show a, Ord a, Show a)
<a name="line-832"></a>
<a name="line-833"></a>Now we can use mkMinimalBySCs to remove superclasses and duplicates, giving
<a name="line-834"></a>
<a name="line-835"></a>  (Show a, Ord a)
<a name="line-836"></a>
<a name="line-837"></a>And that's what GHC uses for CX.
<a name="line-838"></a>
<a name="line-839"></a>[STEP DAC RESIDUAL]
<a name="line-840"></a>In this case we have solved all the leftover constraints, but what if
<a name="line-841"></a>we don't?  Simple!  We just form the final residual constraint
<a name="line-842"></a>
<a name="line-843"></a>   forall s. CX =&gt; (C1',C2')
<a name="line-844"></a>
<a name="line-845"></a>and simplify that. In simple cases it'll succeed easily, because CX
<a name="line-846"></a>literally contains the constraints in C1', C2', but if there is anything
<a name="line-847"></a>more complicated it will be reported in a civilised way.
<a name="line-848"></a>
<a name="line-849"></a>Note [Error reporting for deriving clauses]
<a name="line-850"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-851"></a>A suprisingly tricky aspect of deriving to get right is reporting sensible
<a name="line-852"></a>error messages. In particular, if simplifyDeriv reaches a constraint that it
<a name="line-853"></a>cannot solve, which might include:
<a name="line-854"></a>
<a name="line-855"></a>1. Insoluble constraints
<a name="line-856"></a>2. "Exotic" constraints (See Note [Exotic derived instance contexts])
<a name="line-857"></a>
<a name="line-858"></a>Then we report an error immediately in simplifyDeriv.
<a name="line-859"></a>
<a name="line-860"></a>Another possible choice is to punt and let another part of the typechecker
<a name="line-861"></a>(e.g., simplifyInstanceContexts) catch the errors. But this tends to lead
<a name="line-862"></a>to worse error messages, so we do it directly in simplifyDeriv.
<a name="line-863"></a>
<a name="line-864"></a>simplifyDeriv checks for errors in a clever way. If the deriving machinery
<a name="line-865"></a>infers the context (Foo a)--that is, if this instance is to be generated:
<a name="line-866"></a>
<a name="line-867"></a>  instance Foo a =&gt; ...
<a name="line-868"></a>
<a name="line-869"></a>Then we form an implication of the form:
<a name="line-870"></a>
<a name="line-871"></a>  forall a. Foo a =&gt; &lt;residual_wanted_constraints&gt;
<a name="line-872"></a>
<a name="line-873"></a>And pass it to the simplifier. If the context (Foo a) is enough to discharge
<a name="line-874"></a>all the constraints in &lt;residual_wanted_constraints&gt;, then everything is
<a name="line-875"></a>hunky-dory. But if &lt;residual_wanted_constraints&gt; contains, say, an insoluble
<a name="line-876"></a>constraint, then (Foo a) won't be able to solve it, causing GHC to error.
<a name="line-877"></a>
<a name="line-878"></a>Note [Exotic derived instance contexts]
<a name="line-879"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-880"></a>In a 'derived' instance declaration, we *infer* the context.  It's a
<a name="line-881"></a>bit unclear what rules we should apply for this; the Haskell report is
<a name="line-882"></a>silent.  Obviously, constraints like (Eq a) are fine, but what about
<a name="line-883"></a>        data T f a = MkT (f a) deriving( Eq )
<a name="line-884"></a>where we'd get an Eq (f a) constraint.  That's probably fine too.
<a name="line-885"></a>
<a name="line-886"></a>One could go further: consider
<a name="line-887"></a>        data T a b c = MkT (Foo a b c) deriving( Eq )
<a name="line-888"></a>        instance (C Int a, Eq b, Eq c) =&gt; Eq (Foo a b c)
<a name="line-889"></a>
<a name="line-890"></a>Notice that this instance (just) satisfies the Paterson termination
<a name="line-891"></a>conditions.  Then we *could* derive an instance decl like this:
<a name="line-892"></a>
<a name="line-893"></a>        instance (C Int a, Eq b, Eq c) =&gt; Eq (T a b c)
<a name="line-894"></a>even though there is no instance for (C Int a), because there just
<a name="line-895"></a>*might* be an instance for, say, (C Int Bool) at a site where we
<a name="line-896"></a>need the equality instance for T's.
<a name="line-897"></a>
<a name="line-898"></a>However, this seems pretty exotic, and it's quite tricky to allow
<a name="line-899"></a>this, and yet give sensible error messages in the (much more common)
<a name="line-900"></a>case where we really want that instance decl for C.
<a name="line-901"></a>
<a name="line-902"></a>So for now we simply require that the derived instance context
<a name="line-903"></a>should have only type-variable constraints.
<a name="line-904"></a>
<a name="line-905"></a>Here is another example:
<a name="line-906"></a>        data Fix f = In (f (Fix f)) deriving( Eq )
<a name="line-907"></a>Here, if we are prepared to allow -XUndecidableInstances we
<a name="line-908"></a>could derive the instance
<a name="line-909"></a>        instance Eq (f (Fix f)) =&gt; Eq (Fix f)
<a name="line-910"></a>but this is so delicate that I don't think it should happen inside
<a name="line-911"></a>'deriving'. If you want this, write it yourself!
<a name="line-912"></a>
<a name="line-913"></a>NB: if you want to lift this condition, make sure you still meet the
<a name="line-914"></a>termination conditions!  If not, the deriving mechanism generates
<a name="line-915"></a>larger and larger constraints.  Example:
<a name="line-916"></a>  data Succ a = S a
<a name="line-917"></a>  data Seq a = Cons a (Seq (Succ a)) | Nil deriving Show
<a name="line-918"></a>
<a name="line-919"></a>Note the lack of a Show instance for Succ.  First we'll generate
<a name="line-920"></a>  instance (Show (Succ a), Show a) =&gt; Show (Seq a)
<a name="line-921"></a>and then
<a name="line-922"></a>  instance (Show (Succ (Succ a)), Show (Succ a), Show a) =&gt; Show (Seq a)
<a name="line-923"></a>and so on.  Instead we want to complain of no instance for (Show (Succ a)).
<a name="line-924"></a>
<a name="line-925"></a>The bottom line
<a name="line-926"></a>~~~~~~~~~~~~~~~
<a name="line-927"></a>Allow constraints which consist only of type variables, with no repeats.
<a name="line-928"></a>-}</span>
</pre></body>
</html>
