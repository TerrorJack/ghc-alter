<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>stranal/DmdAnal.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The GRASP/AQUA Project, Glasgow University, 1993-1998
<a name="line-3"></a>
<a name="line-4"></a>
<a name="line-5"></a>                        -----------------
<a name="line-6"></a>                        A demand analysis
<a name="line-7"></a>                        -----------------
<a name="line-8"></a>-}</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>DmdAnal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>dmdAnalProgram</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>WwLib</span>            <span class='hs-layout'>(</span> <span class='hs-varid'>findTypeShape</span><span class='hs-layout'>,</span> <span class='hs-varid'>deepSplitProductType_maybe</span> <span class='hs-layout'>)</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Demand</span>   <span class='hs-comment'>-- All of it</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreSyn</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreSeq</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>seqBinds</span> <span class='hs-layout'>)</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUtils</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>exprIsHNF</span><span class='hs-layout'>,</span> <span class='hs-varid'>exprType</span><span class='hs-layout'>,</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-layout'>)</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span>         <span class='hs-layout'>(</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>,</span> <span class='hs-varid'>coVarsOfCo</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FamInstEnv</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span>           <span class='hs-layout'>(</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>)</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysWiredIn</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysPrim</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>realWorldStatePrimTy</span> <span class='hs-layout'>)</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ErrUtils</span>         <span class='hs-layout'>(</span> <span class='hs-varid'>dumpIfSet_dyn</span> <span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>             <span class='hs-layout'>(</span> <span class='hs-varid'>getName</span><span class='hs-layout'>,</span> <span class='hs-varid'>stableNameCmp</span> <span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Function</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>on</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>UniqSet</span>
<a name="line-40"></a>
<a name="line-41"></a><span class='hs-comment'>{-
<a name="line-42"></a>************************************************************************
<a name="line-43"></a>*                                                                      *
<a name="line-44"></a>\subsection{Top level stuff}
<a name="line-45"></a>*                                                                      *
<a name="line-46"></a>************************************************************************
<a name="line-47"></a>-}</span>
<a name="line-48"></a>
<a name="line-49"></a><a name="dmdAnalProgram"></a><span class='hs-definition'>dmdAnalProgram</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CoreProgram</span>
<a name="line-50"></a><span class='hs-definition'>dmdAnalProgram</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>binds</span>
<a name="line-51"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>
<a name="line-52"></a>        <span class='hs-keyword'>let</span> <span class='hs-layout'>{</span> <span class='hs-varid'>binds_plus_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>do_prog</span> <span class='hs-varid'>binds</span> <span class='hs-layout'>}</span> <span class='hs-layout'>;</span>
<a name="line-53"></a>        <span class='hs-varid'>dumpIfSet_dyn</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_D_dump_str_signatures</span>
<a name="line-54"></a>                      <span class='hs-str'>"Strictness signatures"</span> <span class='hs-varop'>$</span>
<a name="line-55"></a>            <span class='hs-varid'>dumpStrSig</span> <span class='hs-varid'>binds_plus_dmds</span> <span class='hs-layout'>;</span>
<a name="line-56"></a>        <span class='hs-comment'>-- See Note [Stamp out space leaks in demand analysis]</span>
<a name="line-57"></a>        <span class='hs-varid'>seqBinds</span> <span class='hs-varid'>binds_plus_dmds</span> <span class='hs-varop'>`seq`</span> <span class='hs-varid'>return</span> <span class='hs-varid'>binds_plus_dmds</span>
<a name="line-58"></a>    <span class='hs-layout'>}</span>
<a name="line-59"></a>  <span class='hs-keyword'>where</span>
<a name="line-60"></a>    <span class='hs-varid'>do_prog</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span>
<a name="line-61"></a>    <span class='hs-varid'>do_prog</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>dmdAnalTopBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyAnalEnv</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span><span class='hs-layout'>)</span> <span class='hs-varid'>binds</span>
<a name="line-62"></a>
<a name="line-63"></a><a name="dmdAnalTopBind"></a><span class='hs-comment'>-- Analyse a (group of) top-level binding(s)</span>
<a name="line-64"></a><span class='hs-definition'>dmdAnalTopBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-65"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-66"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBind</span><span class='hs-layout'>)</span>
<a name="line-67"></a><span class='hs-definition'>dmdAnalTopBind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-68"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendAnalEnv</span> <span class='hs-conid'>TopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id2</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>id2</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>id2</span> <span class='hs-varid'>rhs2</span><span class='hs-layout'>)</span>
<a name="line-69"></a>  <span class='hs-keyword'>where</span>
<a name="line-70"></a>    <span class='hs-layout'>(</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span>   <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalRhsLetDown</span> <span class='hs-conid'>TopLevel</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>env</span>             <span class='hs-varid'>cleanEvalDmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-71"></a>    <span class='hs-layout'>(</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>id2</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalRhsLetDown</span> <span class='hs-conid'>TopLevel</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>(</span><span class='hs-varid'>nonVirgin</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>cleanEvalDmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs1</span>
<a name="line-72"></a>        <span class='hs-comment'>-- Do two passes to improve CPR information</span>
<a name="line-73"></a>        <span class='hs-comment'>-- See Note [CPR for thunks]</span>
<a name="line-74"></a>        <span class='hs-comment'>-- See Note [Optimistic CPR in the "virgin" case]</span>
<a name="line-75"></a>        <span class='hs-comment'>-- See Note [Initial CPR for strict binders]</span>
<a name="line-76"></a>
<a name="line-77"></a><span class='hs-definition'>dmdAnalTopBind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>
<a name="line-78"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-79"></a>  <span class='hs-keyword'>where</span>
<a name="line-80"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdFix</span> <span class='hs-conid'>TopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cleanEvalDmd</span> <span class='hs-varid'>pairs</span>
<a name="line-81"></a>                <span class='hs-comment'>-- We get two iterations automatically</span>
<a name="line-82"></a>                <span class='hs-comment'>-- c.f. the NonRec case above</span>
<a name="line-83"></a>
<a name="line-84"></a><span class='hs-comment'>{- Note [Stamp out space leaks in demand analysis]
<a name="line-85"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-86"></a>The demand analysis pass outputs a new copy of the Core program in
<a name="line-87"></a>which binders have been annotated with demand and strictness
<a name="line-88"></a>information. It's tiresome to ensure that this information is fully
<a name="line-89"></a>evaluated everywhere that we produce it, so we just run a single
<a name="line-90"></a>seqBinds over the output before returning it, to ensure that there are
<a name="line-91"></a>no references holding on to the input Core program.
<a name="line-92"></a>
<a name="line-93"></a>This makes a ~30% reduction in peak memory usage when compiling
<a name="line-94"></a>DynFlags (cf Trac #9675 and #13426).
<a name="line-95"></a>
<a name="line-96"></a>This is particularly important when we are doing late demand analysis,
<a name="line-97"></a>since we don't do a seqBinds at any point thereafter. Hence code
<a name="line-98"></a>generation would hold on to an extra copy of the Core program, via
<a name="line-99"></a>unforced thunks in demand or strictness information; and it is the
<a name="line-100"></a>most memory-intensive part of the compilation process, so this added
<a name="line-101"></a>seqBinds makes a big difference in peak memory usage.
<a name="line-102"></a>-}</span>
<a name="line-103"></a>
<a name="line-104"></a>
<a name="line-105"></a><span class='hs-comment'>{-
<a name="line-106"></a>************************************************************************
<a name="line-107"></a>*                                                                      *
<a name="line-108"></a>\subsection{The analyser itself}
<a name="line-109"></a>*                                                                      *
<a name="line-110"></a>************************************************************************
<a name="line-111"></a>
<a name="line-112"></a>Note [Ensure demand is strict]
<a name="line-113"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-114"></a>It's important not to analyse e with a lazy demand because
<a name="line-115"></a>a) When we encounter   case s of (a,b) -&gt;
<a name="line-116"></a>        we demand s with U(d1d2)... but if the overall demand is lazy
<a name="line-117"></a>        that is wrong, and we'd need to reduce the demand on s,
<a name="line-118"></a>        which is inconvenient
<a name="line-119"></a>b) More important, consider
<a name="line-120"></a>        f (let x = R in x+x), where f is lazy
<a name="line-121"></a>   We still want to mark x as demanded, because it will be when we
<a name="line-122"></a>   enter the let.  If we analyse f's arg with a Lazy demand, we'll
<a name="line-123"></a>   just mark x as Lazy
<a name="line-124"></a>c) The application rule wouldn't be right either
<a name="line-125"></a>   Evaluating (f x) in a L demand does *not* cause
<a name="line-126"></a>   evaluation of f in a C(L) demand!
<a name="line-127"></a>-}</span>
<a name="line-128"></a>
<a name="line-129"></a><a name="dmdTransformThunkDmd"></a><span class='hs-comment'>-- If e is complicated enough to become a thunk, its contents will be evaluated</span>
<a name="line-130"></a><span class='hs-comment'>-- at most once, so oneify it.</span>
<a name="line-131"></a><span class='hs-definition'>dmdTransformThunkDmd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span>
<a name="line-132"></a><span class='hs-definition'>dmdTransformThunkDmd</span> <span class='hs-varid'>e</span>
<a name="line-133"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-134"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oneifyDmd</span>
<a name="line-135"></a>
<a name="line-136"></a><a name="dmdAnalStar"></a><span class='hs-comment'>-- Do not process absent demands</span>
<a name="line-137"></a><span class='hs-comment'>-- Otherwise act like in a normal demand analysis</span>
<a name="line-138"></a><span class='hs-comment'>-- See ↦* relation in the Cardinality Analysis paper</span>
<a name="line-139"></a><span class='hs-definition'>dmdAnalStar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-140"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span>   <span class='hs-comment'>-- This one takes a *Demand*</span>
<a name="line-141"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>BothDmdArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-142"></a><span class='hs-definition'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>e</span>
<a name="line-143"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>defer_and_use</span><span class='hs-layout'>,</span> <span class='hs-varid'>cd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>toCleanDmd</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-144"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cd</span> <span class='hs-varid'>e</span>
<a name="line-145"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>postProcessDmdType</span> <span class='hs-varid'>defer_and_use</span> <span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-146"></a>
<a name="line-147"></a><a name="dmdAnal"></a><span class='hs-comment'>-- Main Demand Analsysis machinery</span>
<a name="line-148"></a><span class='hs-definition'>dmdAnal</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmdAnal'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-149"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CleanDemand</span>         <span class='hs-comment'>-- The main one takes a *CleanDemand*</span>
<a name="line-150"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-151"></a>
<a name="line-152"></a><span class='hs-comment'>-- The CleanDemand is always strict and not absent</span>
<a name="line-153"></a><span class='hs-comment'>--    See Note [Ensure demand is strict]</span>
<a name="line-154"></a>
<a name="line-155"></a><span class='hs-definition'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>d</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdAnal" (ppr d &lt;+&gt; ppr e) $</span>
<a name="line-156"></a>                  <span class='hs-varid'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>d</span> <span class='hs-varid'>e</span>
<a name="line-157"></a>
<a name="line-158"></a><a name="dmdAnal'"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>nopDmdType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>
<a name="line-159"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>nopDmdType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Doesn't happen, in fact</span>
<a name="line-160"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-161"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionDmdEnv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-162"></a>
<a name="line-163"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-164"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdTransform</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-165"></a>
<a name="line-166"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-167"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span> <span class='hs-varop'>`bothDmdType`</span> <span class='hs-varid'>mkBothDmdArg</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionDmdEnv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>e'</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-168"></a>  <span class='hs-keyword'>where</span>
<a name="line-169"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>e</span>
<a name="line-170"></a>
<a name="line-171"></a><span class='hs-comment'>{-       ----- I don't get this, so commenting out -------
<a name="line-172"></a>    to_co        = pSnd (coercionKind co)
<a name="line-173"></a>    dmd'
<a name="line-174"></a>      | Just tc &lt;- tyConAppTyCon_maybe to_co
<a name="line-175"></a>      , isRecursiveTyCon tc = cleanEvalDmd
<a name="line-176"></a>      | otherwise           = dmd
<a name="line-177"></a>        -- This coerce usually arises from a recursive
<a name="line-178"></a>        -- newtype, and we don't want to look inside them
<a name="line-179"></a>        -- for exactly the same reason that we don't look
<a name="line-180"></a>        -- inside recursive products -- we might not reach
<a name="line-181"></a>        -- a fixpoint.  So revert to a vanilla Eval demand
<a name="line-182"></a>-}</span>
<a name="line-183"></a>
<a name="line-184"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-185"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-186"></a>  <span class='hs-keyword'>where</span>
<a name="line-187"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>e</span>
<a name="line-188"></a>
<a name="line-189"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-190"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>fun_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>App</span> <span class='hs-varid'>fun'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-191"></a>  <span class='hs-keyword'>where</span>
<a name="line-192"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>fun_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>fun</span>
<a name="line-193"></a>
<a name="line-194"></a><span class='hs-comment'>-- Lots of the other code is there to make this</span>
<a name="line-195"></a><span class='hs-comment'>-- beautiful, compositional, application rule :-)</span>
<a name="line-196"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-197"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- This case handles value arguments (type args handled above)</span>
<a name="line-198"></a>    <span class='hs-comment'>-- Crucially, coercions /are/ handled here, because they are</span>
<a name="line-199"></a>    <span class='hs-comment'>-- value arguments (Trac #10288)</span>
<a name="line-200"></a>    <span class='hs-keyword'>let</span>
<a name="line-201"></a>        <span class='hs-varid'>call_dmd</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCallDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-202"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>fun_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun'</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>call_dmd</span> <span class='hs-varid'>fun</span>
<a name="line-203"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>arg_dmd</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitDmdTy</span> <span class='hs-varid'>fun_ty</span>
<a name="line-204"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdTransformThunkDmd</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>arg_dmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-205"></a>    <span class='hs-keyword'>in</span>
<a name="line-206"></a><span class='hs-comment'>--    pprTrace "dmdAnal:app" (vcat</span>
<a name="line-207"></a><span class='hs-comment'>--         [ text "dmd =" &lt;+&gt; ppr dmd</span>
<a name="line-208"></a><span class='hs-comment'>--         , text "expr =" &lt;+&gt; ppr (App fun arg)</span>
<a name="line-209"></a><span class='hs-comment'>--         , text "fun dmd_ty =" &lt;+&gt; ppr fun_ty</span>
<a name="line-210"></a><span class='hs-comment'>--         , text "arg dmd =" &lt;+&gt; ppr arg_dmd</span>
<a name="line-211"></a><span class='hs-comment'>--         , text "arg dmd_ty =" &lt;+&gt; ppr arg_ty</span>
<a name="line-212"></a><span class='hs-comment'>--         , text "res dmd_ty =" &lt;+&gt; ppr res_ty</span>
<a name="line-213"></a><span class='hs-comment'>--         , text "overall res dmd_ty =" &lt;+&gt; ppr (res_ty `bothDmdType` arg_ty) ])</span>
<a name="line-214"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>res_ty</span> <span class='hs-varop'>`bothDmdType`</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>App</span> <span class='hs-varid'>fun'</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span>
<a name="line-215"></a>
<a name="line-216"></a><span class='hs-comment'>-- this is an anonymous lambda, since @dmdAnalRhsLetDown@ uses @collectBinders@</span>
<a name="line-217"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>var</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-218"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>var</span>
<a name="line-219"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-220"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>body</span>
<a name="line-221"></a>    <span class='hs-keyword'>in</span>
<a name="line-222"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>var</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-223"></a>
<a name="line-224"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-225"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_dmd</span><span class='hs-layout'>,</span> <span class='hs-varid'>defer_and_use</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>peelCallDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-226"></a>          <span class='hs-comment'>-- body_dmd: a demand to analyze the body</span>
<a name="line-227"></a>
<a name="line-228"></a>        <span class='hs-varid'>env'</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigsWithLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span>
<a name="line-229"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body_dmd</span> <span class='hs-varid'>body</span>
<a name="line-230"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>lam_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>var'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>annotateLamIdBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>notArgOfDfun</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>var</span>
<a name="line-231"></a>    <span class='hs-keyword'>in</span>
<a name="line-232"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>postProcessUnsat</span> <span class='hs-varid'>defer_and_use</span> <span class='hs-varid'>lam_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>var'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-233"></a>
<a name="line-234"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-235"></a>  <span class='hs-comment'>-- Only one alternative with a product constructor</span>
<a name="line-236"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tycon</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>dc</span>
<a name="line-237"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDataProductTyCon_maybe</span> <span class='hs-varid'>tycon</span><span class='hs-layout'>)</span>
<a name="line-238"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rec_tc'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>checkRecTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_rec_tc</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>tycon</span>
<a name="line-239"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-240"></a>        <span class='hs-varid'>env_w_tc</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_rec_tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rec_tc'</span> <span class='hs-layout'>}</span>
<a name="line-241"></a>        <span class='hs-varid'>env_alt</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendEnvForProdAlt</span> <span class='hs-varid'>env_w_tc</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>bndrs</span>
<a name="line-242"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env_alt</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>rhs</span>
<a name="line-243"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>alt_ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmds</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrsDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-244"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>alt_ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr_dmd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-conid'>False</span> <span class='hs-varid'>alt_ty1</span> <span class='hs-varid'>case_bndr</span>
<a name="line-245"></a>        <span class='hs-varid'>id_dmds</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addCaseBndrDmd</span> <span class='hs-varid'>case_bndr_dmd</span> <span class='hs-varid'>dmds</span>
<a name="line-246"></a>        <span class='hs-varid'>alt_ty3</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>io_hack_reqd</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deferAfterIO</span> <span class='hs-varid'>alt_ty2</span>
<a name="line-247"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_ty2</span>
<a name="line-248"></a>
<a name="line-249"></a>        <span class='hs-comment'>-- Compute demand on the scrutinee</span>
<a name="line-250"></a>        <span class='hs-comment'>-- See Note [Demand on scrutinee of a product case]</span>
<a name="line-251"></a>        <span class='hs-varid'>scrut_dmd</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkProdDmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>addDataConStrictness</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>id_dmds</span><span class='hs-layout'>)</span>
<a name="line-252"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>scrut_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut_dmd</span> <span class='hs-varid'>scrut</span>
<a name="line-253"></a>        <span class='hs-varid'>res_ty</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_ty3</span> <span class='hs-varop'>`bothDmdType`</span> <span class='hs-varid'>toBothDmdArg</span> <span class='hs-varid'>scrut_ty</span>
<a name="line-254"></a>        <span class='hs-varid'>case_bndr'</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>case_bndr_dmd</span>
<a name="line-255"></a>        <span class='hs-varid'>bndrs'</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>id_dmds</span>
<a name="line-256"></a>    <span class='hs-keyword'>in</span>
<a name="line-257"></a><span class='hs-comment'>--    pprTrace "dmdAnal:Case1" (vcat [ text "scrut" &lt;+&gt; ppr scrut</span>
<a name="line-258"></a><span class='hs-comment'>--                                   , text "dmd" &lt;+&gt; ppr dmd</span>
<a name="line-259"></a><span class='hs-comment'>--                                   , text "case_bndr_dmd" &lt;+&gt; ppr (idDemandInfo case_bndr')</span>
<a name="line-260"></a><span class='hs-comment'>--                                   , text "scrut_dmd" &lt;+&gt; ppr scrut_dmd</span>
<a name="line-261"></a><span class='hs-comment'>--                                   , text "scrut_ty" &lt;+&gt; ppr scrut_ty</span>
<a name="line-262"></a><span class='hs-comment'>--                                   , text "alt_ty" &lt;+&gt; ppr alt_ty2</span>
<a name="line-263"></a><span class='hs-comment'>--                                   , text "res_ty" &lt;+&gt; ppr res_ty ]) $</span>
<a name="line-264"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>res_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-265"></a>
<a name="line-266"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-267"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>      <span class='hs-comment'>-- Case expression with multiple alternatives</span>
<a name="line-268"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>alt_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAndUnzip</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdAnalAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span>
<a name="line-269"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>scrut_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cleanEvalDmd</span> <span class='hs-varid'>scrut</span>
<a name="line-270"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>alt_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>annotateBndr</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-varid'>lubDmdType</span> <span class='hs-varid'>botDmdType</span> <span class='hs-varid'>alt_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>case_bndr</span>
<a name="line-271"></a>                               <span class='hs-comment'>-- NB: Base case is botDmdType, for empty case alternatives</span>
<a name="line-272"></a>                               <span class='hs-comment'>--     This is a unit for lubDmdType, and the right result</span>
<a name="line-273"></a>                               <span class='hs-comment'>--     when there really are no alternatives</span>
<a name="line-274"></a>        <span class='hs-varid'>res_ty</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_ty</span> <span class='hs-varop'>`bothDmdType`</span> <span class='hs-varid'>toBothDmdArg</span> <span class='hs-varid'>scrut_ty</span>
<a name="line-275"></a>    <span class='hs-keyword'>in</span>
<a name="line-276"></a><span class='hs-comment'>--    pprTrace "dmdAnal:Case2" (vcat [ text "scrut" &lt;+&gt; ppr scrut</span>
<a name="line-277"></a><span class='hs-comment'>--                                   , text "scrut_ty" &lt;+&gt; ppr scrut_ty</span>
<a name="line-278"></a><span class='hs-comment'>--                                   , text "alt_tys" &lt;+&gt; ppr alt_tys</span>
<a name="line-279"></a><span class='hs-comment'>--                                   , text "alt_ty" &lt;+&gt; ppr alt_ty</span>
<a name="line-280"></a><span class='hs-comment'>--                                   , text "res_ty" &lt;+&gt; ppr res_ty ]) $</span>
<a name="line-281"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>res_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>
<a name="line-282"></a>
<a name="line-283"></a><span class='hs-comment'>-- Let bindings can be processed in two ways:</span>
<a name="line-284"></a><span class='hs-comment'>-- Down (RHS before body) or Up (body before RHS).</span>
<a name="line-285"></a><span class='hs-comment'>-- The following case handle the up variant.</span>
<a name="line-286"></a><span class='hs-comment'>--</span>
<a name="line-287"></a><span class='hs-comment'>-- It is very simple. For  let x = rhs in body</span>
<a name="line-288"></a><span class='hs-comment'>--   * Demand-analyse 'body' in the current environment</span>
<a name="line-289"></a><span class='hs-comment'>--   * Find the demand, 'rhs_dmd' placed on 'x' by 'body'</span>
<a name="line-290"></a><span class='hs-comment'>--   * Demand-analyse 'rhs' in 'rhs_dmd'</span>
<a name="line-291"></a><span class='hs-comment'>--</span>
<a name="line-292"></a><span class='hs-comment'>-- This is used for a non-recursive local let without manifest lambdas.</span>
<a name="line-293"></a><span class='hs-comment'>-- This is the LetUp rule in the paper “Higher-Order Cardinality Analysis”.</span>
<a name="line-294"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-295"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>useLetUp</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-296"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unpackTrivial</span> <span class='hs-varid'>rhs</span>
<a name="line-297"></a>      <span class='hs-comment'>-- dmdAnalRhsLetDown treats trivial right hand sides specially</span>
<a name="line-298"></a>      <span class='hs-comment'>-- so if we have a trival right hand side, fall through to that.</span>
<a name="line-299"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-300"></a>  <span class='hs-keyword'>where</span>
<a name="line-301"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>body</span>
<a name="line-302"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>id_dmd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>notArgOfDfun</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>id</span>
<a name="line-303"></a>    <span class='hs-varid'>id'</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>id</span> <span class='hs-varid'>id_dmd</span>
<a name="line-304"></a>
<a name="line-305"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdTransformThunkDmd</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>id_dmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-306"></a>    <span class='hs-varid'>final_ty</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body_ty'</span> <span class='hs-varop'>`bothDmdType`</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-307"></a>
<a name="line-308"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-309"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_ty2</span><span class='hs-layout'>,</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id2</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-310"></a>  <span class='hs-keyword'>where</span>
<a name="line-311"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalRhsLetDown</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-312"></a>    <span class='hs-varid'>env1</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnv</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id1</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>id1</span><span class='hs-layout'>)</span>
<a name="line-313"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>body</span>
<a name="line-314"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>id2</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>annotateBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>id1</span>
<a name="line-315"></a>    <span class='hs-varid'>body_ty2</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addLazyFVs</span> <span class='hs-varid'>body_ty1</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-comment'>-- see Note [Lazy and unleashable free variables]</span>
<a name="line-316"></a>
<a name="line-317"></a>        <span class='hs-comment'>-- If the actual demand is better than the vanilla call</span>
<a name="line-318"></a>        <span class='hs-comment'>-- demand, you might think that we might do better to re-analyse</span>
<a name="line-319"></a>        <span class='hs-comment'>-- the RHS with the stronger demand.</span>
<a name="line-320"></a>        <span class='hs-comment'>-- But (a) That seldom happens, because it means that *every* path in</span>
<a name="line-321"></a>        <span class='hs-comment'>--         the body of the let has to use that stronger demand</span>
<a name="line-322"></a>        <span class='hs-comment'>-- (b) It often happens temporarily in when fixpointing, because</span>
<a name="line-323"></a>        <span class='hs-comment'>--     the recursive function at first seems to place a massive demand.</span>
<a name="line-324"></a>        <span class='hs-comment'>--     But we don't want to go to extra work when the function will</span>
<a name="line-325"></a>        <span class='hs-comment'>--     probably iterate to something less demanding.</span>
<a name="line-326"></a>        <span class='hs-comment'>-- In practice, all the times the actual demand on id2 is more than</span>
<a name="line-327"></a>        <span class='hs-comment'>-- the vanilla call demand seem to be due to (b).  So we don't</span>
<a name="line-328"></a>        <span class='hs-comment'>-- bother to re-analyse the RHS.</span>
<a name="line-329"></a>
<a name="line-330"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-331"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-332"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdFix</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>pairs</span>
<a name="line-333"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>body</span>
<a name="line-334"></a>        <span class='hs-varid'>body_ty1</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deleteFVs</span> <span class='hs-varid'>body_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>
<a name="line-335"></a>        <span class='hs-varid'>body_ty2</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addLazyFVs</span> <span class='hs-varid'>body_ty1</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-comment'>-- see Note [Lazy and unleashable free variables]</span>
<a name="line-336"></a>    <span class='hs-keyword'>in</span>
<a name="line-337"></a>    <span class='hs-varid'>body_ty2</span> <span class='hs-varop'>`seq`</span>
<a name="line-338"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty2</span><span class='hs-layout'>,</span>  <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-339"></a>
<a name="line-340"></a><a name="io_hack_reqd"></a><span class='hs-definition'>io_hack_reqd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-341"></a><span class='hs-comment'>-- See Note [IO hack in the demand analyser]</span>
<a name="line-342"></a><span class='hs-definition'>io_hack_reqd</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs</span>
<a name="line-343"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs</span>
<a name="line-344"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>con</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tupleDataCon</span> <span class='hs-conid'>Unboxed</span> <span class='hs-num'>2</span>
<a name="line-345"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>realWorldStatePrimTy</span>
<a name="line-346"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectArgs</span> <span class='hs-varid'>scrut</span>
<a name="line-347"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fun</span> <span class='hs-keyword'>of</span>
<a name="line-348"></a>      <span class='hs-conid'>Var</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isPrimOpId</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-349"></a>      <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-350"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-351"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-352"></a>
<a name="line-353"></a><a name="dmdAnalAlt"></a><span class='hs-definition'>dmdAnalAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CleanDemand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span>
<a name="line-354"></a><span class='hs-definition'>dmdAnalAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>case_bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-355"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bndrs</span>    <span class='hs-comment'>-- Literals, DEFAULT, and nullary constructors</span>
<a name="line-356"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>rhs</span>
<a name="line-357"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-358"></a>
<a name="line-359"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-comment'>-- Non-nullary data constructors</span>
<a name="line-360"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>rhs</span>
<a name="line-361"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>findBndrsDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-362"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>case_bndr_dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findIdDemand</span> <span class='hs-varid'>alt_ty</span> <span class='hs-varid'>case_bndr</span>
<a name="line-363"></a>        <span class='hs-varid'>id_dmds</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addCaseBndrDmd</span> <span class='hs-varid'>case_bndr_dmd</span> <span class='hs-varid'>dmds</span>
<a name="line-364"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt_ty</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>id_dmds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-365"></a>
<a name="line-366"></a>
<a name="line-367"></a><span class='hs-comment'>{- Note [IO hack in the demand analyser]
<a name="line-368"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-369"></a>There's a hack here for I/O operations.  Consider
<a name="line-370"></a>
<a name="line-371"></a>     case foo x s of { (# s', r #) -&gt; y }
<a name="line-372"></a>
<a name="line-373"></a>Is this strict in 'y'? Often not! If foo x s performs some observable action
<a name="line-374"></a>(including raising an exception with raiseIO#, modifying a mutable variable, or
<a name="line-375"></a>even ending the program normally), then we must not force 'y' (which may fail
<a name="line-376"></a>to terminate) until we have performed foo x s.
<a name="line-377"></a>
<a name="line-378"></a>Hackish solution: spot the IO-like situation and add a virtual branch,
<a name="line-379"></a>as if we had
<a name="line-380"></a>     case foo x s of
<a name="line-381"></a>        (# s, r #) -&gt; y
<a name="line-382"></a>        other      -&gt; return ()
<a name="line-383"></a>So the 'y' isn't necessarily going to be evaluated
<a name="line-384"></a>
<a name="line-385"></a>A more complete example (Trac #148, #1592) where this shows up is:
<a name="line-386"></a>     do { let len = &lt;expensive&gt; ;
<a name="line-387"></a>        ; when (...) (exitWith ExitSuccess)
<a name="line-388"></a>        ; print len }
<a name="line-389"></a>
<a name="line-390"></a>However, consider
<a name="line-391"></a>  f x s = case getMaskingState# s of
<a name="line-392"></a>            (# s, r #) -&gt;
<a name="line-393"></a>          case x of I# x2 -&gt; ...
<a name="line-394"></a>
<a name="line-395"></a>Here it is terribly sad to make 'f' lazy in 's'.  After all,
<a name="line-396"></a>getMaskingState# is not going to diverge or throw an exception!  This
<a name="line-397"></a>situation actually arises in GHC.IO.Handle.Internals.wantReadableHandle
<a name="line-398"></a>(on an MVar not an Int), and made a material difference.
<a name="line-399"></a>
<a name="line-400"></a>So if the scrutinee is a primop call, we *don't* apply the
<a name="line-401"></a>state hack:
<a name="line-402"></a>  - If is a simple, terminating one like getMaskingState,
<a name="line-403"></a>    applying the hack is over-conservative.
<a name="line-404"></a>  - If the primop is raise# then it returns bottom, so
<a name="line-405"></a>    the case alternatives are already discarded.
<a name="line-406"></a>  - If the primop can raise a non-IO exception, like
<a name="line-407"></a>    divide by zero or seg-fault (eg writing an array
<a name="line-408"></a>    out of bounds) then we don't mind evaluating 'x' first.
<a name="line-409"></a>
<a name="line-410"></a>Note [Demand on the scrutinee of a product case]
<a name="line-411"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-412"></a>When figuring out the demand on the scrutinee of a product case,
<a name="line-413"></a>we use the demands of the case alternative, i.e. id_dmds.
<a name="line-414"></a>But note that these include the demand on the case binder;
<a name="line-415"></a>see Note [Demand on case-alternative binders] in Demand.hs.
<a name="line-416"></a>This is crucial. Example:
<a name="line-417"></a>   f x = case x of y { (a,b) -&gt; k y a }
<a name="line-418"></a>If we just take scrut_demand = U(L,A), then we won't pass x to the
<a name="line-419"></a>worker, so the worker will rebuild
<a name="line-420"></a>     x = (a, absent-error)
<a name="line-421"></a>and that'll crash.
<a name="line-422"></a>
<a name="line-423"></a>Note [Aggregated demand for cardinality]
<a name="line-424"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-425"></a>We use different strategies for strictness and usage/cardinality to
<a name="line-426"></a>"unleash" demands captured on free variables by bindings. Let us
<a name="line-427"></a>consider the example:
<a name="line-428"></a>
<a name="line-429"></a>f1 y = let {-# NOINLINE h #-}
<a name="line-430"></a>           h = y
<a name="line-431"></a>       in  (h, h)
<a name="line-432"></a>
<a name="line-433"></a>We are interested in obtaining cardinality demand U1 on |y|, as it is
<a name="line-434"></a>used only in a thunk, and, therefore, is not going to be updated any
<a name="line-435"></a>more. Therefore, the demand on |y|, captured and unleashed by usage of
<a name="line-436"></a>|h| is U1. However, if we unleash this demand every time |h| is used,
<a name="line-437"></a>and then sum up the effects, the ultimate demand on |y| will be U1 +
<a name="line-438"></a>U1 = U. In order to avoid it, we *first* collect the aggregate demand
<a name="line-439"></a>on |h| in the body of let-expression, and only then apply the demand
<a name="line-440"></a>transformer:
<a name="line-441"></a>
<a name="line-442"></a>transf[x](U) = {y |-&gt; U1}
<a name="line-443"></a>
<a name="line-444"></a>so the resulting demand on |y| is U1.
<a name="line-445"></a>
<a name="line-446"></a>The situation is, however, different for strictness, where this
<a name="line-447"></a>aggregating approach exhibits worse results because of the nature of
<a name="line-448"></a>|both| operation for strictness. Consider the example:
<a name="line-449"></a>
<a name="line-450"></a>f y c =
<a name="line-451"></a>  let h x = y |seq| x
<a name="line-452"></a>   in case of
<a name="line-453"></a>        True  -&gt; h True
<a name="line-454"></a>        False -&gt; y
<a name="line-455"></a>
<a name="line-456"></a>It is clear that |f| is strict in |y|, however, the suggested analysis
<a name="line-457"></a>will infer from the body of |let| that |h| is used lazily (as it is
<a name="line-458"></a>used in one branch only), therefore lazy demand will be put on its
<a name="line-459"></a>free variable |y|. Conversely, if the demand on |h| is unleashed right
<a name="line-460"></a>on the spot, we will get the desired result, namely, that |f| is
<a name="line-461"></a>strict in |y|.
<a name="line-462"></a>
<a name="line-463"></a>
<a name="line-464"></a>************************************************************************
<a name="line-465"></a>*                                                                      *
<a name="line-466"></a>                    Demand transformer
<a name="line-467"></a>*                                                                      *
<a name="line-468"></a>************************************************************************
<a name="line-469"></a>-}</span>
<a name="line-470"></a>
<a name="line-471"></a><a name="dmdTransform"></a><span class='hs-definition'>dmdTransform</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>         <span class='hs-comment'>-- The strictness environment</span>
<a name="line-472"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>              <span class='hs-comment'>-- The function</span>
<a name="line-473"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CleanDemand</span>     <span class='hs-comment'>-- The demand on the function</span>
<a name="line-474"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>         <span class='hs-comment'>-- The demand type of the function in this context</span>
<a name="line-475"></a>        <span class='hs-comment'>-- Returned DmdEnv includes the demand on</span>
<a name="line-476"></a>        <span class='hs-comment'>-- this function plus demand on its free variables</span>
<a name="line-477"></a>
<a name="line-478"></a><span class='hs-definition'>dmdTransform</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span>
<a name="line-479"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDataConWorkId</span> <span class='hs-varid'>var</span>                          <span class='hs-comment'>-- Data constructor</span>
<a name="line-480"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdTransformDataConSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idArity</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span>
<a name="line-481"></a>
<a name="line-482"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_DmdTxDictSel</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_dflags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-483"></a>    <span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isClassOpId_maybe</span> <span class='hs-varid'>var</span> <span class='hs-comment'>-- Dictionary component selector</span>
<a name="line-484"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdTransformDictSelSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span>
<a name="line-485"></a>
<a name="line-486"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGlobalId</span> <span class='hs-varid'>var</span>                               <span class='hs-comment'>-- Imported function</span>
<a name="line-487"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdTransformSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span> <span class='hs-keyword'>in</span>
<a name="line-488"></a><span class='hs-comment'>--    pprTrace "dmdTransform" (vcat [ppr var, ppr (idStrictness var), ppr dmd, ppr res])</span>
<a name="line-489"></a>    <span class='hs-varid'>res</span>
<a name="line-490"></a>
<a name="line-491"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>sig</span><span class='hs-layout'>,</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span>  <span class='hs-comment'>-- Local letrec bound thing</span>
<a name="line-492"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fn_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdTransformSig</span> <span class='hs-varid'>sig</span> <span class='hs-varid'>dmd</span>
<a name="line-493"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdTransform" (vcat [ppr var, ppr sig, ppr dmd, ppr fn_ty]) $</span>
<a name="line-494"></a>    <span class='hs-keyword'>if</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>
<a name="line-495"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>fn_ty</span>   <span class='hs-comment'>-- Don't record top level things</span>
<a name="line-496"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>addVarDmd</span> <span class='hs-varid'>fn_ty</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkOnceUsedDmd</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span>
<a name="line-497"></a>
<a name="line-498"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                    <span class='hs-comment'>-- Local non-letrec-bound thing</span>
<a name="line-499"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitVarEnv</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkOnceUsedDmd</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-500"></a>
<a name="line-501"></a><span class='hs-comment'>{-
<a name="line-502"></a>************************************************************************
<a name="line-503"></a>*                                                                      *
<a name="line-504"></a>\subsection{Bindings}
<a name="line-505"></a>*                                                                      *
<a name="line-506"></a>************************************************************************
<a name="line-507"></a>-}</span>
<a name="line-508"></a>
<a name="line-509"></a><a name="dmdFix"></a><span class='hs-comment'>-- Recursive bindings</span>
<a name="line-510"></a><span class='hs-definition'>dmdFix</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-511"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>                            <span class='hs-comment'>-- Does not include bindings for this binding</span>
<a name="line-512"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CleanDemand</span>
<a name="line-513"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-514"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Binders annotated with stricness info</span>
<a name="line-515"></a>
<a name="line-516"></a><span class='hs-definition'>dmdFix</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>let_dmd</span> <span class='hs-varid'>orig_pairs</span>
<a name="line-517"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span> <span class='hs-num'>1</span> <span class='hs-varid'>initial_pairs</span>
<a name="line-518"></a>  <span class='hs-keyword'>where</span>
<a name="line-519"></a>    <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>orig_pairs</span>
<a name="line-520"></a>
<a name="line-521"></a>    <span class='hs-comment'>-- See Note [Initialising strictness]</span>
<a name="line-522"></a>    <span class='hs-varid'>initial_pairs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>setIdStrictness</span> <span class='hs-varid'>id</span> <span class='hs-varid'>botSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>orig_pairs</span> <span class='hs-keyglyph'>]</span>
<a name="line-523"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orig_pairs</span>
<a name="line-524"></a>
<a name="line-525"></a>    <span class='hs-comment'>-- If fixed-point iteration does not yield a result we use this instead</span>
<a name="line-526"></a>    <span class='hs-comment'>-- See Note [Safe abortion in the fixed-point iteration]</span>
<a name="line-527"></a>    <span class='hs-varid'>abort</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-528"></a>    <span class='hs-varid'>abort</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv'</span><span class='hs-layout'>,</span> <span class='hs-varid'>zapped_pairs</span><span class='hs-layout'>)</span>
<a name="line-529"></a>      <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>step</span> <span class='hs-conid'>True</span> <span class='hs-layout'>(</span><span class='hs-varid'>zapIdStrictness</span> <span class='hs-varid'>orig_pairs</span><span class='hs-layout'>)</span>
<a name="line-530"></a>            <span class='hs-comment'>-- Note [Lazy and unleashable free variables]</span>
<a name="line-531"></a>            <span class='hs-varid'>non_lazy_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnvList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>strictSigDmdEnv</span> <span class='hs-varop'>.</span> <span class='hs-varid'>idStrictness</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs'</span>
<a name="line-532"></a>            <span class='hs-varid'>lazy_fv'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-varop'>`plusVarEnv`</span> <span class='hs-varid'>mapVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>non_lazy_fvs</span>
<a name="line-533"></a>            <span class='hs-varid'>zapped_pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapIdStrictness</span> <span class='hs-varid'>pairs'</span>
<a name="line-534"></a>
<a name="line-535"></a>    <span class='hs-comment'>-- The fixed-point varies the idStrictness field of the binders, and terminates if that</span>
<a name="line-536"></a>    <span class='hs-comment'>-- annotation does not change any more.</span>
<a name="line-537"></a>    <span class='hs-varid'>loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-538"></a>    <span class='hs-varid'>loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>pairs</span>
<a name="line-539"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>found_fixpoint</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_anal_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-540"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>10</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>abort</span>
<a name="line-541"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs'</span>
<a name="line-542"></a>      <span class='hs-keyword'>where</span>
<a name="line-543"></a>        <span class='hs-varid'>found_fixpoint</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs</span>
<a name="line-544"></a>        <span class='hs-varid'>first_round</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span>
<a name="line-545"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>step</span> <span class='hs-varid'>first_round</span> <span class='hs-varid'>pairs</span>
<a name="line-546"></a>        <span class='hs-varid'>final_anal_env</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-547"></a>
<a name="line-548"></a>    <span class='hs-varid'>step</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-549"></a>    <span class='hs-varid'>step</span> <span class='hs-varid'>first_round</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-550"></a>      <span class='hs-keyword'>where</span>
<a name="line-551"></a>        <span class='hs-comment'>-- In all but the first iteration, delete the virgin flag</span>
<a name="line-552"></a>        <span class='hs-varid'>start_env</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>first_round</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-553"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nonVirgin</span> <span class='hs-varid'>env</span>
<a name="line-554"></a>
<a name="line-555"></a>        <span class='hs-varid'>start</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendAnalEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>start_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyDmdEnv</span><span class='hs-layout'>)</span>
<a name="line-556"></a>
<a name="line-557"></a>        <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>my_downRhs</span> <span class='hs-varid'>start</span> <span class='hs-varid'>pairs</span>
<a name="line-558"></a>                <span class='hs-comment'>-- mapAccumL: Use the new signature to do the next pair</span>
<a name="line-559"></a>                <span class='hs-comment'>-- The occurrence analyser has arranged them in a good order</span>
<a name="line-560"></a>                <span class='hs-comment'>-- so this can significantly reduce the number of iterations needed</span>
<a name="line-561"></a>
<a name="line-562"></a>        <span class='hs-varid'>my_downRhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-563"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv'</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-564"></a>          <span class='hs-keyword'>where</span>
<a name="line-565"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv1</span><span class='hs-layout'>,</span> <span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalRhsLetDown</span> <span class='hs-varid'>top_lvl</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span> <span class='hs-varid'>let_dmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-566"></a>            <span class='hs-varid'>lazy_fv'</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv_C</span> <span class='hs-varid'>bothDmd</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-varid'>lazy_fv1</span>
<a name="line-567"></a>            <span class='hs-varid'>env'</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>id'</span><span class='hs-layout'>)</span>
<a name="line-568"></a>
<a name="line-569"></a>
<a name="line-570"></a>    <span class='hs-varid'>zapIdStrictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-571"></a>    <span class='hs-varid'>zapIdStrictness</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>setIdStrictness</span> <span class='hs-varid'>id</span> <span class='hs-varid'>nopSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>]</span>
<a name="line-572"></a>
<a name="line-573"></a><span class='hs-comment'>{-
<a name="line-574"></a>Note [Safe abortion in the fixed-point iteration]
<a name="line-575"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-576"></a>
<a name="line-577"></a>Fixed-point iteration may fail to terminate. But we cannot simply give up and
<a name="line-578"></a>return the environment and code unchanged! We still need to do one additional
<a name="line-579"></a>round, for two reasons:
<a name="line-580"></a>
<a name="line-581"></a> * To get information on used free variables (both lazy and strict!)
<a name="line-582"></a>   (see Note [Lazy and unleashable free variables])
<a name="line-583"></a> * To ensure that all expressions have been traversed at least once, and any left-over
<a name="line-584"></a>   strictness annotations have been updated.
<a name="line-585"></a>
<a name="line-586"></a>This final iteration does not add the variables to the strictness signature
<a name="line-587"></a>environment, which effectively assigns them 'nopSig' (see "getStrictness")
<a name="line-588"></a>
<a name="line-589"></a>-}</span>
<a name="line-590"></a>
<a name="line-591"></a><a name="dmdAnalTrivialRhs"></a><span class='hs-comment'>-- Trivial RHS</span>
<a name="line-592"></a><span class='hs-comment'>-- See Note [Demand analysis for trivial right-hand sides]</span>
<a name="line-593"></a><span class='hs-definition'>dmdAnalTrivialRhs</span> <span class='hs-keyglyph'>::</span>
<a name="line-594"></a>    <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-595"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-596"></a><span class='hs-definition'>dmdAnalTrivialRhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>fn</span>
<a name="line-597"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>set_idStrictness</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>fn_str</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-598"></a>  <span class='hs-keyword'>where</span>
<a name="line-599"></a>    <span class='hs-varid'>fn_str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getStrictness</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span>
<a name="line-600"></a>    <span class='hs-varid'>fn_fv</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isLocalId</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarEnv</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>topDmd</span>
<a name="line-601"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyDmdEnv</span>
<a name="line-602"></a>    <span class='hs-comment'>-- Note [Remember to demand the function itself]</span>
<a name="line-603"></a>    <span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-604"></a>    <span class='hs-comment'>-- fn_fv: don't forget to produce a demand for fn itself</span>
<a name="line-605"></a>    <span class='hs-comment'>-- Lacking this caused Trac #9128</span>
<a name="line-606"></a>    <span class='hs-comment'>-- The demand is very conservative (topDmd), but that doesn't</span>
<a name="line-607"></a>    <span class='hs-comment'>-- matter; trivial bindings are usually inlined, so it only</span>
<a name="line-608"></a>    <span class='hs-comment'>-- kicks in for top-level bindings and NOINLINE bindings</span>
<a name="line-609"></a>
<a name="line-610"></a><a name="dmdAnalRhsLetDown"></a><span class='hs-comment'>-- Let bindings can be processed in two ways:</span>
<a name="line-611"></a><span class='hs-comment'>-- Down (RHS before body) or Up (body before RHS).</span>
<a name="line-612"></a><span class='hs-comment'>-- dmdAnalRhsLetDown implements the Down variant:</span>
<a name="line-613"></a><span class='hs-comment'>--  * assuming a demand of &lt;L,U&gt;</span>
<a name="line-614"></a><span class='hs-comment'>--  * looking at the definition</span>
<a name="line-615"></a><span class='hs-comment'>--  * determining a strictness signature</span>
<a name="line-616"></a><span class='hs-comment'>--</span>
<a name="line-617"></a><span class='hs-comment'>-- It is used for toplevel definition, recursive definitions and local</span>
<a name="line-618"></a><span class='hs-comment'>-- non-recursive definitions that have manifest lambdas.</span>
<a name="line-619"></a><span class='hs-comment'>-- Local non-recursive definitions without a lambda are handled with LetUp.</span>
<a name="line-620"></a><span class='hs-comment'>--</span>
<a name="line-621"></a><span class='hs-comment'>-- This is the LetDown rule in the paper “Higher-Order Cardinality Analysis”.</span>
<a name="line-622"></a><span class='hs-definition'>dmdAnalRhsLetDown</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-623"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Just bs &lt;=&gt; recursive, Nothing &lt;=&gt; non-recursive</span>
<a name="line-624"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CleanDemand</span>
<a name="line-625"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-626"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-627"></a><span class='hs-comment'>-- Process the RHS of the binding, add the strictness signature</span>
<a name="line-628"></a><span class='hs-comment'>-- to the Id, and augment the environment with the signature as well.</span>
<a name="line-629"></a><span class='hs-definition'>dmdAnalRhsLetDown</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>rec_flag</span> <span class='hs-varid'>env</span> <span class='hs-varid'>let_dmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-630"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unpackTrivial</span> <span class='hs-varid'>rhs</span>   <span class='hs-comment'>-- See Note [Demand analysis for trivial right-hand sides]</span>
<a name="line-631"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalTrivialRhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>fn</span>
<a name="line-632"></a>
<a name="line-633"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-634"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-635"></a>  <span class='hs-keyword'>where</span>
<a name="line-636"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_dmd</span><span class='hs-layout'>)</span>
<a name="line-637"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>id</span> <span class='hs-keyword'>of</span>
<a name="line-638"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span>  <span class='hs-comment'>-- See Note [Demand analysis for join points]</span>
<a name="line-639"></a>                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectNBinders</span> <span class='hs-varid'>join_arity</span> <span class='hs-varid'>rhs</span>
<a name="line-640"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-varid'>let_dmd</span><span class='hs-layout'>)</span>
<a name="line-641"></a>
<a name="line-642"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>rhs</span>
<a name="line-643"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkBodyDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-644"></a>
<a name="line-645"></a>    <span class='hs-varid'>env_body</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>extendSigsWithLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-646"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env_body</span> <span class='hs-varid'>body_dmd</span> <span class='hs-varid'>body</span>
<a name="line-647"></a>    <span class='hs-varid'>body_ty'</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>removeDmdTyArgs</span> <span class='hs-varid'>body_ty</span> <span class='hs-comment'>-- zap possible deep CPR info</span>
<a name="line-648"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span> <span class='hs-varid'>rhs_fv</span> <span class='hs-varid'>rhs_dmds</span> <span class='hs-varid'>rhs_res</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span>
<a name="line-649"></a>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>annotateLamBndrs</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDFunId</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varid'>body_ty'</span> <span class='hs-varid'>bndrs</span>
<a name="line-650"></a>    <span class='hs-varid'>sig_ty</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkStrictSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkDmdType</span> <span class='hs-varid'>sig_fv</span> <span class='hs-varid'>rhs_dmds</span> <span class='hs-varid'>rhs_res'</span><span class='hs-layout'>)</span>
<a name="line-651"></a>    <span class='hs-varid'>id'</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>set_idStrictness</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig_ty</span>
<a name="line-652"></a>        <span class='hs-comment'>-- See Note [NOINLINE and strictness]</span>
<a name="line-653"></a>
<a name="line-654"></a>
<a name="line-655"></a>    <span class='hs-comment'>-- See Note [Aggregated demand for cardinality]</span>
<a name="line-656"></a>    <span class='hs-varid'>rhs_fv1</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rec_flag</span> <span class='hs-keyword'>of</span>
<a name="line-657"></a>                <span class='hs-conid'>Just</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>reuseEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>delVarEnvList</span> <span class='hs-varid'>rhs_fv</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-658"></a>                <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rhs_fv</span>
<a name="line-659"></a>
<a name="line-660"></a>    <span class='hs-comment'>-- See Note [Lazy and unleashable free variables]</span>
<a name="line-661"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>sig_fv</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitFVs</span> <span class='hs-varid'>is_thunk</span> <span class='hs-varid'>rhs_fv1</span>
<a name="line-662"></a>
<a name="line-663"></a>    <span class='hs-varid'>rhs_res'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trimCPRInfo</span> <span class='hs-varid'>trim_all</span> <span class='hs-varid'>trim_sums</span> <span class='hs-varid'>rhs_res</span>
<a name="line-664"></a>    <span class='hs-varid'>trim_all</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_thunk</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not_strict</span>
<a name="line-665"></a>    <span class='hs-varid'>trim_sums</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [CPR for sum types]</span>
<a name="line-666"></a>
<a name="line-667"></a>    <span class='hs-comment'>-- See Note [CPR for thunks]</span>
<a name="line-668"></a>    <span class='hs-varid'>is_thunk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprIsHNF</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-669"></a>    <span class='hs-varid'>not_strict</span>
<a name="line-670"></a>       <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>  <span class='hs-comment'>-- Top level and recursive things don't</span>
<a name="line-671"></a>       <span class='hs-varop'>||</span> <span class='hs-varid'>isJust</span> <span class='hs-varid'>rec_flag</span>     <span class='hs-comment'>-- get their demandInfo set at all</span>
<a name="line-672"></a>       <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isStrictDmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-673"></a>          <span class='hs-comment'>-- See Note [Optimistic CPR in the "virgin" case]</span>
<a name="line-674"></a>
<a name="line-675"></a><a name="mkBodyDmd"></a><span class='hs-definition'>mkBodyDmd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CleanDemand</span>
<a name="line-676"></a><span class='hs-comment'>-- See Note [Product demands for function body]</span>
<a name="line-677"></a><span class='hs-definition'>mkBodyDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span>
<a name="line-678"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>deepSplitProductType_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-679"></a>       <span class='hs-conid'>Nothing</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cleanEvalDmd</span>
<a name="line-680"></a>       <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cleanEvalProdDmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-681"></a>
<a name="line-682"></a><a name="unpackTrivial"></a><span class='hs-definition'>unpackTrivial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Id</span>
<a name="line-683"></a><span class='hs-comment'>-- Returns (Just v) if the arg is really equal to v, modulo</span>
<a name="line-684"></a><span class='hs-comment'>-- casts, type applications etc</span>
<a name="line-685"></a><span class='hs-comment'>-- See Note [Demand analysis for trivial right-hand sides]</span>
<a name="line-686"></a><span class='hs-definition'>unpackTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>v</span>
<a name="line-687"></a><span class='hs-definition'>unpackTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackTrivial</span> <span class='hs-varid'>e</span>
<a name="line-688"></a><span class='hs-definition'>unpackTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>v</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackTrivial</span> <span class='hs-varid'>e</span>
<a name="line-689"></a><span class='hs-definition'>unpackTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeArg</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackTrivial</span> <span class='hs-varid'>e</span>
<a name="line-690"></a><span class='hs-definition'>unpackTrivial</span> <span class='hs-keyword'>_</span>                       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-691"></a>
<a name="line-692"></a><a name="useLetUp"></a><span class='hs-comment'>-- | If given the RHS of a let-binding, this 'useLetUp' determines</span>
<a name="line-693"></a><span class='hs-comment'>-- whether we should process the binding up (body before rhs) or</span>
<a name="line-694"></a><span class='hs-comment'>-- down (rhs before body).</span>
<a name="line-695"></a><span class='hs-comment'>--</span>
<a name="line-696"></a><span class='hs-comment'>-- We use LetDown if there is a chance to get a useful strictness signature.</span>
<a name="line-697"></a><span class='hs-comment'>-- This is the case when there are manifest value lambdas or the binding is a</span>
<a name="line-698"></a><span class='hs-comment'>-- join point (hence always acts like a function, not a value).</span>
<a name="line-699"></a><span class='hs-definition'>useLetUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-700"></a><span class='hs-definition'>useLetUp</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-701"></a><span class='hs-definition'>useLetUp</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>v</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>useLetUp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span>
<a name="line-702"></a><span class='hs-definition'>useLetUp</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-703"></a><span class='hs-definition'>useLetUp</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-704"></a>
<a name="line-705"></a>
<a name="line-706"></a><span class='hs-comment'>{- Note [Demand analysis for join points]
<a name="line-707"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-708"></a>Consider
<a name="line-709"></a>   g :: (Int,Int) -&gt; Int
<a name="line-710"></a>   g (p,q) = p+q
<a name="line-711"></a>
<a name="line-712"></a>   f :: T -&gt; Int -&gt; Int
<a name="line-713"></a>   f x p = g (join j y = (p,y)
<a name="line-714"></a>              in case x of
<a name="line-715"></a>                   A -&gt; j 3
<a name="line-716"></a>                   B -&gt; j 4
<a name="line-717"></a>                   C -&gt; (p,7))
<a name="line-718"></a>
<a name="line-719"></a>If j was a vanilla function definition, we'd analyse its body with
<a name="line-720"></a>evalDmd, and think that it was lazy in p.  But for join points we can
<a name="line-721"></a>do better!  We know that j's body will (if called at all) be evaluated
<a name="line-722"></a>with the demand that consumes the entire join-binding, in this case
<a name="line-723"></a>the argument demand from g.  Whizzo!  g evaluates both components of
<a name="line-724"></a>its argument pair, so p will certainly be evaluated if j is called.
<a name="line-725"></a>
<a name="line-726"></a>For f to be strict in p, we need /all/ paths to evaluate p; in this
<a name="line-727"></a>case the C branch does so too, so we are fine.  So, as usual, we need
<a name="line-728"></a>to transport demands on free variables to the call site(s).  Compare
<a name="line-729"></a>Note [Lazy and unleashable free variables].
<a name="line-730"></a>
<a name="line-731"></a>The implementation is easy.  When analysing a join point, we can
<a name="line-732"></a>analyse its body with the demand from the entire join-binding (written
<a name="line-733"></a>let_dmd here).
<a name="line-734"></a>
<a name="line-735"></a>Another win for join points!  Trac #13543.
<a name="line-736"></a>
<a name="line-737"></a>Note [Demand analysis for trivial right-hand sides]
<a name="line-738"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-739"></a>Consider
<a name="line-740"></a>        foo = plusInt |&gt; co
<a name="line-741"></a>where plusInt is an arity-2 function with known strictness.  Clearly
<a name="line-742"></a>we want plusInt's strictness to propagate to foo!  But because it has
<a name="line-743"></a>no manifest lambdas, it won't do so automatically, and indeed 'co' might
<a name="line-744"></a>have type (Int-&gt;Int-&gt;Int) ~ T, so we *can't* eta-expand.  So we have a
<a name="line-745"></a>special case for right-hand sides that are "trivial", namely variables,
<a name="line-746"></a>casts, type applications, and the like.
<a name="line-747"></a>
<a name="line-748"></a>Note that this can mean that 'foo' has an arity that is smaller than that
<a name="line-749"></a>indicated by its demand info.  e.g. if co :: (Int-&gt;Int-&gt;Int) ~ T, then
<a name="line-750"></a>foo's arity will be zero (see Note [exprArity invariant] in CoreArity),
<a name="line-751"></a>but its demand signature will be that of plusInt. A small example is the
<a name="line-752"></a>test case of Trac #8963.
<a name="line-753"></a>
<a name="line-754"></a>
<a name="line-755"></a>Note [Product demands for function body]
<a name="line-756"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-757"></a>This example comes from shootout/binary_trees:
<a name="line-758"></a>
<a name="line-759"></a>    Main.check' = \ b z ds. case z of z' { I# ip -&gt;
<a name="line-760"></a>                                case ds_d13s of
<a name="line-761"></a>                                  Main.Nil -&gt; z'
<a name="line-762"></a>                                  Main.Node s14k s14l s14m -&gt;
<a name="line-763"></a>                                    Main.check' (not b)
<a name="line-764"></a>                                      (Main.check' b
<a name="line-765"></a>                                         (case b {
<a name="line-766"></a>                                            False -&gt; I# (-# s14h s14k);
<a name="line-767"></a>                                            True  -&gt; I# (+# s14h s14k)
<a name="line-768"></a>                                          })
<a name="line-769"></a>                                         s14l)
<a name="line-770"></a>                                     s14m   }   }   }
<a name="line-771"></a>
<a name="line-772"></a>Here we *really* want to unbox z, even though it appears to be used boxed in
<a name="line-773"></a>the Nil case.  Partly the Nil case is not a hot path.  But more specifically,
<a name="line-774"></a>the whole function gets the CPR property if we do.
<a name="line-775"></a>
<a name="line-776"></a>So for the demand on the body of a RHS we use a product demand if it's
<a name="line-777"></a>a product type.
<a name="line-778"></a>
<a name="line-779"></a>************************************************************************
<a name="line-780"></a>*                                                                      *
<a name="line-781"></a>\subsection{Strictness signatures and types}
<a name="line-782"></a>*                                                                      *
<a name="line-783"></a>************************************************************************
<a name="line-784"></a>-}</span>
<a name="line-785"></a>
<a name="line-786"></a><a name="unitDmdType"></a><span class='hs-definition'>unitDmdType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-787"></a><span class='hs-definition'>unitDmdType</span> <span class='hs-varid'>dmd_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DmdType</span> <span class='hs-varid'>dmd_env</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>topRes</span>
<a name="line-788"></a>
<a name="line-789"></a><a name="coercionDmdEnv"></a><span class='hs-definition'>coercionDmdEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdEnv</span>
<a name="line-790"></a><span class='hs-definition'>coercionDmdEnv</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUniqSet</span> <span class='hs-varop'>$</span> <span class='hs-varid'>coVarsOfCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-791"></a>                    <span class='hs-comment'>-- The VarSet from coVarsOfCo is really a VarEnv Var</span>
<a name="line-792"></a>
<a name="line-793"></a><a name="addVarDmd"></a><span class='hs-definition'>addVarDmd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-794"></a><span class='hs-definition'>addVarDmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span> <span class='hs-varid'>fv</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span>
<a name="line-795"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendVarEnv_C</span> <span class='hs-varid'>bothDmd</span> <span class='hs-varid'>fv</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>res</span>
<a name="line-796"></a>
<a name="line-797"></a><a name="addLazyFVs"></a><span class='hs-definition'>addLazyFVs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-798"></a><span class='hs-definition'>addLazyFVs</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>lazy_fvs</span>
<a name="line-799"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varop'>`bothDmdType`</span> <span class='hs-varid'>mkBothDmdArg</span> <span class='hs-varid'>lazy_fvs</span>
<a name="line-800"></a>        <span class='hs-comment'>-- Using bothDmdType (rather than just both'ing the envs)</span>
<a name="line-801"></a>        <span class='hs-comment'>-- is vital.  Consider</span>
<a name="line-802"></a>        <span class='hs-comment'>--      let f = \x -&gt; (x,y)</span>
<a name="line-803"></a>        <span class='hs-comment'>--      in  error (f 3)</span>
<a name="line-804"></a>        <span class='hs-comment'>-- Here, y is treated as a lazy-fv of f, but we must `bothDmd` that L</span>
<a name="line-805"></a>        <span class='hs-comment'>-- demand with the bottom coming up from 'error'</span>
<a name="line-806"></a>        <span class='hs-comment'>--</span>
<a name="line-807"></a>        <span class='hs-comment'>-- I got a loop in the fixpointer without this, due to an interaction</span>
<a name="line-808"></a>        <span class='hs-comment'>-- with the lazy_fv filtering in dmdAnalRhsLetDown.  Roughly, it was</span>
<a name="line-809"></a>        <span class='hs-comment'>--      letrec f n x</span>
<a name="line-810"></a>        <span class='hs-comment'>--          = letrec g y = x `fatbar`</span>
<a name="line-811"></a>        <span class='hs-comment'>--                         letrec h z = z + ...g...</span>
<a name="line-812"></a>        <span class='hs-comment'>--                         in h (f (n-1) x)</span>
<a name="line-813"></a>        <span class='hs-comment'>--      in ...</span>
<a name="line-814"></a>        <span class='hs-comment'>-- In the initial iteration for f, f=Bot</span>
<a name="line-815"></a>        <span class='hs-comment'>-- Suppose h is found to be strict in z, but the occurrence of g in its RHS</span>
<a name="line-816"></a>        <span class='hs-comment'>-- is lazy.  Now consider the fixpoint iteration for g, esp the demands it</span>
<a name="line-817"></a>        <span class='hs-comment'>-- places on its free variables.  Suppose it places none.  Then the</span>
<a name="line-818"></a>        <span class='hs-comment'>--      x `fatbar` ...call to h...</span>
<a name="line-819"></a>        <span class='hs-comment'>-- will give a x-&gt;V demand for x.  That turns into a L demand for x,</span>
<a name="line-820"></a>        <span class='hs-comment'>-- which floats out of the defn for h.  Without the modifyEnv, that</span>
<a name="line-821"></a>        <span class='hs-comment'>-- L demand doesn't get both'd with the Bot coming up from the inner</span>
<a name="line-822"></a>        <span class='hs-comment'>-- call to f.  So we just get an L demand for x for g.</span>
<a name="line-823"></a>
<a name="line-824"></a><span class='hs-comment'>{-
<a name="line-825"></a>Note [Do not strictify the argument dictionaries of a dfun]
<a name="line-826"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-827"></a>The typechecker can tie recursive knots involving dfuns, so we do the
<a name="line-828"></a>conservative thing and refrain from strictifying a dfun's argument
<a name="line-829"></a>dictionaries.
<a name="line-830"></a>-}</span>
<a name="line-831"></a>
<a name="line-832"></a><a name="setBndrsDemandInfo"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>
<a name="line-833"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>d</span><span class='hs-conop'>:</span><span class='hs-varid'>ds</span><span class='hs-layout'>)</span>
<a name="line-834"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-varid'>d</span><span class='hs-conop'>:</span><span class='hs-varid'>ds</span><span class='hs-layout'>)</span>
<a name="line-835"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>b</span> <span class='hs-varid'>d</span> <span class='hs-conop'>:</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>ds</span>
<a name="line-836"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>ds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>ds</span> <span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-837"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-varid'>bs</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"setBndrsDemandInfo"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-838"></a>
<a name="line-839"></a><a name="annotateBndr"></a><span class='hs-definition'>annotateBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span>
<a name="line-840"></a><span class='hs-comment'>-- The returned env has the var deleted</span>
<a name="line-841"></a><span class='hs-comment'>-- The returned var is annotated with demand info</span>
<a name="line-842"></a><span class='hs-comment'>-- according to the result demand of the provided demand type</span>
<a name="line-843"></a><span class='hs-comment'>-- No effect on the argument demands</span>
<a name="line-844"></a><span class='hs-definition'>annotateBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>var</span>
<a name="line-845"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>var</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span>
<a name="line-846"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-847"></a>  <span class='hs-keyword'>where</span>
<a name="line-848"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-conid'>False</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>var</span>
<a name="line-849"></a>
<a name="line-850"></a><a name="annotateLamBndrs"></a><span class='hs-definition'>annotateLamBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DFunFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-851"></a><span class='hs-definition'>annotateLamBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args_of_dfun</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumR</span> <span class='hs-varid'>annotate</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-852"></a>  <span class='hs-keyword'>where</span>
<a name="line-853"></a>    <span class='hs-varid'>annotate</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bndr</span>
<a name="line-854"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>annotateLamIdBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args_of_dfun</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bndr</span>
<a name="line-855"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-856"></a>
<a name="line-857"></a><a name="annotateLamIdBndr"></a><span class='hs-definition'>annotateLamIdBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-858"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DFunFlag</span>   <span class='hs-comment'>-- is this lambda at the top of the RHS of a dfun?</span>
<a name="line-859"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>    <span class='hs-comment'>-- Demand type of body</span>
<a name="line-860"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>         <span class='hs-comment'>-- Lambda binder</span>
<a name="line-861"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- Demand type of lambda</span>
<a name="line-862"></a>                      <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- and binder annotated with demand</span>
<a name="line-863"></a>
<a name="line-864"></a><span class='hs-definition'>annotateLamIdBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-865"></a><span class='hs-comment'>-- For lambdas we add the demand to the argument demands</span>
<a name="line-866"></a><span class='hs-comment'>-- Only called for Ids</span>
<a name="line-867"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>id</span> <span class='hs-layout'>)</span>
<a name="line-868"></a>    <span class='hs-comment'>-- pprTrace "annLamBndr" (vcat [ppr id, ppr _dmd_ty]) $</span>
<a name="line-869"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>id</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span>
<a name="line-870"></a>  <span class='hs-keyword'>where</span>
<a name="line-871"></a>      <span class='hs-comment'>-- Watch out!  See note [Lambda-bound unfoldings]</span>
<a name="line-872"></a>    <span class='hs-varid'>final_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>maybeUnfoldingTemplate</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-873"></a>                 <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>main_ty</span>
<a name="line-874"></a>                 <span class='hs-conid'>Just</span> <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>main_ty</span> <span class='hs-varop'>`bothDmdType`</span> <span class='hs-varid'>unf_ty</span>
<a name="line-875"></a>                          <span class='hs-keyword'>where</span>
<a name="line-876"></a>                             <span class='hs-layout'>(</span><span class='hs-varid'>unf_ty</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>unf</span>
<a name="line-877"></a>
<a name="line-878"></a>    <span class='hs-varid'>main_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addDemand</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>dmd_ty'</span>
<a name="line-879"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-880"></a>
<a name="line-881"></a><a name="deleteFVs"></a><span class='hs-definition'>deleteFVs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-882"></a><span class='hs-definition'>deleteFVs</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span> <span class='hs-varid'>fvs</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-883"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>delVarEnvList</span> <span class='hs-varid'>fvs</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>res</span>
<a name="line-884"></a>
<a name="line-885"></a><span class='hs-comment'>{-
<a name="line-886"></a>Note [CPR for sum types]
<a name="line-887"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-888"></a>At the moment we do not do CPR for let-bindings that
<a name="line-889"></a>   * non-top level
<a name="line-890"></a>   * bind a sum type
<a name="line-891"></a>Reason: I found that in some benchmarks we were losing let-no-escapes,
<a name="line-892"></a>which messed it all up.  Example
<a name="line-893"></a>   let j = \x. ....
<a name="line-894"></a>   in case y of
<a name="line-895"></a>        True  -&gt; j False
<a name="line-896"></a>        False -&gt; j True
<a name="line-897"></a>If we w/w this we get
<a name="line-898"></a>   let j' = \x. ....
<a name="line-899"></a>   in case y of
<a name="line-900"></a>        True  -&gt; case j' False of { (# a #) -&gt; Just a }
<a name="line-901"></a>        False -&gt; case j' True of { (# a #) -&gt; Just a }
<a name="line-902"></a>Notice that j' is not a let-no-escape any more.
<a name="line-903"></a>
<a name="line-904"></a>However this means in turn that the *enclosing* function
<a name="line-905"></a>may be CPR'd (via the returned Justs).  But in the case of
<a name="line-906"></a>sums, there may be Nothing alternatives; and that messes
<a name="line-907"></a>up the sum-type CPR.
<a name="line-908"></a>
<a name="line-909"></a>Conclusion: only do this for products.  It's still not
<a name="line-910"></a>guaranteed OK for products, but sums definitely lose sometimes.
<a name="line-911"></a>
<a name="line-912"></a>Note [CPR for thunks]
<a name="line-913"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-914"></a>If the rhs is a thunk, we usually forget the CPR info, because
<a name="line-915"></a>it is presumably shared (else it would have been inlined, and
<a name="line-916"></a>so we'd lose sharing if w/w'd it into a function).  E.g.
<a name="line-917"></a>
<a name="line-918"></a>        let r = case expensive of
<a name="line-919"></a>                  (a,b) -&gt; (b,a)
<a name="line-920"></a>        in ...
<a name="line-921"></a>
<a name="line-922"></a>If we marked r as having the CPR property, then we'd w/w into
<a name="line-923"></a>
<a name="line-924"></a>        let $wr = \() -&gt; case expensive of
<a name="line-925"></a>                            (a,b) -&gt; (# b, a #)
<a name="line-926"></a>            r = case $wr () of
<a name="line-927"></a>                  (# b,a #) -&gt; (b,a)
<a name="line-928"></a>        in ...
<a name="line-929"></a>
<a name="line-930"></a>But now r is a thunk, which won't be inlined, so we are no further ahead.
<a name="line-931"></a>But consider
<a name="line-932"></a>
<a name="line-933"></a>        f x = let r = case expensive of (a,b) -&gt; (b,a)
<a name="line-934"></a>              in if foo r then r else (x,x)
<a name="line-935"></a>
<a name="line-936"></a>Does f have the CPR property?  Well, no.
<a name="line-937"></a>
<a name="line-938"></a>However, if the strictness analyser has figured out (in a previous
<a name="line-939"></a>iteration) that it's strict, then we DON'T need to forget the CPR info.
<a name="line-940"></a>Instead we can retain the CPR info and do the thunk-splitting transform
<a name="line-941"></a>(see WorkWrap.splitThunk).
<a name="line-942"></a>
<a name="line-943"></a>This made a big difference to PrelBase.modInt, which had something like
<a name="line-944"></a>        modInt = \ x -&gt; let r = ... -&gt; I# v in
<a name="line-945"></a>                        ...body strict in r...
<a name="line-946"></a>r's RHS isn't a value yet; but modInt returns r in various branches, so
<a name="line-947"></a>if r doesn't have the CPR property then neither does modInt
<a name="line-948"></a>Another case I found in practice (in Complex.magnitude), looks like this:
<a name="line-949"></a>                let k = if ... then I# a else I# b
<a name="line-950"></a>                in ... body strict in k ....
<a name="line-951"></a>(For this example, it doesn't matter whether k is returned as part of
<a name="line-952"></a>the overall result; but it does matter that k's RHS has the CPR property.)
<a name="line-953"></a>Left to itself, the simplifier will make a join point thus:
<a name="line-954"></a>                let $j k = ...body strict in k...
<a name="line-955"></a>                if ... then $j (I# a) else $j (I# b)
<a name="line-956"></a>With thunk-splitting, we get instead
<a name="line-957"></a>                let $j x = let k = I#x in ...body strict in k...
<a name="line-958"></a>                in if ... then $j a else $j b
<a name="line-959"></a>This is much better; there's a good chance the I# won't get allocated.
<a name="line-960"></a>
<a name="line-961"></a>The difficulty with this is that we need the strictness type to
<a name="line-962"></a>look at the body... but we now need the body to calculate the demand
<a name="line-963"></a>on the variable, so we can decide whether its strictness type should
<a name="line-964"></a>have a CPR in it or not.  Simple solution:
<a name="line-965"></a>        a) use strictness info from the previous iteration
<a name="line-966"></a>        b) make sure we do at least 2 iterations, by doing a second
<a name="line-967"></a>           round for top-level non-recs.  Top level recs will get at
<a name="line-968"></a>           least 2 iterations except for totally-bottom functions
<a name="line-969"></a>           which aren't very interesting anyway.
<a name="line-970"></a>
<a name="line-971"></a>NB: strictly_demanded is never true of a top-level Id, or of a recursive Id.
<a name="line-972"></a>
<a name="line-973"></a>Note [Optimistic CPR in the "virgin" case]
<a name="line-974"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-975"></a>Demand and strictness info are initialized by top elements. However,
<a name="line-976"></a>this prevents from inferring a CPR property in the first pass of the
<a name="line-977"></a>analyser, so we keep an explicit flag ae_virgin in the AnalEnv
<a name="line-978"></a>datatype.
<a name="line-979"></a>
<a name="line-980"></a>We can't start with 'not-demanded' (i.e., top) because then consider
<a name="line-981"></a>        f x = let
<a name="line-982"></a>                  t = ... I# x
<a name="line-983"></a>              in
<a name="line-984"></a>              if ... then t else I# y else f x'
<a name="line-985"></a>
<a name="line-986"></a>In the first iteration we'd have no demand info for x, so assume
<a name="line-987"></a>not-demanded; then we'd get TopRes for f's CPR info.  Next iteration
<a name="line-988"></a>we'd see that t was demanded, and so give it the CPR property, but by
<a name="line-989"></a>now f has TopRes, so it will stay TopRes.  Instead, by checking the
<a name="line-990"></a>ae_virgin flag at the first time round, we say 'yes t is demanded' the
<a name="line-991"></a>first time.
<a name="line-992"></a>
<a name="line-993"></a>However, this does mean that for non-recursive bindings we must
<a name="line-994"></a>iterate twice to be sure of not getting over-optimistic CPR info,
<a name="line-995"></a>in the case where t turns out to be not-demanded.  This is handled
<a name="line-996"></a>by dmdAnalTopBind.
<a name="line-997"></a>
<a name="line-998"></a>
<a name="line-999"></a>Note [NOINLINE and strictness]
<a name="line-1000"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1001"></a>The strictness analyser used to have a HACK which ensured that NOINLNE
<a name="line-1002"></a>things were not strictness-analysed.  The reason was unsafePerformIO.
<a name="line-1003"></a>Left to itself, the strictness analyser would discover this strictness
<a name="line-1004"></a>for unsafePerformIO:
<a name="line-1005"></a>        unsafePerformIO:  C(U(AV))
<a name="line-1006"></a>But then consider this sub-expression
<a name="line-1007"></a>        unsafePerformIO (\s -&gt; let r = f x in
<a name="line-1008"></a>                               case writeIORef v r s of (# s1, _ #) -&gt;
<a name="line-1009"></a>                               (# s1, r #)
<a name="line-1010"></a>The strictness analyser will now find that r is sure to be eval'd,
<a name="line-1011"></a>and may then hoist it out.  This makes tests/lib/should_run/memo002
<a name="line-1012"></a>deadlock.
<a name="line-1013"></a>
<a name="line-1014"></a>Solving this by making all NOINLINE things have no strictness info is overkill.
<a name="line-1015"></a>In particular, it's overkill for runST, which is perfectly respectable.
<a name="line-1016"></a>Consider
<a name="line-1017"></a>        f x = runST (return x)
<a name="line-1018"></a>This should be strict in x.
<a name="line-1019"></a>
<a name="line-1020"></a>So the new plan is to define unsafePerformIO using the 'lazy' combinator:
<a name="line-1021"></a>
<a name="line-1022"></a>        unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -&gt; r)
<a name="line-1023"></a>
<a name="line-1024"></a>Remember, 'lazy' is a wired-in identity-function Id, of type a-&gt;a, which is
<a name="line-1025"></a>magically NON-STRICT, and is inlined after strictness analysis.  So
<a name="line-1026"></a>unsafePerformIO will look non-strict, and that's what we want.
<a name="line-1027"></a>
<a name="line-1028"></a>Now we don't need the hack in the strictness analyser.  HOWEVER, this
<a name="line-1029"></a>decision does mean that even a NOINLINE function is not entirely
<a name="line-1030"></a>opaque: some aspect of its implementation leaks out, notably its
<a name="line-1031"></a>strictness.  For example, if you have a function implemented by an
<a name="line-1032"></a>error stub, but which has RULES, you may want it not to be eliminated
<a name="line-1033"></a>in favour of error!
<a name="line-1034"></a>
<a name="line-1035"></a>Note [Lazy and unleashable free variables]
<a name="line-1036"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1037"></a>We put the strict and once-used FVs in the DmdType of the Id, so
<a name="line-1038"></a>that at its call sites we unleash demands on its strict fvs.
<a name="line-1039"></a>An example is 'roll' in imaginary/wheel-sieve2
<a name="line-1040"></a>Something like this:
<a name="line-1041"></a>        roll x = letrec
<a name="line-1042"></a>                     go y = if ... then roll (x-1) else x+1
<a name="line-1043"></a>                 in
<a name="line-1044"></a>                 go ms
<a name="line-1045"></a>We want to see that roll is strict in x, which is because
<a name="line-1046"></a>go is called.   So we put the DmdEnv for x in go's DmdType.
<a name="line-1047"></a>
<a name="line-1048"></a>Another example:
<a name="line-1049"></a>
<a name="line-1050"></a>        f :: Int -&gt; Int -&gt; Int
<a name="line-1051"></a>        f x y = let t = x+1
<a name="line-1052"></a>            h z = if z==0 then t else
<a name="line-1053"></a>                  if z==1 then x+1 else
<a name="line-1054"></a>                  x + h (z-1)
<a name="line-1055"></a>        in h y
<a name="line-1056"></a>
<a name="line-1057"></a>Calling h does indeed evaluate x, but we can only see
<a name="line-1058"></a>that if we unleash a demand on x at the call site for t.
<a name="line-1059"></a>
<a name="line-1060"></a>Incidentally, here's a place where lambda-lifting h would
<a name="line-1061"></a>lose the cigar --- we couldn't see the joint strictness in t/x
<a name="line-1062"></a>
<a name="line-1063"></a>        ON THE OTHER HAND
<a name="line-1064"></a>
<a name="line-1065"></a>We don't want to put *all* the fv's from the RHS into the
<a name="line-1066"></a>DmdType. Because
<a name="line-1067"></a>
<a name="line-1068"></a> * it makes the strictness signatures larger, and hence slows down fixpointing
<a name="line-1069"></a>
<a name="line-1070"></a>and
<a name="line-1071"></a>
<a name="line-1072"></a> * it is useless information at the call site anyways:
<a name="line-1073"></a>   For lazy, used-many times fv's we will never get any better result than
<a name="line-1074"></a>   that, no matter how good the actual demand on the function at the call site
<a name="line-1075"></a>   is (unless it is always absent, but then the whole binder is useless).
<a name="line-1076"></a>
<a name="line-1077"></a>Therefore we exclude lazy multiple-used fv's from the environment in the
<a name="line-1078"></a>DmdType.
<a name="line-1079"></a>
<a name="line-1080"></a>But now the signature lies! (Missing variables are assumed to be absent.) To
<a name="line-1081"></a>make up for this, the code that analyses the binding keeps the demand on those
<a name="line-1082"></a>variable separate (usually called "lazy_fv") and adds it to the demand of the
<a name="line-1083"></a>whole binding later.
<a name="line-1084"></a>
<a name="line-1085"></a>What if we decide _not_ to store a strictness signature for a binding at all, as
<a name="line-1086"></a>we do when aborting a fixed-point iteration? The we risk losing the information
<a name="line-1087"></a>that the strict variables are being used. In that case, we take all free variables
<a name="line-1088"></a>mentioned in the (unsound) strictness signature, conservatively approximate the
<a name="line-1089"></a>demand put on them (topDmd), and add that to the "lazy_fv" returned by "dmdFix".
<a name="line-1090"></a>
<a name="line-1091"></a>
<a name="line-1092"></a>Note [Lambda-bound unfoldings]
<a name="line-1093"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1094"></a>We allow a lambda-bound variable to carry an unfolding, a facility that is used
<a name="line-1095"></a>exclusively for join points; see Note [Case binders and join points].  If so,
<a name="line-1096"></a>we must be careful to demand-analyse the RHS of the unfolding!  Example
<a name="line-1097"></a>   \x. \y{=Just x}. &lt;body&gt;
<a name="line-1098"></a>Then if &lt;body&gt; uses 'y', then transitively it uses 'x', and we must not
<a name="line-1099"></a>forget that fact, otherwise we might make 'x' absent when it isn't.
<a name="line-1100"></a>
<a name="line-1101"></a>
<a name="line-1102"></a>************************************************************************
<a name="line-1103"></a>*                                                                      *
<a name="line-1104"></a>\subsection{Strictness signatures}
<a name="line-1105"></a>*                                                                      *
<a name="line-1106"></a>************************************************************************
<a name="line-1107"></a>-}</span>
<a name="line-1108"></a>
<a name="line-1109"></a><a name="DFunFlag"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>DFunFlag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bool</span>  <span class='hs-comment'>-- indicates if the lambda being considered is in the</span>
<a name="line-1110"></a>                      <span class='hs-comment'>-- sequence of lambdas at the top of the RHS of a dfun</span>
<a name="line-1111"></a><a name="notArgOfDfun"></a><span class='hs-definition'>notArgOfDfun</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunFlag</span>
<a name="line-1112"></a><span class='hs-definition'>notArgOfDfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1113"></a>
<a name="line-1114"></a><a name="AnalEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1115"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_dflags</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-1116"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ae_sigs</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SigEnv</span>
<a name="line-1117"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- True on first iteration only</span>
<a name="line-1118"></a>                              <span class='hs-comment'>-- See Note [Initialising strictness]</span>
<a name="line-1119"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ae_rec_tc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RecTcChecker</span>
<a name="line-1120"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-1121"></a> <span class='hs-layout'>}</span>
<a name="line-1122"></a>
<a name="line-1123"></a>        <span class='hs-comment'>-- We use the se_env to tell us whether to</span>
<a name="line-1124"></a>        <span class='hs-comment'>-- record info about a variable in the DmdEnv</span>
<a name="line-1125"></a>        <span class='hs-comment'>-- We do so if it's a LocalId, but not top-level</span>
<a name="line-1126"></a>        <span class='hs-comment'>--</span>
<a name="line-1127"></a>        <span class='hs-comment'>-- The DmdEnv gives the demand on the free vars of the function</span>
<a name="line-1128"></a>        <span class='hs-comment'>-- when it is given enough args to satisfy the strictness signature</span>
<a name="line-1129"></a>
<a name="line-1130"></a><a name="SigEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>SigEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>VarEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictSig</span><span class='hs-layout'>,</span> <span class='hs-conid'>TopLevelFlag</span><span class='hs-layout'>)</span>
<a name="line-1131"></a>
<a name="line-1132"></a><a name="instance%20Outputable%20AnalEnv"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyword'>where</span>
<a name="line-1133"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>virgin</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1134"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"AE"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-1135"></a>         <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ae_virgin ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>virgin</span>
<a name="line-1136"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ae_sigs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1137"></a>
<a name="line-1138"></a><a name="emptyAnalEnv"></a><span class='hs-definition'>emptyAnalEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1139"></a><span class='hs-definition'>emptyAnalEnv</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span>
<a name="line-1140"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_dflags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dflags</span>
<a name="line-1141"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptySigEnv</span>
<a name="line-1142"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1143"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ae_rec_tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initRecTc</span>
<a name="line-1144"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fam_envs</span>
<a name="line-1145"></a>         <span class='hs-layout'>}</span>
<a name="line-1146"></a>
<a name="line-1147"></a><a name="emptySigEnv"></a><span class='hs-definition'>emptySigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SigEnv</span>
<a name="line-1148"></a><span class='hs-definition'>emptySigEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-1149"></a>
<a name="line-1150"></a><a name="extendAnalEnvs"></a><span class='hs-comment'>-- | Extend an environment with the strictness IDs attached to the id</span>
<a name="line-1151"></a><span class='hs-definition'>extendAnalEnvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1152"></a><span class='hs-definition'>extendAnalEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>vars</span>
<a name="line-1153"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>vars</span> <span class='hs-layout'>}</span>
<a name="line-1154"></a>
<a name="line-1155"></a><a name="extendSigEnvs"></a><span class='hs-definition'>extendSigEnvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span>
<a name="line-1156"></a><span class='hs-definition'>extendSigEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>vars</span>
<a name="line-1157"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnvList</span> <span class='hs-varid'>sigs</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>var</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>var</span><span class='hs-layout'>,</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>vars</span><span class='hs-keyglyph'>]</span>
<a name="line-1158"></a>
<a name="line-1159"></a><a name="extendAnalEnv"></a><span class='hs-definition'>extendAnalEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictSig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1160"></a><span class='hs-definition'>extendAnalEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>sig</span>
<a name="line-1161"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>var</span> <span class='hs-varid'>sig</span> <span class='hs-layout'>}</span>
<a name="line-1162"></a>
<a name="line-1163"></a><a name="extendSigEnv"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictSig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span>
<a name="line-1164"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>var</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-varid'>sig</span><span class='hs-layout'>,</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span>
<a name="line-1165"></a>
<a name="line-1166"></a><a name="lookupSigEnv"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictSig</span><span class='hs-layout'>,</span> <span class='hs-conid'>TopLevelFlag</span><span class='hs-layout'>)</span>
<a name="line-1167"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span>
<a name="line-1168"></a>
<a name="line-1169"></a><a name="getStrictness"></a><span class='hs-definition'>getStrictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictSig</span>
<a name="line-1170"></a><span class='hs-definition'>getStrictness</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span>
<a name="line-1171"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGlobalId</span> <span class='hs-varid'>fn</span>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idStrictness</span> <span class='hs-varid'>fn</span>
<a name="line-1172"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>sig</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sig</span>
<a name="line-1173"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nopSig</span>
<a name="line-1174"></a>
<a name="line-1175"></a><a name="nonVirgin"></a><span class='hs-definition'>nonVirgin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1176"></a><span class='hs-definition'>nonVirgin</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-1177"></a>
<a name="line-1178"></a><a name="extendSigsWithLam"></a><span class='hs-definition'>extendSigsWithLam</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1179"></a><span class='hs-comment'>-- Extend the AnalEnv when we meet a lambda binder</span>
<a name="line-1180"></a><span class='hs-definition'>extendSigsWithLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span>
<a name="line-1181"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>id</span>
<a name="line-1182"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isStrictDmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-varid'>env</span>
<a name="line-1183"></a>       <span class='hs-comment'>-- See Note [Optimistic CPR in the "virgin" case]</span>
<a name="line-1184"></a>       <span class='hs-comment'>-- See Note [Initial CPR for strict binders]</span>
<a name="line-1185"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>dc</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deepSplitProductType_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>id</span>
<a name="line-1186"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnv</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>cprProdSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1187"></a>
<a name="line-1188"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1189"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-1190"></a>
<a name="line-1191"></a><a name="extendEnvForProdAlt"></a><span class='hs-definition'>extendEnvForProdAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1192"></a><span class='hs-comment'>-- See Note [CPR in a product case alternative]</span>
<a name="line-1193"></a><span class='hs-definition'>extendEnvForProdAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>bndrs</span>
<a name="line-1194"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>do_con_arg</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>ids_w_strs</span>
<a name="line-1195"></a>  <span class='hs-keyword'>where</span>
<a name="line-1196"></a>    <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnv</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>case_bndr_sig</span>
<a name="line-1197"></a>
<a name="line-1198"></a>    <span class='hs-varid'>ids_w_strs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndrs</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>dc</span>
<a name="line-1199"></a>    <span class='hs-varid'>case_bndr_sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprProdSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-1200"></a>    <span class='hs-varid'>fam_envs</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span>
<a name="line-1201"></a>
<a name="line-1202"></a>    <span class='hs-varid'>do_con_arg</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span>
<a name="line-1203"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>is_strict</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStrictDmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isMarkedStrict</span> <span class='hs-varid'>str</span>
<a name="line-1204"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-varid'>env</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_var_scrut</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>is_strict</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [CPR in a product case alternative]</span>
<a name="line-1205"></a>       <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>dc</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deepSplitProductType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varop'>$</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>id</span>
<a name="line-1206"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnv</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>cprProdSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1207"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1208"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-1209"></a>
<a name="line-1210"></a>    <span class='hs-varid'>is_var_scrut</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_var</span> <span class='hs-varid'>scrut</span>
<a name="line-1211"></a>    <span class='hs-varid'>is_var</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_var</span> <span class='hs-varid'>e</span>
<a name="line-1212"></a>    <span class='hs-varid'>is_var</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isLocalId</span> <span class='hs-varid'>v</span>
<a name="line-1213"></a>    <span class='hs-varid'>is_var</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1214"></a>
<a name="line-1215"></a><a name="addDataConStrictness"></a><span class='hs-definition'>addDataConStrictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>
<a name="line-1216"></a><span class='hs-comment'>-- See Note [Add demands for strict constructors]</span>
<a name="line-1217"></a><span class='hs-definition'>addDataConStrictness</span> <span class='hs-varid'>con</span> <span class='hs-varid'>ds</span>
<a name="line-1218"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>strs</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>strs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ds</span> <span class='hs-layout'>)</span>
<a name="line-1219"></a>    <span class='hs-varid'>zipWith</span> <span class='hs-varid'>add</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>strs</span>
<a name="line-1220"></a>  <span class='hs-keyword'>where</span>
<a name="line-1221"></a>    <span class='hs-varid'>strs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>con</span>
<a name="line-1222"></a>    <span class='hs-varid'>add</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isMarkedStrict</span> <span class='hs-varid'>str</span>
<a name="line-1223"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isAbsDmd</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span> <span class='hs-varop'>`bothDmd`</span> <span class='hs-varid'>seqDmd</span>
<a name="line-1224"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span>
<a name="line-1225"></a>
<a name="line-1226"></a><a name="findBndrsDmds"></a><span class='hs-definition'>findBndrsDmds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1227"></a><span class='hs-comment'>-- Return the demands on the Ids in the [Var]</span>
<a name="line-1228"></a><span class='hs-definition'>findBndrsDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-1229"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-1230"></a>  <span class='hs-keyword'>where</span>
<a name="line-1231"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1232"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-1233"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bs</span>
<a name="line-1234"></a>                        <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-conid'>False</span> <span class='hs-varid'>dmd_ty1</span> <span class='hs-varid'>b</span>
<a name="line-1235"></a>                    <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmd</span> <span class='hs-conop'>:</span> <span class='hs-varid'>dmds</span><span class='hs-layout'>)</span>
<a name="line-1236"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bs</span>
<a name="line-1237"></a>
<a name="line-1238"></a><a name="findBndrDmd"></a><span class='hs-definition'>findBndrDmd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Demand</span><span class='hs-layout'>)</span>
<a name="line-1239"></a><span class='hs-comment'>-- See Note [Trimming a demand to a type] in Demand.hs</span>
<a name="line-1240"></a><span class='hs-definition'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-1241"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmd'</span><span class='hs-layout'>)</span>
<a name="line-1242"></a>  <span class='hs-keyword'>where</span>
<a name="line-1243"></a>    <span class='hs-varid'>dmd'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>killUsageDemand</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_dflags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1244"></a>           <span class='hs-varid'>strictify</span> <span class='hs-varop'>$</span>
<a name="line-1245"></a>           <span class='hs-varid'>trimToType</span> <span class='hs-varid'>starting_dmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>findTypeShape</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>id_ty</span><span class='hs-layout'>)</span>
<a name="line-1246"></a>
<a name="line-1247"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>starting_dmd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>peelFV</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-1248"></a>
<a name="line-1249"></a>    <span class='hs-varid'>id_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>id</span>
<a name="line-1250"></a>
<a name="line-1251"></a>    <span class='hs-varid'>strictify</span> <span class='hs-varid'>dmd</span>
<a name="line-1252"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_DictsStrict</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_dflags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1253"></a>             <span class='hs-comment'>-- We never want to strictify a recursive let. At the moment</span>
<a name="line-1254"></a>             <span class='hs-comment'>-- annotateBndr is only call for non-recursive lets; if that</span>
<a name="line-1255"></a>             <span class='hs-comment'>-- changes, we need a RecFlag parameter and another guard here.</span>
<a name="line-1256"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-comment'>-- See Note [Do not strictify the argument dictionaries of a dfun]</span>
<a name="line-1257"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictifyDictDmd</span> <span class='hs-varid'>id_ty</span> <span class='hs-varid'>dmd</span>
<a name="line-1258"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1259"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span>
<a name="line-1260"></a>
<a name="line-1261"></a>    <span class='hs-varid'>fam_envs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span>
<a name="line-1262"></a>
<a name="line-1263"></a><a name="set_idStrictness"></a><span class='hs-definition'>set_idStrictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictSig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1264"></a><span class='hs-definition'>set_idStrictness</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig</span>
<a name="line-1265"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdStrictness</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>killUsageSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_dflags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>sig</span><span class='hs-layout'>)</span>
<a name="line-1266"></a>
<a name="line-1267"></a><a name="dumpStrSig"></a><span class='hs-definition'>dumpStrSig</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1268"></a><span class='hs-definition'>dumpStrSig</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>printId</span> <span class='hs-varid'>ids</span><span class='hs-layout'>)</span>
<a name="line-1269"></a>  <span class='hs-keyword'>where</span>
<a name="line-1270"></a>  <span class='hs-varid'>ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sortBy</span> <span class='hs-layout'>(</span><span class='hs-varid'>stableNameCmp</span> <span class='hs-varop'>`on`</span> <span class='hs-varid'>getName</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>concatMap</span> <span class='hs-varid'>getIds</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-1271"></a>  <span class='hs-varid'>getIds</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>i</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>]</span>
<a name="line-1272"></a>  <span class='hs-varid'>getIds</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>bs</span>
<a name="line-1273"></a>  <span class='hs-varid'>printId</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isExportedId</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>id</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>colon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprIfaceStrictSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1274"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>empty</span>
<a name="line-1275"></a>
<a name="line-1276"></a><span class='hs-comment'>{- Note [CPR in a product case alternative]
<a name="line-1277"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1278"></a>In a case alternative for a product type, we want to give some of the
<a name="line-1279"></a>binders the CPR property.  Specifically
<a name="line-1280"></a>
<a name="line-1281"></a> * The case binder; inside the alternative, the case binder always has
<a name="line-1282"></a>   the CPR property, meaning that a case on it will successfully cancel.
<a name="line-1283"></a>   Example:
<a name="line-1284"></a>        f True  x = case x of y { I# x' -&gt; if x' ==# 3
<a name="line-1285"></a>                                           then y
<a name="line-1286"></a>                                           else I# 8 }
<a name="line-1287"></a>        f False x = I# 3
<a name="line-1288"></a>
<a name="line-1289"></a>   By giving 'y' the CPR property, we ensure that 'f' does too, so we get
<a name="line-1290"></a>        f b x = case fw b x of { r -&gt; I# r }
<a name="line-1291"></a>        fw True  x = case x of y { I# x' -&gt; if x' ==# 3 then x' else 8 }
<a name="line-1292"></a>        fw False x = 3
<a name="line-1293"></a>
<a name="line-1294"></a>   Of course there is the usual risk of re-boxing: we have 'x' available
<a name="line-1295"></a>   boxed and unboxed, but we return the unboxed version for the wrapper to
<a name="line-1296"></a>   box.  If the wrapper doesn't cancel with its caller, we'll end up
<a name="line-1297"></a>   re-boxing something that we did have available in boxed form.
<a name="line-1298"></a>
<a name="line-1299"></a> * Any strict binders with product type, can use
<a name="line-1300"></a>   Note [Initial CPR for strict binders].  But we can go a little
<a name="line-1301"></a>   further. Consider
<a name="line-1302"></a>
<a name="line-1303"></a>      data T = MkT !Int Int
<a name="line-1304"></a>
<a name="line-1305"></a>      f2 (MkT x y) | y&gt;0       = f2 (MkT x (y-1))
<a name="line-1306"></a>                   | otherwise = x
<a name="line-1307"></a>
<a name="line-1308"></a>   For $wf2 we are going to unbox the MkT *and*, since it is strict, the
<a name="line-1309"></a>   first argument of the MkT; see Note [Add demands for strict constructors].
<a name="line-1310"></a>   But then we don't want box it up again when returning it!  We want
<a name="line-1311"></a>   'f2' to have the CPR property, so we give 'x' the CPR property.
<a name="line-1312"></a>
<a name="line-1313"></a> * It's a bit delicate because if this case is scrutinising something other
<a name="line-1314"></a>   than an argument the original function, we really don't have the unboxed
<a name="line-1315"></a>   version available.  E.g
<a name="line-1316"></a>      g v = case foo v of
<a name="line-1317"></a>              MkT x y | y&gt;0       -&gt; ...
<a name="line-1318"></a>                      | otherwise -&gt; x
<a name="line-1319"></a>   Here we don't have the unboxed 'x' available.  Hence the
<a name="line-1320"></a>   is_var_scrut test when making use of the strictness annotation.
<a name="line-1321"></a>   Slightly ad-hoc, because even if the scrutinee *is* a variable it
<a name="line-1322"></a>   might not be a onre of the arguments to the original function, or a
<a name="line-1323"></a>   sub-component thereof.  But it's simple, and nothing terrible
<a name="line-1324"></a>   happens if we get it wrong.  e.g. Trac #10694.
<a name="line-1325"></a>
<a name="line-1326"></a>Note [Add demands for strict constructors]
<a name="line-1327"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1328"></a>Consider this program (due to Roman):
<a name="line-1329"></a>
<a name="line-1330"></a>    data X a = X !a
<a name="line-1331"></a>
<a name="line-1332"></a>    foo :: X Int -&gt; Int -&gt; Int
<a name="line-1333"></a>    foo (X a) n = go 0
<a name="line-1334"></a>     where
<a name="line-1335"></a>       go i | i &lt; n     = a + go (i+1)
<a name="line-1336"></a>            | otherwise = 0
<a name="line-1337"></a>
<a name="line-1338"></a>We want the worker for 'foo' too look like this:
<a name="line-1339"></a>
<a name="line-1340"></a>    $wfoo :: Int# -&gt; Int# -&gt; Int#
<a name="line-1341"></a>
<a name="line-1342"></a>with the first argument unboxed, so that it is not eval'd each time
<a name="line-1343"></a>around the 'go' loop (which would otherwise happen, since 'foo' is not
<a name="line-1344"></a>strict in 'a').  It is sound for the wrapper to pass an unboxed arg
<a name="line-1345"></a>because X is strict, so its argument must be evaluated.  And if we
<a name="line-1346"></a>*don't* pass an unboxed argument, we can't even repair it by adding a
<a name="line-1347"></a>`seq` thus:
<a name="line-1348"></a>
<a name="line-1349"></a>    foo (X a) n = a `seq` go 0
<a name="line-1350"></a>
<a name="line-1351"></a>because the seq is discarded (very early) since X is strict!
<a name="line-1352"></a>
<a name="line-1353"></a>We achieve the effect using addDataConStrictness.  It is called at a
<a name="line-1354"></a>case expression, such as the pattern match on (X a) in the example
<a name="line-1355"></a>above.  After computing how 'a' is used in the alternatives, we add an
<a name="line-1356"></a>extra 'seqDmd' to it.  The case alternative isn't itself strict in the
<a name="line-1357"></a>sub-components, but simply evaluating the scrutinee to HNF does force
<a name="line-1358"></a>those sub-components.
<a name="line-1359"></a>
<a name="line-1360"></a>If the argument is not used at all in the alternative (i.e. it is
<a name="line-1361"></a>Absent), then *don't* add a 'seqDmd'.  If we do, it makes it look used
<a name="line-1362"></a>and hence it'll be passed to the worker when it doesn't need to be.
<a name="line-1363"></a>Hence the isAbsDmd test in addDataConStrictness.
<a name="line-1364"></a>
<a name="line-1365"></a>There is the usual danger of reboxing, which as usual we ignore. But
<a name="line-1366"></a>if X is monomorphic, and has an UNPACK pragma, then this optimisation
<a name="line-1367"></a>is even more important.  We don't want the wrapper to rebox an unboxed
<a name="line-1368"></a>argument, and pass an Int to $wfoo!
<a name="line-1369"></a>
<a name="line-1370"></a>
<a name="line-1371"></a>Note [Initial CPR for strict binders]
<a name="line-1372"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1373"></a>CPR is initialized for a lambda binder in an optimistic manner, i.e,
<a name="line-1374"></a>if the binder is used strictly and at least some of its components as
<a name="line-1375"></a>a product are used, which is checked by the value of the absence
<a name="line-1376"></a>demand.
<a name="line-1377"></a>
<a name="line-1378"></a>If the binder is marked demanded with a strict demand, then give it a
<a name="line-1379"></a>CPR signature. Here's a concrete example ('f1' in test T10482a),
<a name="line-1380"></a>assuming h is strict:
<a name="line-1381"></a>
<a name="line-1382"></a>  f1 :: Int -&gt; Int
<a name="line-1383"></a>  f1 x = case h x of
<a name="line-1384"></a>          A -&gt; x
<a name="line-1385"></a>          B -&gt; f1 (x-1)
<a name="line-1386"></a>          C -&gt; x+1
<a name="line-1387"></a>
<a name="line-1388"></a>If we notice that 'x' is used strictly, we can give it the CPR
<a name="line-1389"></a>property; and hence f1 gets the CPR property too.  It's sound (doesn't
<a name="line-1390"></a>change strictness) to give it the CPR property because by the time 'x'
<a name="line-1391"></a>is returned (case A above), it'll have been evaluated (by the wrapper
<a name="line-1392"></a>of 'h' in the example).
<a name="line-1393"></a>
<a name="line-1394"></a>Moreover, if f itself is strict in x, then we'll pass x unboxed to
<a name="line-1395"></a>f1, and so the boxed version *won't* be available; in that case it's
<a name="line-1396"></a>very helpful to give 'x' the CPR property.
<a name="line-1397"></a>
<a name="line-1398"></a>Note that
<a name="line-1399"></a>
<a name="line-1400"></a>  * We only want to do this for something that definitely
<a name="line-1401"></a>    has product type, else we may get over-optimistic CPR results
<a name="line-1402"></a>    (e.g. from \x -&gt; x!).
<a name="line-1403"></a>
<a name="line-1404"></a>  * See Note [CPR examples]
<a name="line-1405"></a>
<a name="line-1406"></a>Note [CPR examples]
<a name="line-1407"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-1408"></a>Here are some examples (stranal/should_compile/T10482a) of the
<a name="line-1409"></a>usefulness of Note [CPR in a product case alternative].  The main
<a name="line-1410"></a>point: all of these functions can have the CPR property.
<a name="line-1411"></a>
<a name="line-1412"></a>    ------- f1 -----------
<a name="line-1413"></a>    -- x is used strictly by h, so it'll be available
<a name="line-1414"></a>    -- unboxed before it is returned in the True branch
<a name="line-1415"></a>
<a name="line-1416"></a>    f1 :: Int -&gt; Int
<a name="line-1417"></a>    f1 x = case h x x of
<a name="line-1418"></a>            True  -&gt; x
<a name="line-1419"></a>            False -&gt; f1 (x-1)
<a name="line-1420"></a>
<a name="line-1421"></a>
<a name="line-1422"></a>    ------- f2 -----------
<a name="line-1423"></a>    -- x is a strict field of MkT2, so we'll pass it unboxed
<a name="line-1424"></a>    -- to $wf2, so it's available unboxed.  This depends on
<a name="line-1425"></a>    -- the case expression analysing (a subcomponent of) one
<a name="line-1426"></a>    -- of the original arguments to the function, so it's
<a name="line-1427"></a>    -- a bit more delicate.
<a name="line-1428"></a>
<a name="line-1429"></a>    data T2 = MkT2 !Int Int
<a name="line-1430"></a>
<a name="line-1431"></a>    f2 :: T2 -&gt; Int
<a name="line-1432"></a>    f2 (MkT2 x y) | y&gt;0       = f2 (MkT2 x (y-1))
<a name="line-1433"></a>                  | otherwise = x
<a name="line-1434"></a>
<a name="line-1435"></a>
<a name="line-1436"></a>    ------- f3 -----------
<a name="line-1437"></a>    -- h is strict in x, so x will be unboxed before it
<a name="line-1438"></a>    -- is rerturned in the otherwise case.
<a name="line-1439"></a>
<a name="line-1440"></a>    data T3 = MkT3 Int Int
<a name="line-1441"></a>
<a name="line-1442"></a>    f1 :: T3 -&gt; Int
<a name="line-1443"></a>    f1 (MkT3 x y) | h x y     = f3 (MkT3 x (y-1))
<a name="line-1444"></a>                  | otherwise = x
<a name="line-1445"></a>
<a name="line-1446"></a>
<a name="line-1447"></a>    ------- f4 -----------
<a name="line-1448"></a>    -- Just like f2, but MkT4 can't unbox its strict
<a name="line-1449"></a>    -- argument automatically, as f2 can
<a name="line-1450"></a>
<a name="line-1451"></a>    data family Foo a
<a name="line-1452"></a>    newtype instance Foo Int = Foo Int
<a name="line-1453"></a>
<a name="line-1454"></a>    data T4 a = MkT4 !(Foo a) Int
<a name="line-1455"></a>
<a name="line-1456"></a>    f4 :: T4 Int -&gt; Int
<a name="line-1457"></a>    f4 (MkT4 x@(Foo v) y) | y&gt;0       = f4 (MkT4 x (y-1))
<a name="line-1458"></a>                          | otherwise = v
<a name="line-1459"></a>
<a name="line-1460"></a>
<a name="line-1461"></a>Note [Initialising strictness]
<a name="line-1462"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1463"></a>See section 9.2 (Finding fixpoints) of the paper.
<a name="line-1464"></a>
<a name="line-1465"></a>Our basic plan is to initialise the strictness of each Id in a
<a name="line-1466"></a>recursive group to "bottom", and find a fixpoint from there.  However,
<a name="line-1467"></a>this group B might be inside an *enclosing* recursive group A, in
<a name="line-1468"></a>which case we'll do the entire fixpoint shebang on for each iteration
<a name="line-1469"></a>of A. This can be illustrated by the following example:
<a name="line-1470"></a>
<a name="line-1471"></a>Example:
<a name="line-1472"></a>
<a name="line-1473"></a>  f [] = []
<a name="line-1474"></a>  f (x:xs) = let g []     = f xs
<a name="line-1475"></a>                 g (y:ys) = y+1 : g ys
<a name="line-1476"></a>              in g (h x)
<a name="line-1477"></a>
<a name="line-1478"></a>At each iteration of the fixpoint for f, the analyser has to find a
<a name="line-1479"></a>fixpoint for the enclosed function g. In the meantime, the demand
<a name="line-1480"></a>values for g at each iteration for f are *greater* than those we
<a name="line-1481"></a>encountered in the previous iteration for f. Therefore, we can begin
<a name="line-1482"></a>the fixpoint for g not with the bottom value but rather with the
<a name="line-1483"></a>result of the previous analysis. I.e., when beginning the fixpoint
<a name="line-1484"></a>process for g, we can start from the demand signature computed for g
<a name="line-1485"></a>previously and attached to the binding occurrence of g.
<a name="line-1486"></a>
<a name="line-1487"></a>To speed things up, we initialise each iteration of A (the enclosing
<a name="line-1488"></a>one) from the result of the last one, which is neatly recorded in each
<a name="line-1489"></a>binder.  That way we make use of earlier iterations of the fixpoint
<a name="line-1490"></a>algorithm. (Cunning plan.)
<a name="line-1491"></a>
<a name="line-1492"></a>But on the *first* iteration we want to *ignore* the current strictness
<a name="line-1493"></a>of the Id, and start from "bottom".  Nowadays the Id can have a current
<a name="line-1494"></a>strictness, because interface files record strictness for nested bindings.
<a name="line-1495"></a>To know when we are in the first iteration, we look at the ae_virgin
<a name="line-1496"></a>field of the AnalEnv.
<a name="line-1497"></a>
<a name="line-1498"></a>
<a name="line-1499"></a>Note [Final Demand Analyser run]
<a name="line-1500"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1501"></a>Some of the information that the demand analyser determines is not always
<a name="line-1502"></a>preserved by the simplifier.  For example, the simplifier will happily rewrite
<a name="line-1503"></a>  \y [Demand=1*U] let x = y in x + x
<a name="line-1504"></a>to
<a name="line-1505"></a>  \y [Demand=1*U] y + y
<a name="line-1506"></a>which is quite a lie.
<a name="line-1507"></a>
<a name="line-1508"></a>The once-used information is (currently) only used by the code
<a name="line-1509"></a>generator, though.  So:
<a name="line-1510"></a>
<a name="line-1511"></a> * We zap the used-once info in the worker-wrapper;
<a name="line-1512"></a>   see Note [Zapping Used Once info in WorkWrap] in WorkWrap. If it's
<a name="line-1513"></a>   not reliable, it's better not to have it at all.
<a name="line-1514"></a>
<a name="line-1515"></a> * Just before TidyCore, we add a pass of the demand analyser,
<a name="line-1516"></a>      but WITHOUT subsequent worker/wrapper and simplifier,
<a name="line-1517"></a>   right before TidyCore.  See SimplCore.getCoreToDo.
<a name="line-1518"></a>
<a name="line-1519"></a>   This way, correct information finds its way into the module interface
<a name="line-1520"></a>   (strictness signatures!) and the code generator (single-entry thunks!)
<a name="line-1521"></a>
<a name="line-1522"></a>Note that, in contrast, the single-call information (C1(..)) /can/ be
<a name="line-1523"></a>relied upon, as the simplifier tends to be very careful about not
<a name="line-1524"></a>duplicating actual function calls.
<a name="line-1525"></a>
<a name="line-1526"></a>Also see #11731.
<a name="line-1527"></a>-}</span>
</pre></body>
</html>
