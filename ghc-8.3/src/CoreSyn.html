<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>coreSyn/CoreSyn.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The University of Glasgow 2006
<a name="line-3"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-4"></a>-}</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE CPP, DeriveDataTypeable, FlexibleContexts #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE NamedFieldPuns #-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-comment'>-- | CoreSyn holds all the main data types for use by for the Glasgow Haskell Compiler midsection</span>
<a name="line-10"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>CoreSyn</span> <span class='hs-layout'>(</span>
<a name="line-11"></a>        <span class='hs-comment'>-- * Main data types</span>
<a name="line-12"></a>        <span class='hs-conid'>Expr</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bind</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AltCon</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Arg</span><span class='hs-layout'>,</span>
<a name="line-13"></a>        <span class='hs-conid'>Tickish</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>TickishScoping</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>TickishPlacement</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-14"></a>        <span class='hs-conid'>CoreProgram</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBndr</span><span class='hs-layout'>,</span>
<a name="line-15"></a>        <span class='hs-conid'>TaggedExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedBndr</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>deTagExpr</span><span class='hs-layout'>,</span>
<a name="line-16"></a>
<a name="line-17"></a>        <span class='hs-comment'>-- * In/Out type synonyms</span>
<a name="line-18"></a>        <span class='hs-conid'>InId</span><span class='hs-layout'>,</span> <span class='hs-conid'>InBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>InAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>InArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>InType</span><span class='hs-layout'>,</span> <span class='hs-conid'>InKind</span><span class='hs-layout'>,</span>
<a name="line-19"></a>               <span class='hs-conid'>InBndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>InVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>InCoercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>InTyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>InCoVar</span><span class='hs-layout'>,</span>
<a name="line-20"></a>        <span class='hs-conid'>OutId</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutType</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutKind</span><span class='hs-layout'>,</span>
<a name="line-21"></a>               <span class='hs-conid'>OutBndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutCoercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutTyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutCoVar</span><span class='hs-layout'>,</span>
<a name="line-22"></a>
<a name="line-23"></a>        <span class='hs-comment'>-- ** 'Expr' construction</span>
<a name="line-24"></a>        <span class='hs-varid'>mkLet</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLets</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLetNonRec</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLetRec</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLams</span><span class='hs-layout'>,</span>
<a name="line-25"></a>        <span class='hs-varid'>mkApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkVarApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyArg</span><span class='hs-layout'>,</span>
<a name="line-26"></a>
<a name="line-27"></a>        <span class='hs-varid'>mkIntLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkIntLitInt</span><span class='hs-layout'>,</span>
<a name="line-28"></a>        <span class='hs-varid'>mkWordLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWordLitWord</span><span class='hs-layout'>,</span>
<a name="line-29"></a>        <span class='hs-varid'>mkWord64LitWord64</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkInt64LitInt64</span><span class='hs-layout'>,</span>
<a name="line-30"></a>        <span class='hs-varid'>mkCharLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkStringLit</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-varid'>mkFloatLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkFloatLitFloat</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-varid'>mkDoubleLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDoubleLitDouble</span><span class='hs-layout'>,</span>
<a name="line-33"></a>
<a name="line-34"></a>        <span class='hs-varid'>mkConApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkConApp2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyBind</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoBind</span><span class='hs-layout'>,</span>
<a name="line-35"></a>        <span class='hs-varid'>varToCoreExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>varsToCoreExprs</span><span class='hs-layout'>,</span>
<a name="line-36"></a>
<a name="line-37"></a>        <span class='hs-varid'>isId</span><span class='hs-layout'>,</span> <span class='hs-varid'>cmpAltCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>cmpAlt</span><span class='hs-layout'>,</span> <span class='hs-varid'>ltAlt</span><span class='hs-layout'>,</span>
<a name="line-38"></a>
<a name="line-39"></a>        <span class='hs-comment'>-- ** Simple 'Expr' access functions and predicates</span>
<a name="line-40"></a>        <span class='hs-varid'>bindersOf</span><span class='hs-layout'>,</span> <span class='hs-varid'>bindersOfBinds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhssOfBind</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhssOfAlts</span><span class='hs-layout'>,</span>
<a name="line-41"></a>        <span class='hs-varid'>collectBinders</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectTyBinders</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectTyAndValBinders</span><span class='hs-layout'>,</span>
<a name="line-42"></a>        <span class='hs-varid'>collectNBinders</span><span class='hs-layout'>,</span>
<a name="line-43"></a>        <span class='hs-varid'>collectArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectArgsTicks</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenBinds</span><span class='hs-layout'>,</span>
<a name="line-44"></a>
<a name="line-45"></a>        <span class='hs-varid'>exprToType</span><span class='hs-layout'>,</span> <span class='hs-varid'>exprToCoercion_maybe</span><span class='hs-layout'>,</span>
<a name="line-46"></a>        <span class='hs-varid'>applyTypeToArg</span><span class='hs-layout'>,</span>
<a name="line-47"></a>
<a name="line-48"></a>        <span class='hs-varid'>isValArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTypeArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTyCoArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>valArgCount</span><span class='hs-layout'>,</span> <span class='hs-varid'>valBndrCount</span><span class='hs-layout'>,</span>
<a name="line-49"></a>        <span class='hs-varid'>isRuntimeArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>isRuntimeVar</span><span class='hs-layout'>,</span>
<a name="line-50"></a>
<a name="line-51"></a>        <span class='hs-comment'>-- * Tick-related functions</span>
<a name="line-52"></a>        <span class='hs-varid'>tickishCounts</span><span class='hs-layout'>,</span> <span class='hs-varid'>tickishScoped</span><span class='hs-layout'>,</span> <span class='hs-varid'>tickishScopesLike</span><span class='hs-layout'>,</span> <span class='hs-varid'>tickishFloatable</span><span class='hs-layout'>,</span>
<a name="line-53"></a>        <span class='hs-varid'>tickishCanSplit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkNoCount</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkNoScope</span><span class='hs-layout'>,</span>
<a name="line-54"></a>        <span class='hs-varid'>tickishIsCode</span><span class='hs-layout'>,</span> <span class='hs-varid'>tickishPlace</span><span class='hs-layout'>,</span>
<a name="line-55"></a>        <span class='hs-varid'>tickishContains</span><span class='hs-layout'>,</span>
<a name="line-56"></a>
<a name="line-57"></a>        <span class='hs-comment'>-- * Unfolding data types</span>
<a name="line-58"></a>        <span class='hs-conid'>Unfolding</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>  <span class='hs-conid'>UnfoldingGuidance</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>UnfoldingSource</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-59"></a>
<a name="line-60"></a>        <span class='hs-comment'>-- ** Constructing 'Unfolding's</span>
<a name="line-61"></a>        <span class='hs-varid'>noUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>bootUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>evaldUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkOtherCon</span><span class='hs-layout'>,</span>
<a name="line-62"></a>        <span class='hs-varid'>unSaturatedOk</span><span class='hs-layout'>,</span> <span class='hs-varid'>needSaturated</span><span class='hs-layout'>,</span> <span class='hs-varid'>boringCxtOk</span><span class='hs-layout'>,</span> <span class='hs-varid'>boringCxtNotOk</span><span class='hs-layout'>,</span>
<a name="line-63"></a>
<a name="line-64"></a>        <span class='hs-comment'>-- ** Predicates and deconstruction on 'Unfolding'</span>
<a name="line-65"></a>        <span class='hs-varid'>unfoldingTemplate</span><span class='hs-layout'>,</span> <span class='hs-varid'>expandUnfolding_maybe</span><span class='hs-layout'>,</span>
<a name="line-66"></a>        <span class='hs-varid'>maybeUnfoldingTemplate</span><span class='hs-layout'>,</span> <span class='hs-varid'>otherCons</span><span class='hs-layout'>,</span>
<a name="line-67"></a>        <span class='hs-varid'>isValueUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isEvaldUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isCheapUnfolding</span><span class='hs-layout'>,</span>
<a name="line-68"></a>        <span class='hs-varid'>isExpandableUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isConLikeUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isCompulsoryUnfolding</span><span class='hs-layout'>,</span>
<a name="line-69"></a>        <span class='hs-varid'>isStableUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isFragileUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>hasSomeUnfolding</span><span class='hs-layout'>,</span>
<a name="line-70"></a>        <span class='hs-varid'>isBootUnfolding</span><span class='hs-layout'>,</span>
<a name="line-71"></a>        <span class='hs-varid'>canUnfold</span><span class='hs-layout'>,</span> <span class='hs-varid'>neverUnfoldGuidance</span><span class='hs-layout'>,</span> <span class='hs-varid'>isStableSource</span><span class='hs-layout'>,</span>
<a name="line-72"></a>
<a name="line-73"></a>        <span class='hs-comment'>-- * Annotated expression data types</span>
<a name="line-74"></a>        <span class='hs-conid'>AnnExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr'</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnBind</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnAlt</span><span class='hs-layout'>,</span>
<a name="line-75"></a>
<a name="line-76"></a>        <span class='hs-comment'>-- ** Operations on annotated expressions</span>
<a name="line-77"></a>        <span class='hs-varid'>collectAnnArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectAnnArgsTicks</span><span class='hs-layout'>,</span>
<a name="line-78"></a>
<a name="line-79"></a>        <span class='hs-comment'>-- ** Operations on annotations</span>
<a name="line-80"></a>        <span class='hs-varid'>deAnnotate</span><span class='hs-layout'>,</span> <span class='hs-varid'>deAnnotate'</span><span class='hs-layout'>,</span> <span class='hs-varid'>deAnnAlt</span><span class='hs-layout'>,</span>
<a name="line-81"></a>        <span class='hs-varid'>collectAnnBndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectNAnnBndrs</span><span class='hs-layout'>,</span>
<a name="line-82"></a>
<a name="line-83"></a>        <span class='hs-comment'>-- * Orphanhood</span>
<a name="line-84"></a>        <span class='hs-conid'>IsOrphan</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>isOrphan</span><span class='hs-layout'>,</span> <span class='hs-varid'>notOrphan</span><span class='hs-layout'>,</span> <span class='hs-varid'>chooseOrphanAnchor</span><span class='hs-layout'>,</span>
<a name="line-85"></a>
<a name="line-86"></a>        <span class='hs-comment'>-- * Core rule data types</span>
<a name="line-87"></a>        <span class='hs-conid'>CoreRule</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>RuleBase</span><span class='hs-layout'>,</span>
<a name="line-88"></a>        <span class='hs-conid'>RuleName</span><span class='hs-layout'>,</span> <span class='hs-conid'>RuleFun</span><span class='hs-layout'>,</span> <span class='hs-conid'>IdUnfoldingFun</span><span class='hs-layout'>,</span> <span class='hs-conid'>InScopeEnv</span><span class='hs-layout'>,</span>
<a name="line-89"></a>        <span class='hs-conid'>RuleEnv</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkRuleEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyRuleEnv</span><span class='hs-layout'>,</span>
<a name="line-90"></a>
<a name="line-91"></a>        <span class='hs-comment'>-- ** Operations on 'CoreRule's</span>
<a name="line-92"></a>        <span class='hs-varid'>ruleArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleName</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleIdName</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleActivation</span><span class='hs-layout'>,</span>
<a name="line-93"></a>        <span class='hs-varid'>setRuleIdName</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleModule</span><span class='hs-layout'>,</span>
<a name="line-94"></a>        <span class='hs-varid'>isBuiltinRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>isLocalRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>isAutoRule</span><span class='hs-layout'>,</span>
<a name="line-95"></a>
<a name="line-96"></a>        <span class='hs-comment'>-- * Core vectorisation declarations data type</span>
<a name="line-97"></a>        <span class='hs-conid'>CoreVect</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-98"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-99"></a>
<a name="line-100"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-101"></a>
<a name="line-102"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CostCentre</span>
<a name="line-103"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span><span class='hs-layout'>(</span> <span class='hs-conid'>InScopeSet</span> <span class='hs-layout'>)</span>
<a name="line-104"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-105"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-106"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span>
<a name="line-107"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-108"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameSet</span>
<a name="line-109"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameEnv</span><span class='hs-layout'>(</span> <span class='hs-conid'>NameEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyNameEnv</span> <span class='hs-layout'>)</span>
<a name="line-110"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Literal</span>
<a name="line-111"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-112"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Module</span>
<a name="line-113"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-114"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>
<a name="line-115"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-116"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-117"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-118"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>UniqSet</span>
<a name="line-119"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>SrcLoc</span>     <span class='hs-layout'>(</span> <span class='hs-conid'>RealSrcSpan</span><span class='hs-layout'>,</span> <span class='hs-varid'>containsSpan</span> <span class='hs-layout'>)</span>
<a name="line-120"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Binary</span>
<a name="line-121"></a>
<a name="line-122"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Data</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyCon</span><span class='hs-layout'>)</span>
<a name="line-123"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Int</span>
<a name="line-124"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Word</span>
<a name="line-125"></a>
<a name="line-126"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>`mkApps`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkTyApps`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkVarApps`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`App`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkCoApps`</span>
<a name="line-127"></a><span class='hs-comment'>-- Left associative, so that we can say (f `mkTyApps` xs `mkVarApps` ys)</span>
<a name="line-128"></a>
<a name="line-129"></a><span class='hs-comment'>{-
<a name="line-130"></a>************************************************************************
<a name="line-131"></a>*                                                                      *
<a name="line-132"></a>\subsection{The main data types}
<a name="line-133"></a>*                                                                      *
<a name="line-134"></a>************************************************************************
<a name="line-135"></a>
<a name="line-136"></a>These data types are the heart of the compiler
<a name="line-137"></a>-}</span>
<a name="line-138"></a>
<a name="line-139"></a><span class='hs-comment'>-- | This is the data type that represents GHCs core intermediate language. Currently</span>
<a name="line-140"></a><span class='hs-comment'>-- GHC uses System FC &lt;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions/&gt; for this purpose,</span>
<a name="line-141"></a><span class='hs-comment'>-- which is closely related to the simpler and better known System F &lt;<a href="http://en.wikipedia.org/wiki/System_F">http://en.wikipedia.org/wiki/System_F</a>&gt;.</span>
<a name="line-142"></a><span class='hs-comment'>--</span>
<a name="line-143"></a><span class='hs-comment'>-- We get from Haskell source to this Core language in a number of stages:</span>
<a name="line-144"></a><span class='hs-comment'>--</span>
<a name="line-145"></a><span class='hs-comment'>-- 1. The source code is parsed into an abstract syntax tree, which is represented</span>
<a name="line-146"></a><span class='hs-comment'>--    by the data type 'HsExpr.HsExpr' with the names being 'RdrName.RdrNames'</span>
<a name="line-147"></a><span class='hs-comment'>--</span>
<a name="line-148"></a><span class='hs-comment'>-- 2. This syntax tree is /renamed/, which attaches a 'Unique.Unique' to every 'RdrName.RdrName'</span>
<a name="line-149"></a><span class='hs-comment'>--    (yielding a 'Name.Name') to disambiguate identifiers which are lexically identical.</span>
<a name="line-150"></a><span class='hs-comment'>--    For example, this program:</span>
<a name="line-151"></a><span class='hs-comment'>--</span>
<a name="line-152"></a><span class='hs-comment'>-- @</span>
<a name="line-153"></a><span class='hs-comment'>--      f x = let f x = x + 1</span>
<a name="line-154"></a><span class='hs-comment'>--            in f (x - 2)</span>
<a name="line-155"></a><span class='hs-comment'>-- @</span>
<a name="line-156"></a><span class='hs-comment'>--</span>
<a name="line-157"></a><span class='hs-comment'>--    Would be renamed by having 'Unique's attached so it looked something like this:</span>
<a name="line-158"></a><span class='hs-comment'>--</span>
<a name="line-159"></a><span class='hs-comment'>-- @</span>
<a name="line-160"></a><span class='hs-comment'>--      f_1 x_2 = let f_3 x_4 = x_4 + 1</span>
<a name="line-161"></a><span class='hs-comment'>--                in f_3 (x_2 - 2)</span>
<a name="line-162"></a><span class='hs-comment'>-- @</span>
<a name="line-163"></a><span class='hs-comment'>--    But see Note [Shadowing] below.</span>
<a name="line-164"></a><span class='hs-comment'>--</span>
<a name="line-165"></a><span class='hs-comment'>-- 3. The resulting syntax tree undergoes type checking (which also deals with instantiating</span>
<a name="line-166"></a><span class='hs-comment'>--    type class arguments) to yield a 'HsExpr.HsExpr' type that has 'Id.Id' as it's names.</span>
<a name="line-167"></a><span class='hs-comment'>--</span>
<a name="line-168"></a><span class='hs-comment'>-- 4. Finally the syntax tree is /desugared/ from the expressive 'HsExpr.HsExpr' type into</span>
<a name="line-169"></a><span class='hs-comment'>--    this 'Expr' type, which has far fewer constructors and hence is easier to perform</span>
<a name="line-170"></a><span class='hs-comment'>--    optimization, analysis and code generation on.</span>
<a name="line-171"></a><span class='hs-comment'>--</span>
<a name="line-172"></a><span class='hs-comment'>-- The type parameter @b@ is for the type of binders in the expression tree.</span>
<a name="line-173"></a><span class='hs-comment'>--</span>
<a name="line-174"></a><span class='hs-comment'>-- The language consists of the following elements:</span>
<a name="line-175"></a><span class='hs-comment'>--</span>
<a name="line-176"></a><span class='hs-comment'>-- *  Variables</span>
<a name="line-177"></a><span class='hs-comment'>--</span>
<a name="line-178"></a><span class='hs-comment'>-- *  Primitive literals</span>
<a name="line-179"></a><span class='hs-comment'>--</span>
<a name="line-180"></a><span class='hs-comment'>-- *  Applications: note that the argument may be a 'Type'.</span>
<a name="line-181"></a><span class='hs-comment'>--    See Note [CoreSyn let/app invariant]</span>
<a name="line-182"></a><span class='hs-comment'>--    See Note [Levity polymorphism invariants]</span>
<a name="line-183"></a><span class='hs-comment'>--</span>
<a name="line-184"></a><span class='hs-comment'>-- *  Lambda abstraction</span>
<a name="line-185"></a><span class='hs-comment'>--    See Note [Levity polymorphism invariants]</span>
<a name="line-186"></a><span class='hs-comment'>--</span>
<a name="line-187"></a><span class='hs-comment'>-- *  Recursive and non recursive @let@s. Operationally</span>
<a name="line-188"></a><span class='hs-comment'>--    this corresponds to allocating a thunk for the things</span>
<a name="line-189"></a><span class='hs-comment'>--    bound and then executing the sub-expression.</span>
<a name="line-190"></a><span class='hs-comment'>--</span>
<a name="line-191"></a><span class='hs-comment'>--    #top_level_invariant#</span>
<a name="line-192"></a><span class='hs-comment'>--    #letrec_invariant#</span>
<a name="line-193"></a><span class='hs-comment'>--</span>
<a name="line-194"></a><span class='hs-comment'>--    The right hand sides of all top-level and recursive @let@s</span>
<a name="line-195"></a><span class='hs-comment'>--    /must/ be of lifted type (see "Type#type_classification" for</span>
<a name="line-196"></a><span class='hs-comment'>--    the meaning of /lifted/ vs. /unlifted/). There is one exception</span>
<a name="line-197"></a><span class='hs-comment'>--    to this rule, top-level @let@s are allowed to bind primitive</span>
<a name="line-198"></a><span class='hs-comment'>--    string literals, see Note [CoreSyn top-level string literals].</span>
<a name="line-199"></a><span class='hs-comment'>--</span>
<a name="line-200"></a><span class='hs-comment'>--    See Note [CoreSyn let/app invariant]</span>
<a name="line-201"></a><span class='hs-comment'>--    See Note [Levity polymorphism invariants]</span>
<a name="line-202"></a><span class='hs-comment'>--</span>
<a name="line-203"></a><span class='hs-comment'>--    #type_let#</span>
<a name="line-204"></a><span class='hs-comment'>--    We allow a /non-recursive/ let to bind a type variable, thus:</span>
<a name="line-205"></a><span class='hs-comment'>--</span>
<a name="line-206"></a><span class='hs-comment'>--    &gt; Let (NonRec tv (Type ty)) body</span>
<a name="line-207"></a><span class='hs-comment'>--</span>
<a name="line-208"></a><span class='hs-comment'>--    This can be very convenient for postponing type substitutions until</span>
<a name="line-209"></a><span class='hs-comment'>--    the next run of the simplifier.</span>
<a name="line-210"></a><span class='hs-comment'>--</span>
<a name="line-211"></a><span class='hs-comment'>--    At the moment, the rest of the compiler only deals with type-let</span>
<a name="line-212"></a><span class='hs-comment'>--    in a Let expression, rather than at top level.  We may want to revist</span>
<a name="line-213"></a><span class='hs-comment'>--    this choice.</span>
<a name="line-214"></a><span class='hs-comment'>--</span>
<a name="line-215"></a><span class='hs-comment'>-- *  Case expression. Operationally this corresponds to evaluating</span>
<a name="line-216"></a><span class='hs-comment'>--    the scrutinee (expression examined) to weak head normal form</span>
<a name="line-217"></a><span class='hs-comment'>--    and then examining at most one level of resulting constructor (i.e. you</span>
<a name="line-218"></a><span class='hs-comment'>--    cannot do nested pattern matching directly with this).</span>
<a name="line-219"></a><span class='hs-comment'>--</span>
<a name="line-220"></a><span class='hs-comment'>--    The binder gets bound to the value of the scrutinee,</span>
<a name="line-221"></a><span class='hs-comment'>--    and the 'Type' must be that of all the case alternatives</span>
<a name="line-222"></a><span class='hs-comment'>--</span>
<a name="line-223"></a><span class='hs-comment'>--    #case_invariants#</span>
<a name="line-224"></a><span class='hs-comment'>--    This is one of the more complicated elements of the Core language,</span>
<a name="line-225"></a><span class='hs-comment'>--    and comes with a number of restrictions:</span>
<a name="line-226"></a><span class='hs-comment'>--</span>
<a name="line-227"></a><span class='hs-comment'>--    1. The list of alternatives may be empty;</span>
<a name="line-228"></a><span class='hs-comment'>--       See Note [Empty case alternatives]</span>
<a name="line-229"></a><span class='hs-comment'>--</span>
<a name="line-230"></a><span class='hs-comment'>--    2. The 'DEFAULT' case alternative must be first in the list,</span>
<a name="line-231"></a><span class='hs-comment'>--       if it occurs at all.</span>
<a name="line-232"></a><span class='hs-comment'>--</span>
<a name="line-233"></a><span class='hs-comment'>--    3. The remaining cases are in order of increasing</span>
<a name="line-234"></a><span class='hs-comment'>--         tag  (for 'DataAlts') or</span>
<a name="line-235"></a><span class='hs-comment'>--         lit  (for 'LitAlts').</span>
<a name="line-236"></a><span class='hs-comment'>--       This makes finding the relevant constructor easy,</span>
<a name="line-237"></a><span class='hs-comment'>--       and makes comparison easier too.</span>
<a name="line-238"></a><span class='hs-comment'>--</span>
<a name="line-239"></a><span class='hs-comment'>--    4. The list of alternatives must be exhaustive. An /exhaustive/ case</span>
<a name="line-240"></a><span class='hs-comment'>--       does not necessarily mention all constructors:</span>
<a name="line-241"></a><span class='hs-comment'>--</span>
<a name="line-242"></a><span class='hs-comment'>--       @</span>
<a name="line-243"></a><span class='hs-comment'>--            data Foo = Red | Green | Blue</span>
<a name="line-244"></a><span class='hs-comment'>--       ... case x of</span>
<a name="line-245"></a><span class='hs-comment'>--            Red   -&gt; True</span>
<a name="line-246"></a><span class='hs-comment'>--            other -&gt; f (case x of</span>
<a name="line-247"></a><span class='hs-comment'>--                            Green -&gt; ...</span>
<a name="line-248"></a><span class='hs-comment'>--                            Blue  -&gt; ... ) ...</span>
<a name="line-249"></a><span class='hs-comment'>--       @</span>
<a name="line-250"></a><span class='hs-comment'>--</span>
<a name="line-251"></a><span class='hs-comment'>--       The inner case does not need a @Red@ alternative, because @x@</span>
<a name="line-252"></a><span class='hs-comment'>--       can't be @Red@ at that program point.</span>
<a name="line-253"></a><span class='hs-comment'>--</span>
<a name="line-254"></a><span class='hs-comment'>--    5. Floating-point values must not be scrutinised against literals.</span>
<a name="line-255"></a><span class='hs-comment'>--       See Trac #9238 and Note [Rules for floating-point comparisons]</span>
<a name="line-256"></a><span class='hs-comment'>--       in PrelRules for rationale.</span>
<a name="line-257"></a><span class='hs-comment'>--</span>
<a name="line-258"></a><span class='hs-comment'>-- *  Cast an expression to a particular type.</span>
<a name="line-259"></a><span class='hs-comment'>--    This is used to implement @newtype@s (a @newtype@ constructor or</span>
<a name="line-260"></a><span class='hs-comment'>--    destructor just becomes a 'Cast' in Core) and GADTs.</span>
<a name="line-261"></a><span class='hs-comment'>--</span>
<a name="line-262"></a><span class='hs-comment'>-- *  Notes. These allow general information to be added to expressions</span>
<a name="line-263"></a><span class='hs-comment'>--    in the syntax tree</span>
<a name="line-264"></a><span class='hs-comment'>--</span>
<a name="line-265"></a><span class='hs-comment'>-- *  A type: this should only show up at the top level of an Arg</span>
<a name="line-266"></a><span class='hs-comment'>--</span>
<a name="line-267"></a><span class='hs-comment'>-- *  A coercion</span>
<a name="line-268"></a>
<a name="line-269"></a><a name="Expr"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-270"></a><a name="Expr"></a><span class='hs-comment'>-- See Note [GHC Formalism] in coreSyn/CoreLint.hs</span>
<a name="line-271"></a><a name="Expr"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-272"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span>   <span class='hs-conid'>Id</span>
<a name="line-273"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Lit</span>   <span class='hs-conid'>Literal</span>
<a name="line-274"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>App</span>   <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-275"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Lam</span>   <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-276"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Let</span>   <span class='hs-layout'>(</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-277"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Case</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- See #case_invariants#</span>
<a name="line-278"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Cast</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-conid'>Coercion</span>
<a name="line-279"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Tick</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Tickish</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-280"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Type</span>  <span class='hs-conid'>Type</span>
<a name="line-281"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Coercion</span> <span class='hs-conid'>Coercion</span>
<a name="line-282"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-283"></a>
<a name="line-284"></a><a name="Arg"></a><span class='hs-comment'>-- | Type synonym for expressions that occur in function argument positions.</span>
<a name="line-285"></a><a name="Arg"></a><span class='hs-comment'>-- Only 'Arg' should contain a 'Type' at top level, general 'Expr' should not</span>
<a name="line-286"></a><a name="Arg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-287"></a>
<a name="line-288"></a><span class='hs-comment'>-- | A case split alternative. Consists of the constructor leading to the alternative,</span>
<a name="line-289"></a><span class='hs-comment'>-- the variables bound from the constructor, and the expression to be executed given that binding.</span>
<a name="line-290"></a><span class='hs-comment'>-- The default alternative is @(DEFAULT, [], rhs)@</span>
<a name="line-291"></a>
<a name="line-292"></a><a name="Alt"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-293"></a><a name="Alt"></a><span class='hs-comment'>-- See Note [GHC Formalism] in coreSyn/CoreLint.hs</span>
<a name="line-294"></a><a name="Alt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-295"></a>
<a name="line-296"></a><span class='hs-comment'>-- | A case alternative constructor (i.e. pattern match)</span>
<a name="line-297"></a>
<a name="line-298"></a><a name="AltCon"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-299"></a><a name="AltCon"></a><span class='hs-comment'>-- See Note [GHC Formalism] in coreSyn/CoreLint.hs</span>
<a name="line-300"></a><a name="AltCon"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AltCon</span>
<a name="line-301"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DataAlt</span> <span class='hs-conid'>DataCon</span>   <span class='hs-comment'>--  ^ A plain data constructor: @case e of { Foo x -&gt; ... }@.</span>
<a name="line-302"></a>                      <span class='hs-comment'>-- Invariant: the 'DataCon' is always from a @data@ type, and never from a @newtype@</span>
<a name="line-303"></a>
<a name="line-304"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LitAlt</span>  <span class='hs-conid'>Literal</span>   <span class='hs-comment'>-- ^ A literal: @case e of { 1 -&gt; ... }@</span>
<a name="line-305"></a>                      <span class='hs-comment'>-- Invariant: always an *unlifted* literal</span>
<a name="line-306"></a>                      <span class='hs-comment'>-- See Note [Literal alternatives]</span>
<a name="line-307"></a>
<a name="line-308"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DEFAULT</span>           <span class='hs-comment'>-- ^ Trivial alternative: @case e of { _ -&gt; ... }@</span>
<a name="line-309"></a>   <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
<a name="line-310"></a>
<a name="line-311"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-comment'>-- This instance is a bit shady. It can only be used to compare AltCons for</span>
<a name="line-312"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-comment'>-- a single type constructor. Fortunately, it seems quite unlikely that we'll</span>
<a name="line-313"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-comment'>-- ever need to compare AltCons for different type constructors.</span>
<a name="line-314"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyword'>where</span>
<a name="line-315"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-316"></a>    <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>con1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>con2</span> <span class='hs-layout'>)</span>
<a name="line-317"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTag</span> <span class='hs-varid'>con1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTag</span> <span class='hs-varid'>con2</span><span class='hs-layout'>)</span>
<a name="line-318"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-319"></a>  <span class='hs-varid'>compare</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-320"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span>
<a name="line-321"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-322"></a>  <span class='hs-varid'>compare</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-323"></a>  <span class='hs-varid'>compare</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-324"></a>
<a name="line-325"></a><span class='hs-comment'>-- | Binding, used for top level bindings in a module and local bindings in a @let@.</span>
<a name="line-326"></a>
<a name="line-327"></a><a name="Bind"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-328"></a><a name="Bind"></a><span class='hs-comment'>-- See Note [GHC Formalism] in coreSyn/CoreLint.hs</span>
<a name="line-329"></a><a name="Bind"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-330"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Rec</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-331"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-332"></a>
<a name="line-333"></a><span class='hs-comment'>{-
<a name="line-334"></a>Note [Shadowing]
<a name="line-335"></a>~~~~~~~~~~~~~~~~
<a name="line-336"></a>While various passes attempt to rename on-the-fly in a manner that
<a name="line-337"></a>avoids "shadowing" (thereby simplifying downstream optimizations),
<a name="line-338"></a>neither the simplifier nor any other pass GUARANTEES that shadowing is
<a name="line-339"></a>avoided. Thus, all passes SHOULD work fine even in the presence of
<a name="line-340"></a>arbitrary shadowing in their inputs.
<a name="line-341"></a>
<a name="line-342"></a>In particular, scrutinee variables `x` in expressions of the form
<a name="line-343"></a>`Case e x t` are often renamed to variables with a prefix
<a name="line-344"></a>"wild_". These "wild" variables may appear in the body of the
<a name="line-345"></a>case-expression, and further, may be shadowed within the body.
<a name="line-346"></a>
<a name="line-347"></a>So the Unique in an Var is not really unique at all.  Still, it's very
<a name="line-348"></a>useful to give a constant-time equality/ordering for Vars, and to give
<a name="line-349"></a>a key that can be used to make sets of Vars (VarSet), or mappings from
<a name="line-350"></a>Vars to other things (VarEnv).   Moreover, if you do want to eliminate
<a name="line-351"></a>shadowing, you can give a new Unique to an Id without changing its
<a name="line-352"></a>printable name, which makes debugging easier.
<a name="line-353"></a>
<a name="line-354"></a>Note [Literal alternatives]
<a name="line-355"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-356"></a>Literal alternatives (LitAlt lit) are always for *un-lifted* literals.
<a name="line-357"></a>We have one literal, a literal Integer, that is lifted, and we don't
<a name="line-358"></a>allow in a LitAlt, because LitAlt cases don't do any evaluation. Also
<a name="line-359"></a>(see Trac #5603) if you say
<a name="line-360"></a>    case 3 of
<a name="line-361"></a>      S# x -&gt; ...
<a name="line-362"></a>      J# _ _ -&gt; ...
<a name="line-363"></a>(where S#, J# are the constructors for Integer) we don't want the
<a name="line-364"></a>simplifier calling findAlt with argument (LitAlt 3).  No no.  Integer
<a name="line-365"></a>literals are an opaque encoding of an algebraic data type, not of
<a name="line-366"></a>an unlifted literal, like all the others.
<a name="line-367"></a>
<a name="line-368"></a>Also, we do not permit case analysis with literal patterns on floating-point
<a name="line-369"></a>types. See Trac #9238 and Note [Rules for floating-point comparisons] in
<a name="line-370"></a>PrelRules for the rationale for this restriction.
<a name="line-371"></a>
<a name="line-372"></a>-------------------------- CoreSyn INVARIANTS ---------------------------
<a name="line-373"></a>
<a name="line-374"></a>Note [CoreSyn top-level invariant]
<a name="line-375"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-376"></a>See #toplevel_invariant#
<a name="line-377"></a>
<a name="line-378"></a>Note [CoreSyn letrec invariant]
<a name="line-379"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-380"></a>See #letrec_invariant#
<a name="line-381"></a>
<a name="line-382"></a>Note [CoreSyn top-level string literals]
<a name="line-383"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-384"></a>As an exception to the usual rule that top-level binders must be lifted,
<a name="line-385"></a>we allow binding primitive string literals (of type Addr#) of type Addr# at the
<a name="line-386"></a>top level. This allows us to share string literals earlier in the pipeline and
<a name="line-387"></a>crucially allows other optimizations in the Core2Core pipeline to fire.
<a name="line-388"></a>Consider,
<a name="line-389"></a>
<a name="line-390"></a>  f n = let a::Addr# = "foo"#
<a name="line-391"></a>        in \x -&gt; blah
<a name="line-392"></a>
<a name="line-393"></a>In order to be able to inline `f`, we would like to float `a` to the top.
<a name="line-394"></a>Another option would be to inline `a`, but that would lead to duplicating string
<a name="line-395"></a>literals, which we want to avoid. See Trac #8472.
<a name="line-396"></a>
<a name="line-397"></a>The solution is simply to allow top-level unlifted binders. We can't allow
<a name="line-398"></a>arbitrary unlifted expression at the top-level though, unlifted binders cannot
<a name="line-399"></a>be thunks, so we just allow string literals.
<a name="line-400"></a>
<a name="line-401"></a>It is important to note that top-level primitive string literals cannot be
<a name="line-402"></a>wrapped in Ticks, as is otherwise done with lifted bindings. CoreToStg expects
<a name="line-403"></a>to see just a plain (Lit (MachStr ...)) expression on the RHS of primitive
<a name="line-404"></a>string bindings; anything else and things break. CoreLint checks this invariant.
<a name="line-405"></a>
<a name="line-406"></a>Also see Note [Compilation plan for top-level string literals].
<a name="line-407"></a>
<a name="line-408"></a>Note [Compilation plan for top-level string literals]
<a name="line-409"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-410"></a>Here is a summary on how top-level string literals are handled by various
<a name="line-411"></a>parts of the compilation pipeline.
<a name="line-412"></a>
<a name="line-413"></a>* In the source language, there is no way to bind a primitive string literal
<a name="line-414"></a>  at the top leve.
<a name="line-415"></a>
<a name="line-416"></a>* In Core, we have a special rule that permits top-level Addr# bindings. See
<a name="line-417"></a>  Note [CoreSyn top-level string literals]. Core-to-core passes may introduce
<a name="line-418"></a>  new top-level string literals.
<a name="line-419"></a>
<a name="line-420"></a>* In STG, top-level string literals are explicitly represented in the syntax
<a name="line-421"></a>  tree.
<a name="line-422"></a>
<a name="line-423"></a>* A top-level string literal may end up exported from a module. In this case,
<a name="line-424"></a>  in the object file, the content of the exported literal is given a label with
<a name="line-425"></a>  the _bytes suffix.
<a name="line-426"></a>
<a name="line-427"></a>Note [CoreSyn let/app invariant]
<a name="line-428"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-429"></a>The let/app invariant
<a name="line-430"></a>     the right hand side of a non-recursive 'Let', and
<a name="line-431"></a>     the argument of an 'App',
<a name="line-432"></a>    /may/ be of unlifted type, but only if
<a name="line-433"></a>    the expression is ok-for-speculation
<a name="line-434"></a>    or the 'Let' is for a join point.
<a name="line-435"></a>
<a name="line-436"></a>This means that the let can be floated around
<a name="line-437"></a>without difficulty. For example, this is OK:
<a name="line-438"></a>
<a name="line-439"></a>   y::Int# = x +# 1#
<a name="line-440"></a>
<a name="line-441"></a>But this is not, as it may affect termination if the
<a name="line-442"></a>expression is floated out:
<a name="line-443"></a>
<a name="line-444"></a>   y::Int# = fac 4#
<a name="line-445"></a>
<a name="line-446"></a>In this situation you should use @case@ rather than a @let@. The function
<a name="line-447"></a>'CoreUtils.needsCaseBinding' can help you determine which to generate, or
<a name="line-448"></a>alternatively use 'MkCore.mkCoreLet' rather than this constructor directly,
<a name="line-449"></a>which will generate a @case@ if necessary
<a name="line-450"></a>
<a name="line-451"></a>The let/app invariant is initially enforced by mkCoreLet and mkCoreApp in
<a name="line-452"></a>coreSyn/MkCore.
<a name="line-453"></a>
<a name="line-454"></a>Note [CoreSyn case invariants]
<a name="line-455"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-456"></a>See #case_invariants#
<a name="line-457"></a>
<a name="line-458"></a>Note [Levity polymorphism invariants]
<a name="line-459"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-460"></a>The levity-polymorphism invariants are these (as per "Levity Polymorphism",
<a name="line-461"></a>PLDI '17):
<a name="line-462"></a>
<a name="line-463"></a>* The type of a term-binder must not be levity-polymorphic,
<a name="line-464"></a>  unless it is a let(rec)-bound join point
<a name="line-465"></a>     (see Note [Invariants on join points])
<a name="line-466"></a>
<a name="line-467"></a>* The type of the argument of an App must not be levity-polymorphic.
<a name="line-468"></a>
<a name="line-469"></a>A type (t::TYPE r) is "levity polymorphic" if 'r' has any free variables.
<a name="line-470"></a>
<a name="line-471"></a>For example
<a name="line-472"></a>  \(r::RuntimeRep). \(a::TYPE r). \(x::a). e
<a name="line-473"></a>is illegal because x's type has kind (TYPE r), which has 'r' free.
<a name="line-474"></a>
<a name="line-475"></a>See Note [Levity polymorphism checking] in DsMonad to see where these
<a name="line-476"></a>invariants are established for user-written code.
<a name="line-477"></a>
<a name="line-478"></a>Note [CoreSyn let goal]
<a name="line-479"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-480"></a>* The simplifier tries to ensure that if the RHS of a let is a constructor
<a name="line-481"></a>  application, its arguments are trivial, so that the constructor can be
<a name="line-482"></a>  inlined vigorously.
<a name="line-483"></a>
<a name="line-484"></a>Note [Type let]
<a name="line-485"></a>~~~~~~~~~~~~~~~
<a name="line-486"></a>See #type_let#
<a name="line-487"></a>
<a name="line-488"></a>Note [Empty case alternatives]
<a name="line-489"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-490"></a>The alternatives of a case expression should be exhaustive.  But
<a name="line-491"></a>this exhaustive list can be empty!
<a name="line-492"></a>
<a name="line-493"></a>* A case expression can have empty alternatives if (and only if) the
<a name="line-494"></a>  scrutinee is bound to raise an exception or diverge. When do we know
<a name="line-495"></a>  this?  See Note [Bottoming expressions] in CoreUtils.
<a name="line-496"></a>
<a name="line-497"></a>* The possiblity of empty alternatives is one reason we need a type on
<a name="line-498"></a>  the case expression: if the alternatives are empty we can't get the
<a name="line-499"></a>  type from the alternatives!
<a name="line-500"></a>
<a name="line-501"></a>* In the case of empty types (see Note [Bottoming expressions]), say
<a name="line-502"></a>    data T
<a name="line-503"></a>  we do NOT want to replace
<a name="line-504"></a>    case (x::T) of Bool {}   --&gt;   error Bool "Inaccessible case"
<a name="line-505"></a>  because x might raise an exception, and *that*'s what we want to see!
<a name="line-506"></a>  (Trac #6067 is an example.) To preserve semantics we'd have to say
<a name="line-507"></a>     x `seq` error Bool "Inaccessible case"
<a name="line-508"></a>  but the 'seq' is just a case, so we are back to square 1.  Or I suppose
<a name="line-509"></a>  we could say
<a name="line-510"></a>     x |&gt; UnsafeCoerce T Bool
<a name="line-511"></a>  but that loses all trace of the fact that this originated with an empty
<a name="line-512"></a>  set of alternatives.
<a name="line-513"></a>
<a name="line-514"></a>* We can use the empty-alternative construct to coerce error values from
<a name="line-515"></a>  one type to another.  For example
<a name="line-516"></a>
<a name="line-517"></a>    f :: Int -&gt; Int
<a name="line-518"></a>    f n = error "urk"
<a name="line-519"></a>
<a name="line-520"></a>    g :: Int -&gt; (# Char, Bool #)
<a name="line-521"></a>    g x = case f x of { 0 -&gt; ..., n -&gt; ... }
<a name="line-522"></a>
<a name="line-523"></a>  Then if we inline f in g's RHS we get
<a name="line-524"></a>    case (error Int "urk") of (# Char, Bool #) { ... }
<a name="line-525"></a>  and we can discard the alternatives since the scrutinee is bottom to give
<a name="line-526"></a>    case (error Int "urk") of (# Char, Bool #) {}
<a name="line-527"></a>
<a name="line-528"></a>  This is nicer than using an unsafe coerce between Int ~ (# Char,Bool #),
<a name="line-529"></a>  if for no other reason that we don't need to instantiate the (~) at an
<a name="line-530"></a>  unboxed type.
<a name="line-531"></a>
<a name="line-532"></a>* We treat a case expression with empty alternatives as trivial iff
<a name="line-533"></a>  its scrutinee is (see CoreUtils.exprIsTrivial).  This is actually
<a name="line-534"></a>  important; see Note [Empty case is trivial] in CoreUtils
<a name="line-535"></a>
<a name="line-536"></a>* An empty case is replaced by its scrutinee during the CoreToStg
<a name="line-537"></a>  conversion; remember STG is un-typed, so there is no need for
<a name="line-538"></a>  the empty case to do the type conversion.
<a name="line-539"></a>
<a name="line-540"></a>Note [Join points]
<a name="line-541"></a>~~~~~~~~~~~~~~~~~~
<a name="line-542"></a>In Core, a *join point* is a specially tagged function whose only occurrences
<a name="line-543"></a>are saturated tail calls. A tail call can appear in these places:
<a name="line-544"></a>
<a name="line-545"></a>  1. In the branches (not the scrutinee) of a case
<a name="line-546"></a>  2. Underneath a let (value or join point)
<a name="line-547"></a>  3. Inside another join point
<a name="line-548"></a>
<a name="line-549"></a>We write a join-point declaration as
<a name="line-550"></a>  join j @a @b x y = e1 in e2,
<a name="line-551"></a>like a let binding but with "join" instead (or "join rec" for "let rec"). Note
<a name="line-552"></a>that we put the parameters before the = rather than using lambdas; this is
<a name="line-553"></a>because it's relevant how many parameters the join point takes *as a join
<a name="line-554"></a>point.* This number is called the *join arity,* distinct from arity because it
<a name="line-555"></a>counts types as well as values. Note that a join point may return a lambda! So
<a name="line-556"></a>  join j x = x + 1
<a name="line-557"></a>is different from
<a name="line-558"></a>  join j = \x -&gt; x + 1
<a name="line-559"></a>The former has join arity 1, while the latter has join arity 0.
<a name="line-560"></a>
<a name="line-561"></a>The identifier for a join point is called a join id or a *label.* An invocation
<a name="line-562"></a>is called a *jump.* We write a jump using the jump keyword:
<a name="line-563"></a>
<a name="line-564"></a>  jump j 3
<a name="line-565"></a>
<a name="line-566"></a>The words *label* and *jump* are evocative of assembly code (or Cmm) for a
<a name="line-567"></a>reason: join points are indeed compiled as labeled blocks, and jumps become
<a name="line-568"></a>actual jumps (plus argument passing and stack adjustment). There is no closure
<a name="line-569"></a>allocated and only a fraction of the function-call overhead. Hence we would
<a name="line-570"></a>like as many functions as possible to become join points (see OccurAnal) and
<a name="line-571"></a>the type rules for join points ensure we preserve the properties that make them
<a name="line-572"></a>efficient.
<a name="line-573"></a>
<a name="line-574"></a>In the actual AST, a join point is indicated by the IdDetails of the binder: a
<a name="line-575"></a>local value binding gets 'VanillaId' but a join point gets a 'JoinId' with its
<a name="line-576"></a>join arity.
<a name="line-577"></a>
<a name="line-578"></a>For more details, see the paper:
<a name="line-579"></a>
<a name="line-580"></a>  Luke Maurer, Paul Downen, Zena Ariola, and Simon Peyton Jones. "Compiling
<a name="line-581"></a>  without continuations." Submitted to PLDI'17.
<a name="line-582"></a>
<a name="line-583"></a>  https://www.microsoft.com/en-us/research/publication/compiling-without-continuations/
<a name="line-584"></a>
<a name="line-585"></a>Note [Invariants on join points]
<a name="line-586"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-587"></a>Join points must follow these invariants:
<a name="line-588"></a>
<a name="line-589"></a>  1. All occurrences must be tail calls. Each of these tail calls must pass the
<a name="line-590"></a>     same number of arguments, counting both types and values; we call this the
<a name="line-591"></a>     "join arity" (to distinguish from regular arity, which only counts values).
<a name="line-592"></a>
<a name="line-593"></a>  2. For join arity n, the right-hand side must begin with at least n lambdas.
<a name="line-594"></a>     No ticks, no casts, just lambdas!  C.f. CoreUtils.joinRhsArity.
<a name="line-595"></a>
<a name="line-596"></a>  2a. Moreover, this same constraint applies to any unfolding of the binder.
<a name="line-597"></a>     Reason: if we want to push a continuation into the RHS we must push it
<a name="line-598"></a>     into the unfolding as well.
<a name="line-599"></a>
<a name="line-600"></a>  3. If the binding is recursive, then all other bindings in the recursive group
<a name="line-601"></a>     must also be join points.
<a name="line-602"></a>
<a name="line-603"></a>  4. The binding's type must not be polymorphic in its return type (as defined
<a name="line-604"></a>     in Note [The polymorphism rule of join points]).
<a name="line-605"></a>
<a name="line-606"></a>However, join points have simpler invariants in other ways
<a name="line-607"></a>
<a name="line-608"></a>  5. A join point can have an unboxed type without the RHS being
<a name="line-609"></a>     ok-for-speculation (i.e. drop the let/app invariant)
<a name="line-610"></a>     e.g.  let j :: Int# = factorial x in ...
<a name="line-611"></a>
<a name="line-612"></a>  6. A join point can have a levity-polymorphic RHS
<a name="line-613"></a>     e.g.  let j :: r :: TYPE l = fail void# in ...
<a name="line-614"></a>     This happened in an intermediate program Trac #13394
<a name="line-615"></a>
<a name="line-616"></a>Examples:
<a name="line-617"></a>
<a name="line-618"></a>  join j1  x = 1 + x in jump j (jump j x)  -- Fails 1: non-tail call
<a name="line-619"></a>  join j1' x = 1 + x in if even a
<a name="line-620"></a>                          then jump j1 a
<a name="line-621"></a>                          else jump j1 a b -- Fails 1: inconsistent calls
<a name="line-622"></a>  join j2  x = flip (+) x in j2 1 2        -- Fails 2: not enough lambdas
<a name="line-623"></a>  join j2' x = \y -&gt; x + y in j3 1         -- Passes: extra lams ok
<a name="line-624"></a>  join j @a (x :: a) = x                   -- Fails 4: polymorphic in ret type
<a name="line-625"></a>
<a name="line-626"></a>Invariant 1 applies to left-hand sides of rewrite rules, so a rule for a join
<a name="line-627"></a>point must have an exact call as its LHS.
<a name="line-628"></a>
<a name="line-629"></a>Strictly speaking, invariant 3 is redundant, since a call from inside a lazy
<a name="line-630"></a>binding isn't a tail call. Since a let-bound value can't invoke a free join
<a name="line-631"></a>point, then, they can't be mutually recursive. (A Core binding group *can*
<a name="line-632"></a>include spurious extra bindings if the occurrence analyser hasn't run, so
<a name="line-633"></a>invariant 3 does still need to be checked.) For the rigorous definition of
<a name="line-634"></a>"tail call", see Section 3 of the paper (Note [Join points]).
<a name="line-635"></a>
<a name="line-636"></a>Invariant 4 is subtle; see Note [The polymorphism rule of join points].
<a name="line-637"></a>
<a name="line-638"></a>Core Lint will check these invariants, anticipating that any binder whose
<a name="line-639"></a>OccInfo is marked AlwaysTailCalled will become a join point as soon as the
<a name="line-640"></a>simplifier (or simpleOptPgm) runs.
<a name="line-641"></a>
<a name="line-642"></a>Note [The type of a join point]
<a name="line-643"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-644"></a>A join point has the same type it would have as a function. That is, if it takes
<a name="line-645"></a>an Int and a Bool and its body produces a String, its type is `Int -&gt; Bool -&gt;
<a name="line-646"></a>String`. Natural as this may seem, it can be awkward. A join point shouldn't be
<a name="line-647"></a>thought to "return" in the same sense a function does---a jump is one-way. This
<a name="line-648"></a>is crucial for understanding how case-of-case interacts with join points:
<a name="line-649"></a>
<a name="line-650"></a>  case (join
<a name="line-651"></a>          j :: Int -&gt; Bool -&gt; String
<a name="line-652"></a>          j x y = ...
<a name="line-653"></a>        in
<a name="line-654"></a>          jump j z w) of
<a name="line-655"></a>    "" -&gt; True
<a name="line-656"></a>    _  -&gt; False
<a name="line-657"></a>
<a name="line-658"></a>The simplifier will pull the case into the join point (see Note [Case-of-case
<a name="line-659"></a>and join points] in Simplify):
<a name="line-660"></a>
<a name="line-661"></a>  join
<a name="line-662"></a>    j :: Int -&gt; Bool -&gt; Bool -- changed!
<a name="line-663"></a>    j x y = case ... of "" -&gt; True
<a name="line-664"></a>                        _  -&gt; False
<a name="line-665"></a>  in
<a name="line-666"></a>    jump j z w
<a name="line-667"></a>
<a name="line-668"></a>The body of the join point now returns a Bool, so the label `j` has to have its
<a name="line-669"></a>type updated accordingly. Inconvenient though this may be, it has the advantage
<a name="line-670"></a>that 'CoreUtils.exprType' can still return a type for any expression, including
<a name="line-671"></a>a jump.
<a name="line-672"></a>
<a name="line-673"></a>This differs from the paper (see Note [Invariants on join points]). In the
<a name="line-674"></a>paper, we instead give j the type `Int -&gt; Bool -&gt; forall a. a`. Then each jump
<a name="line-675"></a>carries the "return type" as a parameter, exactly the way other non-returning
<a name="line-676"></a>functions like `error` work:
<a name="line-677"></a>
<a name="line-678"></a>  case (join
<a name="line-679"></a>          j :: Int -&gt; Bool -&gt; forall a. a
<a name="line-680"></a>          j x y = ...
<a name="line-681"></a>        in
<a name="line-682"></a>          jump j z w @String) of
<a name="line-683"></a>    "" -&gt; True
<a name="line-684"></a>    _  -&gt; False
<a name="line-685"></a>
<a name="line-686"></a>Now we can move the case inward and we only have to change the jump:
<a name="line-687"></a>
<a name="line-688"></a>  join
<a name="line-689"></a>    j :: Int -&gt; Bool -&gt; forall a. a
<a name="line-690"></a>    j x y = case ... of "" -&gt; True
<a name="line-691"></a>                        _  -&gt; False
<a name="line-692"></a>  in
<a name="line-693"></a>    jump j z w @Bool
<a name="line-694"></a>
<a name="line-695"></a>(Core Lint would still check that the body of the join point has the right type;
<a name="line-696"></a>that type would simply not be reflected in the join id.)
<a name="line-697"></a>
<a name="line-698"></a>Note [The polymorphism rule of join points]
<a name="line-699"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-700"></a>Invariant 4 of Note [Invariants on join points] forbids a join point to be
<a name="line-701"></a>polymorphic in its return type. That is, if its type is
<a name="line-702"></a>
<a name="line-703"></a>  forall a1 ... ak. t1 -&gt; ... -&gt; tn -&gt; r
<a name="line-704"></a>
<a name="line-705"></a>where its join arity is k+n, none of the type parameters ai may occur free in r.
<a name="line-706"></a>The most direct explanation is that given
<a name="line-707"></a>
<a name="line-708"></a>  join j @a1 ... @ak x1 ... xn = e1 in e2
<a name="line-709"></a>
<a name="line-710"></a>our typing rules require `e1` and `e2` to have the same type. Therefore the type
<a name="line-711"></a>of `e1`---the return type of the join point---must be the same as the type of
<a name="line-712"></a>e2. Since the type variables aren't bound in `e2`, its type can't include them,
<a name="line-713"></a>and thus neither can the type of `e1`.
<a name="line-714"></a>
<a name="line-715"></a>There's a deeper explanation in terms of the sequent calculus in Section 5.3 of
<a name="line-716"></a>a previous paper:
<a name="line-717"></a>
<a name="line-718"></a>  Paul Downen, Luke Maurer, Zena Ariola, and Simon Peyton Jones. "Sequent
<a name="line-719"></a>  calculus as a compiler intermediate language." ICFP'16.
<a name="line-720"></a>
<a name="line-721"></a>  https://www.microsoft.com/en-us/research/wp-content/uploads/2016/04/sequent-calculus-icfp16.pdf
<a name="line-722"></a>
<a name="line-723"></a>The quick version: Consider the CPS term (the paper uses the sequent calculus,
<a name="line-724"></a>but we can translate readily):
<a name="line-725"></a>
<a name="line-726"></a>  \k -&gt; join j @a1 ... @ak x1 ... xn = e1 k in e2 k
<a name="line-727"></a>
<a name="line-728"></a>Since `j` is a join point, it doesn't bind a continuation variable but reuses
<a name="line-729"></a>the variable `k` from the context. But the parameters `ai` are not in `k`'s
<a name="line-730"></a>scope, and `k`'s type determines the return type of `j`; thus the `ai`s don't
<a name="line-731"></a>appear in the return type of `j`. (Also, since `e1` and `e2` are passed the same
<a name="line-732"></a>continuation, they must have the same type; hence the direct explanation above.)
<a name="line-733"></a>
<a name="line-734"></a>************************************************************************
<a name="line-735"></a>*                                                                      *
<a name="line-736"></a>            In/Out type synonyms
<a name="line-737"></a>*                                                                      *
<a name="line-738"></a>********************************************************************* -}</span>
<a name="line-739"></a>
<a name="line-740"></a><span class='hs-comment'>{- Many passes apply a substitution, and it's very handy to have type
<a name="line-741"></a>   synonyms to remind us whether or not the substitution has been applied -}</span>
<a name="line-742"></a>
<a name="line-743"></a><a name="InBndr"></a><span class='hs-comment'>-- Pre-cloning or substitution</span>
<a name="line-744"></a><a name="InBndr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InBndr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-745"></a><a name="InType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InType</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-746"></a><a name="InKind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InKind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Kind</span>
<a name="line-747"></a><a name="InBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InBind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBind</span>
<a name="line-748"></a><a name="InExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InExpr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-749"></a><a name="InAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InAlt</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreAlt</span>
<a name="line-750"></a><a name="InArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InArg</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreArg</span>
<a name="line-751"></a><a name="InCoercion"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InCoercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span>
<a name="line-752"></a>
<a name="line-753"></a><a name="OutBndr"></a><span class='hs-comment'>-- Post-cloning or substitution</span>
<a name="line-754"></a><a name="OutBndr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutBndr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-755"></a><a name="OutType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutType</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-756"></a><a name="OutKind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutKind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Kind</span>
<a name="line-757"></a><a name="OutCoercion"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutCoercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span>
<a name="line-758"></a><a name="OutBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutBind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBind</span>
<a name="line-759"></a><a name="OutExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutExpr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-760"></a><a name="OutAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutAlt</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreAlt</span>
<a name="line-761"></a><a name="OutArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutArg</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreArg</span>
<a name="line-762"></a>
<a name="line-763"></a>
<a name="line-764"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-765"></a>*                                                                      *
<a name="line-766"></a>              Ticks
<a name="line-767"></a>*                                                                      *
<a name="line-768"></a>************************************************************************
<a name="line-769"></a>-}</span>
<a name="line-770"></a>
<a name="line-771"></a><span class='hs-comment'>-- | Allows attaching extra information to points in expressions</span>
<a name="line-772"></a>
<a name="line-773"></a><a name="Tickish"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-774"></a><a name="Tickish"></a><span class='hs-comment'>-- See Note [GHC Formalism] in coreSyn/CoreLint.hs</span>
<a name="line-775"></a><a name="Tickish"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span>
<a name="line-776"></a>    <span class='hs-comment'>-- | An @{-# SCC #-}@ profiling annotation, either automatically</span>
<a name="line-777"></a>    <span class='hs-comment'>-- added by the desugarer as a result of -auto-all, or added by</span>
<a name="line-778"></a>    <span class='hs-comment'>-- the user.</span>
<a name="line-779"></a>    <span class='hs-conid'>ProfNote</span> <span class='hs-layout'>{</span>
<a name="line-780"></a>      <span class='hs-varid'>profNoteCC</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CostCentre</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- ^ the cost centre</span>
<a name="line-781"></a>      <span class='hs-varid'>profNoteCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- ^ bump the entry count?</span>
<a name="line-782"></a>      <span class='hs-varid'>profNoteScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>       <span class='hs-comment'>-- ^ scopes over the enclosed expression</span>
<a name="line-783"></a>                                   <span class='hs-comment'>-- (i.e. not just a tick)</span>
<a name="line-784"></a>    <span class='hs-layout'>}</span>
<a name="line-785"></a>
<a name="line-786"></a>  <span class='hs-comment'>-- | A "tick" used by HPC to track the execution of each</span>
<a name="line-787"></a>  <span class='hs-comment'>-- subexpression in the original source code.</span>
<a name="line-788"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HpcTick</span> <span class='hs-layout'>{</span>
<a name="line-789"></a>      <span class='hs-varid'>tickModule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Module</span><span class='hs-layout'>,</span>
<a name="line-790"></a>      <span class='hs-varid'>tickId</span>     <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-791"></a>    <span class='hs-layout'>}</span>
<a name="line-792"></a>
<a name="line-793"></a>  <span class='hs-comment'>-- | A breakpoint for the GHCi debugger.  This behaves like an HPC</span>
<a name="line-794"></a>  <span class='hs-comment'>-- tick, but has a list of free variables which will be available</span>
<a name="line-795"></a>  <span class='hs-comment'>-- for inspection in GHCi when the program stops at the breakpoint.</span>
<a name="line-796"></a>  <span class='hs-comment'>--</span>
<a name="line-797"></a>  <span class='hs-comment'>-- NB. we must take account of these Ids when (a) counting free variables,</span>
<a name="line-798"></a>  <span class='hs-comment'>-- and (b) substituting (don't substitute for them)</span>
<a name="line-799"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Breakpoint</span>
<a name="line-800"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>breakpointId</span>     <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-801"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>breakpointFVs</span>    <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>id</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- ^ the order of this list is important:</span>
<a name="line-802"></a>                                <span class='hs-comment'>-- it matches the order of the lists in the</span>
<a name="line-803"></a>                                <span class='hs-comment'>-- appropriate entry in HscTypes.ModBreaks.</span>
<a name="line-804"></a>                                <span class='hs-comment'>--</span>
<a name="line-805"></a>                                <span class='hs-comment'>-- Careful about substitution!  See</span>
<a name="line-806"></a>                                <span class='hs-comment'>-- Note [substTickish] in CoreSubst.</span>
<a name="line-807"></a>    <span class='hs-layout'>}</span>
<a name="line-808"></a>
<a name="line-809"></a>  <span class='hs-comment'>-- | A source note.</span>
<a name="line-810"></a>  <span class='hs-comment'>--</span>
<a name="line-811"></a>  <span class='hs-comment'>-- Source notes are pure annotations: Their presence should neither</span>
<a name="line-812"></a>  <span class='hs-comment'>-- influence compilation nor execution. The semantics are given by</span>
<a name="line-813"></a>  <span class='hs-comment'>-- causality: The presence of a source note means that a local</span>
<a name="line-814"></a>  <span class='hs-comment'>-- change in the referenced source code span will possibly provoke</span>
<a name="line-815"></a>  <span class='hs-comment'>-- the generated code to change. On the flip-side, the functionality</span>
<a name="line-816"></a>  <span class='hs-comment'>-- of annotated code *must* be invariant against changes to all</span>
<a name="line-817"></a>  <span class='hs-comment'>-- source code *except* the spans referenced in the source notes</span>
<a name="line-818"></a>  <span class='hs-comment'>-- (see "Causality of optimized Haskell" paper for details).</span>
<a name="line-819"></a>  <span class='hs-comment'>--</span>
<a name="line-820"></a>  <span class='hs-comment'>-- Therefore extending the scope of any given source note is always</span>
<a name="line-821"></a>  <span class='hs-comment'>-- valid. Note that it is still undesirable though, as this reduces</span>
<a name="line-822"></a>  <span class='hs-comment'>-- their usefulness for debugging and profiling. Therefore we will</span>
<a name="line-823"></a>  <span class='hs-comment'>-- generally try only to make use of this property where it is</span>
<a name="line-824"></a>  <span class='hs-comment'>-- necessary to enable optimizations.</span>
<a name="line-825"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SourceNote</span>
<a name="line-826"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>sourceSpan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RealSrcSpan</span> <span class='hs-comment'>-- ^ Source covered</span>
<a name="line-827"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>sourceName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span>      <span class='hs-comment'>-- ^ Name for source location</span>
<a name="line-828"></a>                                <span class='hs-comment'>--   (uses same names as CCs)</span>
<a name="line-829"></a>    <span class='hs-layout'>}</span>
<a name="line-830"></a>
<a name="line-831"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span><span class='hs-layout'>,</span> <span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
<a name="line-832"></a>
<a name="line-833"></a><a name="tickishCounts"></a><span class='hs-comment'>-- | A "counting tick" (where tickishCounts is True) is one that</span>
<a name="line-834"></a><span class='hs-comment'>-- counts evaluations in some way.  We cannot discard a counting tick,</span>
<a name="line-835"></a><span class='hs-comment'>-- and the compiler should preserve the number of counting ticks as</span>
<a name="line-836"></a><span class='hs-comment'>-- far as possible.</span>
<a name="line-837"></a><span class='hs-comment'>--</span>
<a name="line-838"></a><span class='hs-comment'>-- However, we still allow the simplifier to increase or decrease</span>
<a name="line-839"></a><span class='hs-comment'>-- sharing, so in practice the actual number of ticks may vary, except</span>
<a name="line-840"></a><span class='hs-comment'>-- that we never change the value from zero to non-zero or vice versa.</span>
<a name="line-841"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-842"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>profNoteCount</span> <span class='hs-varid'>n</span>
<a name="line-843"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-conid'>HpcTick</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-844"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-conid'>Breakpoint</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-845"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-keyword'>_</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-846"></a>
<a name="line-847"></a>
<a name="line-848"></a><a name="TickishScoping"></a><span class='hs-comment'>-- | Specifies the scoping behaviour of ticks. This governs the</span>
<a name="line-849"></a><a name="TickishScoping"></a><span class='hs-comment'>-- behaviour of ticks that care about the covered code and the cost</span>
<a name="line-850"></a><a name="TickishScoping"></a><span class='hs-comment'>-- associated with it. Important for ticks relating to profiling.</span>
<a name="line-851"></a><a name="TickishScoping"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TickishScoping</span> <span class='hs-keyglyph'>=</span>
<a name="line-852"></a>    <span class='hs-comment'>-- | No scoping: The tick does not care about what code it</span>
<a name="line-853"></a>    <span class='hs-comment'>-- covers. Transformations can freely move code inside as well as</span>
<a name="line-854"></a>    <span class='hs-comment'>-- outside without any additional annotation obligations</span>
<a name="line-855"></a>    <span class='hs-conid'>NoScope</span>
<a name="line-856"></a>
<a name="line-857"></a>    <span class='hs-comment'>-- | Soft scoping: We want all code that is covered to stay</span>
<a name="line-858"></a>    <span class='hs-comment'>-- covered.  Note that this scope type does not forbid</span>
<a name="line-859"></a>    <span class='hs-comment'>-- transformations from happening, as as long as all results of</span>
<a name="line-860"></a>    <span class='hs-comment'>-- the transformations are still covered by this tick or a copy of</span>
<a name="line-861"></a>    <span class='hs-comment'>-- it. For example</span>
<a name="line-862"></a>    <span class='hs-comment'>--</span>
<a name="line-863"></a>    <span class='hs-comment'>--   let x = tick&lt;...&gt; (let y = foo in bar) in baz</span>
<a name="line-864"></a>    <span class='hs-comment'>--     ===&gt;</span>
<a name="line-865"></a>    <span class='hs-comment'>--   let x = tick&lt;...&gt; bar; y = tick&lt;...&gt; foo in baz</span>
<a name="line-866"></a>    <span class='hs-comment'>--</span>
<a name="line-867"></a>    <span class='hs-comment'>-- Is a valid transformation as far as "bar" and "foo" is</span>
<a name="line-868"></a>    <span class='hs-comment'>-- concerned, because both still are scoped over by the tick.</span>
<a name="line-869"></a>    <span class='hs-comment'>--</span>
<a name="line-870"></a>    <span class='hs-comment'>-- Note though that one might object to the "let" not being</span>
<a name="line-871"></a>    <span class='hs-comment'>-- covered by the tick any more. However, we are generally lax</span>
<a name="line-872"></a>    <span class='hs-comment'>-- with this - constant costs don't matter too much, and given</span>
<a name="line-873"></a>    <span class='hs-comment'>-- that the "let" was effectively merged we can view it as having</span>
<a name="line-874"></a>    <span class='hs-comment'>-- lost its identity anyway.</span>
<a name="line-875"></a>    <span class='hs-comment'>--</span>
<a name="line-876"></a>    <span class='hs-comment'>-- Also note that this scoping behaviour allows floating a tick</span>
<a name="line-877"></a>    <span class='hs-comment'>-- "upwards" in pretty much any situation. For example:</span>
<a name="line-878"></a>    <span class='hs-comment'>--</span>
<a name="line-879"></a>    <span class='hs-comment'>--   case foo of x -&gt; tick&lt;...&gt; bar</span>
<a name="line-880"></a>    <span class='hs-comment'>--     ==&gt;</span>
<a name="line-881"></a>    <span class='hs-comment'>--   tick&lt;...&gt; case foo of x -&gt; bar</span>
<a name="line-882"></a>    <span class='hs-comment'>--</span>
<a name="line-883"></a>    <span class='hs-comment'>-- While this is always leagl, we want to make a best effort to</span>
<a name="line-884"></a>    <span class='hs-comment'>-- only make us of this where it exposes transformation</span>
<a name="line-885"></a>    <span class='hs-comment'>-- opportunities.</span>
<a name="line-886"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SoftScope</span>
<a name="line-887"></a>
<a name="line-888"></a>    <span class='hs-comment'>-- | Cost centre scoping: We don't want any costs to move to other</span>
<a name="line-889"></a>    <span class='hs-comment'>-- cost-centre stacks. This means we not only want no code or cost</span>
<a name="line-890"></a>    <span class='hs-comment'>-- to get moved out of their cost centres, but we also object to</span>
<a name="line-891"></a>    <span class='hs-comment'>-- code getting associated with new cost-centre ticks - or</span>
<a name="line-892"></a>    <span class='hs-comment'>-- changing the order in which they get applied.</span>
<a name="line-893"></a>    <span class='hs-comment'>--</span>
<a name="line-894"></a>    <span class='hs-comment'>-- A rule of thumb is that we don't want any code to gain new</span>
<a name="line-895"></a>    <span class='hs-comment'>-- annotations. However, there are notable exceptions, for</span>
<a name="line-896"></a>    <span class='hs-comment'>-- example:</span>
<a name="line-897"></a>    <span class='hs-comment'>--</span>
<a name="line-898"></a>    <span class='hs-comment'>--   let f = \y -&gt; foo in tick&lt;...&gt; ... (f x) ...</span>
<a name="line-899"></a>    <span class='hs-comment'>--     ==&gt;</span>
<a name="line-900"></a>    <span class='hs-comment'>--   tick&lt;...&gt; ... foo[x/y] ...</span>
<a name="line-901"></a>    <span class='hs-comment'>--</span>
<a name="line-902"></a>    <span class='hs-comment'>-- In-lining lambdas like this is always legal, because inlining a</span>
<a name="line-903"></a>    <span class='hs-comment'>-- function does not change the cost-centre stack when the</span>
<a name="line-904"></a>    <span class='hs-comment'>-- function is called.</span>
<a name="line-905"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CostCentreScope</span>
<a name="line-906"></a>
<a name="line-907"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-908"></a>
<a name="line-909"></a><a name="tickishScoped"></a><span class='hs-comment'>-- | Returns the intended scoping rule for a Tickish</span>
<a name="line-910"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TickishScoping</span>
<a name="line-911"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>
<a name="line-912"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>profNoteScope</span> <span class='hs-varid'>n</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CostCentreScope</span>
<a name="line-913"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoScope</span>
<a name="line-914"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-conid'>HpcTick</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoScope</span>
<a name="line-915"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-conid'>Breakpoint</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CostCentreScope</span>
<a name="line-916"></a>   <span class='hs-comment'>-- Breakpoints are scoped: eventually we're going to do call</span>
<a name="line-917"></a>   <span class='hs-comment'>-- stacks, but also this helps prevent the simplifier from moving</span>
<a name="line-918"></a>   <span class='hs-comment'>-- breakpoints around and changing their result type (see #1531).</span>
<a name="line-919"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-conid'>SourceNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SoftScope</span>
<a name="line-920"></a>
<a name="line-921"></a><a name="tickishScopesLike"></a><span class='hs-comment'>-- | Returns whether the tick scoping rule is at least as permissive</span>
<a name="line-922"></a><span class='hs-comment'>-- as the given scoping rule.</span>
<a name="line-923"></a><span class='hs-definition'>tickishScopesLike</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TickishScoping</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-924"></a><span class='hs-definition'>tickishScopesLike</span> <span class='hs-varid'>t</span> <span class='hs-varid'>scope</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tickishScoped</span> <span class='hs-varid'>t</span> <span class='hs-varop'>`like`</span> <span class='hs-varid'>scope</span>
<a name="line-925"></a>  <span class='hs-keyword'>where</span> <span class='hs-conid'>NoScope</span>         <span class='hs-varop'>`like`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-926"></a>        <span class='hs-keyword'>_</span>               <span class='hs-varop'>`like`</span> <span class='hs-conid'>NoScope</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-927"></a>        <span class='hs-conid'>SoftScope</span>       <span class='hs-varop'>`like`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-928"></a>        <span class='hs-keyword'>_</span>               <span class='hs-varop'>`like`</span> <span class='hs-conid'>SoftScope</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-929"></a>        <span class='hs-conid'>CostCentreScope</span> <span class='hs-varop'>`like`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-930"></a>
<a name="line-931"></a><a name="tickishFloatable"></a><span class='hs-comment'>-- | Returns @True@ for ticks that can be floated upwards easily even</span>
<a name="line-932"></a><span class='hs-comment'>-- where it might change execution counts, such as:</span>
<a name="line-933"></a><span class='hs-comment'>--</span>
<a name="line-934"></a><span class='hs-comment'>--   Just (tick&lt;...&gt; foo)</span>
<a name="line-935"></a><span class='hs-comment'>--     ==&gt;</span>
<a name="line-936"></a><span class='hs-comment'>--   tick&lt;...&gt; (Just foo)</span>
<a name="line-937"></a><span class='hs-comment'>--</span>
<a name="line-938"></a><span class='hs-comment'>-- This is a combination of @tickishSoftScope@ and</span>
<a name="line-939"></a><span class='hs-comment'>-- @tickishCounts@. Note that in principle splittable ticks can become</span>
<a name="line-940"></a><span class='hs-comment'>-- floatable using @mkNoTick@ -- even though there's currently no</span>
<a name="line-941"></a><span class='hs-comment'>-- tickish for which that is the case.</span>
<a name="line-942"></a><span class='hs-definition'>tickishFloatable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-943"></a><span class='hs-definition'>tickishFloatable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> <span class='hs-varop'>`tickishScopesLike`</span> <span class='hs-conid'>SoftScope</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCounts</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-944"></a>
<a name="line-945"></a><a name="tickishCanSplit"></a><span class='hs-comment'>-- | Returns @True@ for a tick that is both counting /and/ scoping and</span>
<a name="line-946"></a><span class='hs-comment'>-- can be split into its (tick, scope) parts using 'mkNoScope' and</span>
<a name="line-947"></a><span class='hs-comment'>-- 'mkNoTick' respectively.</span>
<a name="line-948"></a><span class='hs-definition'>tickishCanSplit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-949"></a><span class='hs-definition'>tickishCanSplit</span> <span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-varid'>profNoteScope</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>profNoteCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span><span class='hs-layout'>}</span>
<a name="line-950"></a>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-951"></a><span class='hs-definition'>tickishCanSplit</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-952"></a>
<a name="line-953"></a><a name="mkNoCount"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span>
<a name="line-954"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCounts</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-955"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCanSplit</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoCount: Cannot split!"</span>
<a name="line-956"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>{</span><span class='hs-varid'>profNoteCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span><span class='hs-layout'>}</span>
<a name="line-957"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-keyword'>_</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoCount: Undefined split!"</span>
<a name="line-958"></a>
<a name="line-959"></a><a name="mkNoScope"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span>
<a name="line-960"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickishScoped</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NoScope</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-961"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCanSplit</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoScope: Cannot split!"</span>
<a name="line-962"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>{</span><span class='hs-varid'>profNoteScope</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span><span class='hs-layout'>}</span>
<a name="line-963"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-keyword'>_</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoScope: Undefined split!"</span>
<a name="line-964"></a>
<a name="line-965"></a><a name="tickishIsCode"></a><span class='hs-comment'>-- | Return @True@ if this source annotation compiles to some backend</span>
<a name="line-966"></a><span class='hs-comment'>-- code. Without this flag, the tickish is seen as a simple annotation</span>
<a name="line-967"></a><span class='hs-comment'>-- that does not have any associated evaluation code.</span>
<a name="line-968"></a><span class='hs-comment'>--</span>
<a name="line-969"></a><span class='hs-comment'>-- What this means that we are allowed to disregard the tick if doing</span>
<a name="line-970"></a><span class='hs-comment'>-- so means that we can skip generating any code in the first place. A</span>
<a name="line-971"></a><span class='hs-comment'>-- typical example is top-level bindings:</span>
<a name="line-972"></a><span class='hs-comment'>--</span>
<a name="line-973"></a><span class='hs-comment'>--   foo = tick&lt;...&gt; \y -&gt; ...</span>
<a name="line-974"></a><span class='hs-comment'>--     ==&gt;</span>
<a name="line-975"></a><span class='hs-comment'>--   foo = \y -&gt; tick&lt;...&gt; ...</span>
<a name="line-976"></a><span class='hs-comment'>--</span>
<a name="line-977"></a><span class='hs-comment'>-- Here there is just no operational difference between the first and</span>
<a name="line-978"></a><span class='hs-comment'>-- the second version. Therefore code generation should simply</span>
<a name="line-979"></a><span class='hs-comment'>-- translate the code as if it found the latter.</span>
<a name="line-980"></a><span class='hs-definition'>tickishIsCode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-981"></a><span class='hs-definition'>tickishIsCode</span> <span class='hs-conid'>SourceNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-982"></a><span class='hs-definition'>tickishIsCode</span> <span class='hs-sel'>_tickish</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- all the rest for now</span>
<a name="line-983"></a>
<a name="line-984"></a>
<a name="line-985"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- | Governs the kind of expression that the tick gets placed on when</span>
<a name="line-986"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- annotating for example using @mkTick@. If we find that we want to</span>
<a name="line-987"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- put a tickish on an expression ruled out here, we try to float it</span>
<a name="line-988"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- inwards until we find a suitable expression.</span>
<a name="line-989"></a><a name="TickishPlacement"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TickishPlacement</span> <span class='hs-keyglyph'>=</span>
<a name="line-990"></a>
<a name="line-991"></a>    <span class='hs-comment'>-- | Place ticks exactly on run-time expressions. We can still</span>
<a name="line-992"></a>    <span class='hs-comment'>-- move the tick through pure compile-time constructs such as</span>
<a name="line-993"></a>    <span class='hs-comment'>-- other ticks, casts or type lambdas. This is the most</span>
<a name="line-994"></a>    <span class='hs-comment'>-- restrictive placement rule for ticks, as all tickishs have in</span>
<a name="line-995"></a>    <span class='hs-comment'>-- common that they want to track runtime processes. The only</span>
<a name="line-996"></a>    <span class='hs-comment'>-- legal placement rule for counting ticks.</span>
<a name="line-997"></a>    <span class='hs-conid'>PlaceRuntime</span>
<a name="line-998"></a>
<a name="line-999"></a>    <span class='hs-comment'>-- | As @PlaceRuntime@, but we float the tick through all</span>
<a name="line-1000"></a>    <span class='hs-comment'>-- lambdas. This makes sense where there is little difference</span>
<a name="line-1001"></a>    <span class='hs-comment'>-- between annotating the lambda and annotating the lambda's code.</span>
<a name="line-1002"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PlaceNonLam</span>
<a name="line-1003"></a>
<a name="line-1004"></a>    <span class='hs-comment'>-- | In addition to floating through lambdas, cost-centre style</span>
<a name="line-1005"></a>    <span class='hs-comment'>-- tickishs can also be moved from constructors, non-function</span>
<a name="line-1006"></a>    <span class='hs-comment'>-- variables and literals. For example:</span>
<a name="line-1007"></a>    <span class='hs-comment'>--</span>
<a name="line-1008"></a>    <span class='hs-comment'>--   let x = scc&lt;...&gt; C (scc&lt;...&gt; y) (scc&lt;...&gt; 3) in ...</span>
<a name="line-1009"></a>    <span class='hs-comment'>--</span>
<a name="line-1010"></a>    <span class='hs-comment'>-- Neither the constructor application, the variable or the</span>
<a name="line-1011"></a>    <span class='hs-comment'>-- literal are likely to have any cost worth mentioning. And even</span>
<a name="line-1012"></a>    <span class='hs-comment'>-- if y names a thunk, the call would not care about the</span>
<a name="line-1013"></a>    <span class='hs-comment'>-- evaluation context. Therefore removing all annotations in the</span>
<a name="line-1014"></a>    <span class='hs-comment'>-- above example is safe.</span>
<a name="line-1015"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PlaceCostCentre</span>
<a name="line-1016"></a>
<a name="line-1017"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-1018"></a>
<a name="line-1019"></a><a name="tickishPlace"></a><span class='hs-comment'>-- | Placement behaviour we want for the ticks</span>
<a name="line-1020"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TickishPlacement</span>
<a name="line-1021"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>
<a name="line-1022"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>profNoteCount</span> <span class='hs-varid'>n</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceRuntime</span>
<a name="line-1023"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceCostCentre</span>
<a name="line-1024"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-conid'>HpcTick</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceRuntime</span>
<a name="line-1025"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-conid'>Breakpoint</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceRuntime</span>
<a name="line-1026"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-conid'>SourceNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceNonLam</span>
<a name="line-1027"></a>
<a name="line-1028"></a><a name="tickishContains"></a><span class='hs-comment'>-- | Returns whether one tick "contains" the other one, therefore</span>
<a name="line-1029"></a><span class='hs-comment'>-- making the second tick redundant.</span>
<a name="line-1030"></a><span class='hs-definition'>tickishContains</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Tickish</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1031"></a><span class='hs-definition'>tickishContains</span> <span class='hs-layout'>(</span><span class='hs-conid'>SourceNote</span> <span class='hs-varid'>sp1</span> <span class='hs-varid'>n1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>SourceNote</span> <span class='hs-varid'>sp2</span> <span class='hs-varid'>n2</span><span class='hs-layout'>)</span>
<a name="line-1032"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>containsSpan</span> <span class='hs-varid'>sp1</span> <span class='hs-varid'>sp2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>n1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>n2</span>
<a name="line-1033"></a>    <span class='hs-comment'>-- compare the String last</span>
<a name="line-1034"></a><span class='hs-definition'>tickishContains</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span>
<a name="line-1035"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>t2</span>
<a name="line-1036"></a>
<a name="line-1037"></a><span class='hs-comment'>{-
<a name="line-1038"></a>************************************************************************
<a name="line-1039"></a>*                                                                      *
<a name="line-1040"></a>                Orphans
<a name="line-1041"></a>*                                                                      *
<a name="line-1042"></a>************************************************************************
<a name="line-1043"></a>-}</span>
<a name="line-1044"></a>
<a name="line-1045"></a><a name="IsOrphan"></a><span class='hs-comment'>-- | Is this instance an orphan?  If it is not an orphan, contains an 'OccName'</span>
<a name="line-1046"></a><a name="IsOrphan"></a><span class='hs-comment'>-- witnessing the instance's non-orphanhood.</span>
<a name="line-1047"></a><a name="IsOrphan"></a><span class='hs-comment'>-- See Note [Orphans]</span>
<a name="line-1048"></a><a name="IsOrphan"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-1049"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-1050"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NotOrphan</span> <span class='hs-conid'>OccName</span> <span class='hs-comment'>-- The OccName 'n' witnesses the instance's non-orphanhood</span>
<a name="line-1051"></a>                      <span class='hs-comment'>-- In that case, the instance is fingerprinted as part</span>
<a name="line-1052"></a>                      <span class='hs-comment'>-- of the definition of 'n's definition</span>
<a name="line-1053"></a>    <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-1054"></a>
<a name="line-1055"></a><a name="isOrphan"></a><span class='hs-comment'>-- | Returns true if 'IsOrphan' is orphan.</span>
<a name="line-1056"></a><span class='hs-definition'>isOrphan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1057"></a><span class='hs-definition'>isOrphan</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1058"></a><span class='hs-definition'>isOrphan</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1059"></a>
<a name="line-1060"></a><a name="notOrphan"></a><span class='hs-comment'>-- | Returns true if 'IsOrphan' is not an orphan.</span>
<a name="line-1061"></a><span class='hs-definition'>notOrphan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1062"></a><span class='hs-definition'>notOrphan</span> <span class='hs-conid'>NotOrphan</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1063"></a><span class='hs-definition'>notOrphan</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1064"></a>
<a name="line-1065"></a><a name="chooseOrphanAnchor"></a><span class='hs-definition'>chooseOrphanAnchor</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NameSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-1066"></a><span class='hs-comment'>-- Something (rule, instance) is relate to all the Names in this</span>
<a name="line-1067"></a><span class='hs-comment'>-- list. Choose one of them to be an "anchor" for the orphan.  We make</span>
<a name="line-1068"></a><span class='hs-comment'>-- the choice deterministic to avoid gratuitious changes in the ABI</span>
<a name="line-1069"></a><span class='hs-comment'>-- hash (Trac #4012).  Specifically, use lexicographic comparison of</span>
<a name="line-1070"></a><span class='hs-comment'>-- OccName rather than comparing Uniques</span>
<a name="line-1071"></a><span class='hs-comment'>--</span>
<a name="line-1072"></a><span class='hs-comment'>-- NB: 'minimum' use Ord, and (Ord OccName) works lexicographically</span>
<a name="line-1073"></a><span class='hs-comment'>--</span>
<a name="line-1074"></a><span class='hs-definition'>chooseOrphanAnchor</span> <span class='hs-varid'>local_names</span>
<a name="line-1075"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyNameSet</span> <span class='hs-varid'>local_names</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-1076"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NotOrphan</span> <span class='hs-layout'>(</span><span class='hs-varid'>minimum</span> <span class='hs-varid'>occs</span><span class='hs-layout'>)</span>
<a name="line-1077"></a>  <span class='hs-keyword'>where</span>
<a name="line-1078"></a>    <span class='hs-varid'>occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>nameOccName</span> <span class='hs-varop'>$</span> <span class='hs-varid'>nonDetEltsUniqSet</span> <span class='hs-varid'>local_names</span>
<a name="line-1079"></a>    <span class='hs-comment'>-- It's OK to use nonDetEltsUFM here, see comments above</span>
<a name="line-1080"></a>
<a name="line-1081"></a><a name="instance%20Binary%20IsOrphan"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Binary</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyword'>where</span>
<a name="line-1082"></a>    <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putByte</span> <span class='hs-varid'>bh</span> <span class='hs-num'>0</span>
<a name="line-1083"></a>    <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-layout'>(</span><span class='hs-conid'>NotOrphan</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1084"></a>        <span class='hs-varid'>putByte</span> <span class='hs-varid'>bh</span> <span class='hs-num'>1</span>
<a name="line-1085"></a>        <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-varid'>n</span>
<a name="line-1086"></a>    <span class='hs-varid'>get</span> <span class='hs-varid'>bh</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1087"></a>        <span class='hs-varid'>h</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getByte</span> <span class='hs-varid'>bh</span>
<a name="line-1088"></a>        <span class='hs-keyword'>case</span> <span class='hs-varid'>h</span> <span class='hs-keyword'>of</span>
<a name="line-1089"></a>            <span class='hs-num'>0</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-1090"></a>            <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1091"></a>                <span class='hs-varid'>n</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>get</span> <span class='hs-varid'>bh</span>
<a name="line-1092"></a>                <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>NotOrphan</span> <span class='hs-varid'>n</span>
<a name="line-1093"></a>
<a name="line-1094"></a><span class='hs-comment'>{-
<a name="line-1095"></a>Note [Orphans]
<a name="line-1096"></a>~~~~~~~~~~~~~~
<a name="line-1097"></a>Class instances, rules, and family instances are divided into orphans
<a name="line-1098"></a>and non-orphans.  Roughly speaking, an instance/rule is an orphan if
<a name="line-1099"></a>its left hand side mentions nothing defined in this module.  Orphan-hood
<a name="line-1100"></a>has two major consequences
<a name="line-1101"></a>
<a name="line-1102"></a> * A module that contains orphans is called an "orphan module".  If
<a name="line-1103"></a>   the module being compiled depends (transitively) on an oprhan
<a name="line-1104"></a>   module M, then M.hi is read in regardless of whether M is oherwise
<a name="line-1105"></a>   needed. This is to ensure that we don't miss any instance decls in
<a name="line-1106"></a>   M.  But it's painful, because it means we need to keep track of all
<a name="line-1107"></a>   the orphan modules below us.
<a name="line-1108"></a>
<a name="line-1109"></a> * A non-orphan is not finger-printed separately.  Instead, for
<a name="line-1110"></a>   fingerprinting purposes it is treated as part of the entity it
<a name="line-1111"></a>   mentions on the LHS.  For example
<a name="line-1112"></a>      data T = T1 | T2
<a name="line-1113"></a>      instance Eq T where ....
<a name="line-1114"></a>   The instance (Eq T) is incorprated as part of T's fingerprint.
<a name="line-1115"></a>
<a name="line-1116"></a>   In contrast, orphans are all fingerprinted together in the
<a name="line-1117"></a>   mi_orph_hash field of the ModIface.
<a name="line-1118"></a>
<a name="line-1119"></a>   See MkIface.addFingerprints.
<a name="line-1120"></a>
<a name="line-1121"></a>Orphan-hood is computed
<a name="line-1122"></a>  * For class instances:
<a name="line-1123"></a>      when we make a ClsInst
<a name="line-1124"></a>    (because it is needed during instance lookup)
<a name="line-1125"></a>
<a name="line-1126"></a>  * For rules and family instances:
<a name="line-1127"></a>       when we generate an IfaceRule (MkIface.coreRuleToIfaceRule)
<a name="line-1128"></a>                     or IfaceFamInst (MkIface.instanceToIfaceInst)
<a name="line-1129"></a>-}</span>
<a name="line-1130"></a>
<a name="line-1131"></a><span class='hs-comment'>{-
<a name="line-1132"></a>************************************************************************
<a name="line-1133"></a>*                                                                      *
<a name="line-1134"></a>\subsection{Transformation rules}
<a name="line-1135"></a>*                                                                      *
<a name="line-1136"></a>************************************************************************
<a name="line-1137"></a>
<a name="line-1138"></a>The CoreRule type and its friends are dealt with mainly in CoreRules,
<a name="line-1139"></a>but CoreFVs, Subst, PprCore, CoreTidy also inspect the representation.
<a name="line-1140"></a>-}</span>
<a name="line-1141"></a>
<a name="line-1142"></a><a name="RuleBase"></a><span class='hs-comment'>-- | Gathers a collection of 'CoreRule's. Maps (the name of) an 'Id' to its rules</span>
<a name="line-1143"></a><a name="RuleBase"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RuleBase</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NameEnv</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span>
<a name="line-1144"></a>        <span class='hs-comment'>-- The rules are unordered;</span>
<a name="line-1145"></a>        <span class='hs-comment'>-- we sort out any overlaps on lookup</span>
<a name="line-1146"></a>
<a name="line-1147"></a><a name="RuleEnv"></a><span class='hs-comment'>-- | A full rule environment which we can apply rules from.  Like a 'RuleBase',</span>
<a name="line-1148"></a><a name="RuleEnv"></a><span class='hs-comment'>-- but it also includes the set of visible orphans we use to filter out orphan</span>
<a name="line-1149"></a><a name="RuleEnv"></a><span class='hs-comment'>-- rules which are not visible (even though we can see them...)</span>
<a name="line-1150"></a><a name="RuleEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RuleEnv</span>
<a name="line-1151"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>re_base</span>          <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleBase</span>
<a name="line-1152"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>re_visible_orphs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ModuleSet</span>
<a name="line-1153"></a>              <span class='hs-layout'>}</span>
<a name="line-1154"></a>
<a name="line-1155"></a><a name="mkRuleEnv"></a><span class='hs-definition'>mkRuleEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleBase</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Module</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RuleEnv</span>
<a name="line-1156"></a><span class='hs-definition'>mkRuleEnv</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>vis_orphs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleEnv</span> <span class='hs-varid'>rules</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkModuleSet</span> <span class='hs-varid'>vis_orphs</span><span class='hs-layout'>)</span>
<a name="line-1157"></a>
<a name="line-1158"></a><a name="emptyRuleEnv"></a><span class='hs-definition'>emptyRuleEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleEnv</span>
<a name="line-1159"></a><span class='hs-definition'>emptyRuleEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleEnv</span> <span class='hs-varid'>emptyNameEnv</span> <span class='hs-varid'>emptyModuleSet</span>
<a name="line-1160"></a>
<a name="line-1161"></a><a name="CoreRule"></a><span class='hs-comment'>-- | A 'CoreRule' is:</span>
<a name="line-1162"></a><a name="CoreRule"></a><span class='hs-comment'>--</span>
<a name="line-1163"></a><a name="CoreRule"></a><span class='hs-comment'>-- * \"Local\" if the function it is a rule for is defined in the</span>
<a name="line-1164"></a><a name="CoreRule"></a><span class='hs-comment'>--   same module as the rule itself.</span>
<a name="line-1165"></a><a name="CoreRule"></a><span class='hs-comment'>--</span>
<a name="line-1166"></a><a name="CoreRule"></a><span class='hs-comment'>-- * \"Orphan\" if nothing on the LHS is defined in the same module</span>
<a name="line-1167"></a><a name="CoreRule"></a><span class='hs-comment'>--   as the rule itself</span>
<a name="line-1168"></a><a name="CoreRule"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CoreRule</span>
<a name="line-1169"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span>
<a name="line-1170"></a>        <span class='hs-varid'>ru_name</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- ^ Name of the rule, for communication with the user</span>
<a name="line-1171"></a>        <span class='hs-varid'>ru_act</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Activation</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- ^ When the rule is active</span>
<a name="line-1172"></a>
<a name="line-1173"></a>        <span class='hs-comment'>-- Rough-matching stuff</span>
<a name="line-1174"></a>        <span class='hs-comment'>-- see comments with InstEnv.ClsInst( is_cls, is_rough )</span>
<a name="line-1175"></a>        <span class='hs-varid'>ru_fn</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span><span class='hs-layout'>,</span>               <span class='hs-comment'>-- ^ Name of the 'Id.Id' at the head of this rule</span>
<a name="line-1176"></a>        <span class='hs-varid'>ru_rough</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>       <span class='hs-comment'>-- ^ Name at the head of each argument to the left hand side</span>
<a name="line-1177"></a>
<a name="line-1178"></a>        <span class='hs-comment'>-- Proper-matching stuff</span>
<a name="line-1179"></a>        <span class='hs-comment'>-- see comments with InstEnv.ClsInst( is_tvs, is_tys )</span>
<a name="line-1180"></a>        <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- ^ Variables quantified over</span>
<a name="line-1181"></a>        <span class='hs-varid'>ru_args</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- ^ Left hand side arguments</span>
<a name="line-1182"></a>
<a name="line-1183"></a>        <span class='hs-comment'>-- And the right-hand side</span>
<a name="line-1184"></a>        <span class='hs-varid'>ru_rhs</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>           <span class='hs-comment'>-- ^ Right hand side of the rule</span>
<a name="line-1185"></a>                                        <span class='hs-comment'>-- Occurrence info is guaranteed correct</span>
<a name="line-1186"></a>                                        <span class='hs-comment'>-- See Note [OccInfo in unfoldings and rules]</span>
<a name="line-1187"></a>
<a name="line-1188"></a>        <span class='hs-comment'>-- Locality</span>
<a name="line-1189"></a>        <span class='hs-varid'>ru_auto</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- ^ @True@  &lt;=&gt; this rule is auto-generated</span>
<a name="line-1190"></a>                           <span class='hs-comment'>--               (notably by Specialise or SpecConstr)</span>
<a name="line-1191"></a>                           <span class='hs-comment'>--   @False@ &lt;=&gt; generated at the user's behest</span>
<a name="line-1192"></a>                           <span class='hs-comment'>-- See Note [Trimming auto-rules] in TidyPgm</span>
<a name="line-1193"></a>                           <span class='hs-comment'>-- for the sole purpose of this field.</span>
<a name="line-1194"></a>
<a name="line-1195"></a>        <span class='hs-varid'>ru_origin</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Module</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- ^ 'Module' the rule was defined in, used</span>
<a name="line-1196"></a>                                <span class='hs-comment'>-- to test if we should see an orphan rule.</span>
<a name="line-1197"></a>
<a name="line-1198"></a>        <span class='hs-varid'>ru_orphan</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>IsOrphan</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- ^ Whether or not the rule is an orphan.</span>
<a name="line-1199"></a>
<a name="line-1200"></a>        <span class='hs-varid'>ru_local</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>        <span class='hs-comment'>-- ^ @True@ iff the fn at the head of the rule is</span>
<a name="line-1201"></a>                                <span class='hs-comment'>-- defined in the same module as the rule</span>
<a name="line-1202"></a>                                <span class='hs-comment'>-- and is not an implicit 'Id' (like a record selector,</span>
<a name="line-1203"></a>                                <span class='hs-comment'>-- class operation, or data constructor).  This</span>
<a name="line-1204"></a>                                <span class='hs-comment'>-- is different from 'ru_orphan', where a rule</span>
<a name="line-1205"></a>                                <span class='hs-comment'>-- can avoid being an orphan if *any* Name in</span>
<a name="line-1206"></a>                                <span class='hs-comment'>-- LHS of the rule was defined in the same</span>
<a name="line-1207"></a>                                <span class='hs-comment'>-- module as the rule.</span>
<a name="line-1208"></a>    <span class='hs-layout'>}</span>
<a name="line-1209"></a>
<a name="line-1210"></a>  <span class='hs-comment'>-- | Built-in rules are used for constant folding</span>
<a name="line-1211"></a>  <span class='hs-comment'>-- and suchlike.  They have no free variables.</span>
<a name="line-1212"></a>  <span class='hs-comment'>-- A built-in rule is always visible (there is no such thing as</span>
<a name="line-1213"></a>  <span class='hs-comment'>-- an orphan built-in rule.)</span>
<a name="line-1214"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span>
<a name="line-1215"></a>        <span class='hs-varid'>ru_name</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- ^ As above</span>
<a name="line-1216"></a>        <span class='hs-varid'>ru_fn</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span><span class='hs-layout'>,</span>       <span class='hs-comment'>-- ^ As above</span>
<a name="line-1217"></a>        <span class='hs-varid'>ru_nargs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- ^ Number of arguments that 'ru_try' consumes,</span>
<a name="line-1218"></a>                                <span class='hs-comment'>-- if it fires, including type arguments</span>
<a name="line-1219"></a>        <span class='hs-varid'>ru_try</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleFun</span>
<a name="line-1220"></a>                <span class='hs-comment'>-- ^ This function does the rewrite.  It given too many</span>
<a name="line-1221"></a>                <span class='hs-comment'>-- arguments, it simply discards them; the returned 'CoreExpr'</span>
<a name="line-1222"></a>                <span class='hs-comment'>-- is just the rewrite of 'ru_fn' applied to the first 'ru_nargs' args</span>
<a name="line-1223"></a>    <span class='hs-layout'>}</span>
<a name="line-1224"></a>                <span class='hs-comment'>-- See Note [Extra args in rule matching] in Rules.hs</span>
<a name="line-1225"></a>
<a name="line-1226"></a><a name="RuleFun"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RuleFun</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1227"></a><a name="InScopeEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InScopeEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>InScopeSet</span><span class='hs-layout'>,</span> <span class='hs-conid'>IdUnfoldingFun</span><span class='hs-layout'>)</span>
<a name="line-1228"></a>
<a name="line-1229"></a><a name="IdUnfoldingFun"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>IdUnfoldingFun</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1230"></a><span class='hs-comment'>-- A function that embodies how to unfold an Id if you need</span>
<a name="line-1231"></a><span class='hs-comment'>-- to do that in the Rule.  The reason we need to pass this info in</span>
<a name="line-1232"></a><span class='hs-comment'>-- is that whether an Id is unfoldable depends on the simplifier phase</span>
<a name="line-1233"></a>
<a name="line-1234"></a><a name="isBuiltinRule"></a><span class='hs-definition'>isBuiltinRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1235"></a><span class='hs-definition'>isBuiltinRule</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1236"></a><span class='hs-definition'>isBuiltinRule</span> <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1237"></a>
<a name="line-1238"></a><a name="isAutoRule"></a><span class='hs-definition'>isAutoRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1239"></a><span class='hs-definition'>isAutoRule</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1240"></a><span class='hs-definition'>isAutoRule</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_auto</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_auto</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_auto</span>
<a name="line-1241"></a>
<a name="line-1242"></a><a name="ruleArity"></a><span class='hs-comment'>-- | The number of arguments the 'ru_fn' must be applied</span>
<a name="line-1243"></a><span class='hs-comment'>-- to before the rule can match on it</span>
<a name="line-1244"></a><span class='hs-definition'>ruleArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1245"></a><span class='hs-definition'>ruleArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-varid'>ru_nargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-1246"></a><span class='hs-definition'>ruleArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span><span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>args</span>
<a name="line-1247"></a>
<a name="line-1248"></a><a name="ruleName"></a><span class='hs-definition'>ruleName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RuleName</span>
<a name="line-1249"></a><span class='hs-definition'>ruleName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru_name</span>
<a name="line-1250"></a>
<a name="line-1251"></a><a name="ruleModule"></a><span class='hs-definition'>ruleModule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Module</span>
<a name="line-1252"></a><span class='hs-definition'>ruleModule</span> <span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_origin</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ru_origin</span>
<a name="line-1253"></a><span class='hs-definition'>ruleModule</span> <span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1254"></a>
<a name="line-1255"></a><a name="ruleActivation"></a><span class='hs-definition'>ruleActivation</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Activation</span>
<a name="line-1256"></a><span class='hs-definition'>ruleActivation</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AlwaysActive</span>
<a name="line-1257"></a><span class='hs-definition'>ruleActivation</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span>
<a name="line-1258"></a>
<a name="line-1259"></a><a name="ruleIdName"></a><span class='hs-comment'>-- | The 'Name' of the 'Id.Id' at the head of the rule left hand side</span>
<a name="line-1260"></a><span class='hs-definition'>ruleIdName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span>
<a name="line-1261"></a><span class='hs-definition'>ruleIdName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru_fn</span>
<a name="line-1262"></a>
<a name="line-1263"></a><a name="isLocalRule"></a><span class='hs-definition'>isLocalRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1264"></a><span class='hs-definition'>isLocalRule</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru_local</span>
<a name="line-1265"></a>
<a name="line-1266"></a><a name="setRuleIdName"></a><span class='hs-comment'>-- | Set the 'Name' of the 'Id.Id' at the head of the rule left hand side</span>
<a name="line-1267"></a><span class='hs-definition'>setRuleIdName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreRule</span>
<a name="line-1268"></a><span class='hs-definition'>setRuleIdName</span> <span class='hs-varid'>nm</span> <span class='hs-varid'>ru</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nm</span> <span class='hs-layout'>}</span>
<a name="line-1269"></a>
<a name="line-1270"></a><span class='hs-comment'>{-
<a name="line-1271"></a>************************************************************************
<a name="line-1272"></a>*                                                                      *
<a name="line-1273"></a>\subsection{Vectorisation declarations}
<a name="line-1274"></a>*                                                                      *
<a name="line-1275"></a>************************************************************************
<a name="line-1276"></a>
<a name="line-1277"></a>Representation of desugared vectorisation declarations that are fed to the vectoriser (via
<a name="line-1278"></a>'ModGuts').
<a name="line-1279"></a>-}</span>
<a name="line-1280"></a>
<a name="line-1281"></a><a name="CoreVect"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CoreVect</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Vect</span>      <span class='hs-conid'>Id</span>   <span class='hs-conid'>CoreExpr</span>
<a name="line-1282"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NoVect</span>    <span class='hs-conid'>Id</span>
<a name="line-1283"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>VectType</span>  <span class='hs-conid'>Bool</span> <span class='hs-conid'>TyCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>TyCon</span><span class='hs-layout'>)</span>
<a name="line-1284"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>VectClass</span> <span class='hs-conid'>TyCon</span>                     <span class='hs-comment'>-- class tycon</span>
<a name="line-1285"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>VectInst</span>  <span class='hs-conid'>Id</span>                        <span class='hs-comment'>-- instance dfun (always SCALAR)  !!!FIXME: should be superfluous now</span>
<a name="line-1286"></a>
<a name="line-1287"></a><span class='hs-comment'>{-
<a name="line-1288"></a>************************************************************************
<a name="line-1289"></a>*                                                                      *
<a name="line-1290"></a>                Unfoldings
<a name="line-1291"></a>*                                                                      *
<a name="line-1292"></a>************************************************************************
<a name="line-1293"></a>
<a name="line-1294"></a>The @Unfolding@ type is declared here to avoid numerous loops
<a name="line-1295"></a>-}</span>
<a name="line-1296"></a>
<a name="line-1297"></a><a name="Unfolding"></a><span class='hs-comment'>-- | Records the /unfolding/ of an identifier, which is approximately the form the</span>
<a name="line-1298"></a><a name="Unfolding"></a><span class='hs-comment'>-- identifier would have if we substituted its definition in for the identifier.</span>
<a name="line-1299"></a><a name="Unfolding"></a><span class='hs-comment'>-- This type should be treated as abstract everywhere except in "CoreUnfold"</span>
<a name="line-1300"></a><a name="Unfolding"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1301"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUnfolding</span>        <span class='hs-comment'>-- ^ We have no information about the unfolding.</span>
<a name="line-1302"></a>
<a name="line-1303"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BootUnfolding</span>      <span class='hs-comment'>-- ^ We have no information about the unfolding, because</span>
<a name="line-1304"></a>                       <span class='hs-comment'>-- this 'Id' came from an @hi-boot@ file.</span>
<a name="line-1305"></a>                       <span class='hs-comment'>-- See Note [Inlining and hs-boot files] in ToIface</span>
<a name="line-1306"></a>                       <span class='hs-comment'>-- for what this is used for.</span>
<a name="line-1307"></a>
<a name="line-1308"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OtherCon</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- ^ It ain't one of these constructors.</span>
<a name="line-1309"></a>                       <span class='hs-comment'>-- @OtherCon xs@ also indicates that something has been evaluated</span>
<a name="line-1310"></a>                       <span class='hs-comment'>-- and hence there's no point in re-evaluating it.</span>
<a name="line-1311"></a>                       <span class='hs-comment'>-- @OtherCon []@ is used even for non-data-type values</span>
<a name="line-1312"></a>                       <span class='hs-comment'>-- to indicated evaluated-ness.  Notably:</span>
<a name="line-1313"></a>                       <span class='hs-comment'>--</span>
<a name="line-1314"></a>                       <span class='hs-comment'>-- &gt; data C = C !(Int -&gt; Int)</span>
<a name="line-1315"></a>                       <span class='hs-comment'>-- &gt; case x of { C f -&gt; ... }</span>
<a name="line-1316"></a>                       <span class='hs-comment'>--</span>
<a name="line-1317"></a>                       <span class='hs-comment'>-- Here, @f@ gets an @OtherCon []@ unfolding.</span>
<a name="line-1318"></a>
<a name="line-1319"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span>     <span class='hs-comment'>-- The Unfolding of a DFunId</span>
<a name="line-1320"></a>                        <span class='hs-comment'>-- See Note [DFun unfoldings]</span>
<a name="line-1321"></a>                        <span class='hs-comment'>--     df = /\a1..am. \d1..dn. MkD t1 .. tk</span>
<a name="line-1322"></a>                        <span class='hs-comment'>--                                 (op1 a1..am d1..dn)</span>
<a name="line-1323"></a>                        <span class='hs-comment'>--                                 (op2 a1..am d1..dn)</span>
<a name="line-1324"></a>        <span class='hs-varid'>df_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- The bound variables [a1..m],[d1..dn]</span>
<a name="line-1325"></a>        <span class='hs-varid'>df_con</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- The dictionary data constructor (never a newtype datacon)</span>
<a name="line-1326"></a>        <span class='hs-varid'>df_args</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Args of the data con: types, superclasses and methods,</span>
<a name="line-1327"></a>    <span class='hs-layout'>}</span>                           <span class='hs-comment'>-- in positional order</span>
<a name="line-1328"></a>
<a name="line-1329"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span>             <span class='hs-comment'>-- An unfolding for an Id with no pragma,</span>
<a name="line-1330"></a>                                <span class='hs-comment'>-- or perhaps a NOINLINE pragma</span>
<a name="line-1331"></a>                                <span class='hs-comment'>-- (For NOINLINE, the phase, if any, is in the</span>
<a name="line-1332"></a>                                <span class='hs-comment'>-- InlinePragInfo for this Id.)</span>
<a name="line-1333"></a>        <span class='hs-varid'>uf_tmpl</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Template; occurrence info is correct</span>
<a name="line-1334"></a>        <span class='hs-varid'>uf_src</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingSource</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- Where the unfolding came from</span>
<a name="line-1335"></a>        <span class='hs-varid'>uf_is_top</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- True &lt;=&gt; top level binding</span>
<a name="line-1336"></a>        <span class='hs-varid'>uf_is_value</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- exprIsHNF template (cached); it is ok to discard</span>
<a name="line-1337"></a>                                        <span class='hs-comment'>--      a `seq` on this variable</span>
<a name="line-1338"></a>        <span class='hs-varid'>uf_is_conlike</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- True &lt;=&gt; applicn of constructor or CONLIKE function</span>
<a name="line-1339"></a>                                        <span class='hs-comment'>--      Cached version of exprIsConLike</span>
<a name="line-1340"></a>        <span class='hs-varid'>uf_is_work_free</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                <span class='hs-comment'>-- True &lt;=&gt; doesn't waste (much) work to expand</span>
<a name="line-1341"></a>                                        <span class='hs-comment'>--          inside an inlining</span>
<a name="line-1342"></a>                                        <span class='hs-comment'>--      Cached version of exprIsCheap</span>
<a name="line-1343"></a>        <span class='hs-varid'>uf_expandable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- True &lt;=&gt; can expand in RULE matching</span>
<a name="line-1344"></a>                                        <span class='hs-comment'>--      Cached version of exprIsExpandable</span>
<a name="line-1345"></a>        <span class='hs-varid'>uf_guidance</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingGuidance</span>      <span class='hs-comment'>-- Tells about the *size* of the template.</span>
<a name="line-1346"></a>    <span class='hs-layout'>}</span>
<a name="line-1347"></a>  <span class='hs-comment'>-- ^ An unfolding with redundant cached information. Parameters:</span>
<a name="line-1348"></a>  <span class='hs-comment'>--</span>
<a name="line-1349"></a>  <span class='hs-comment'>--  uf_tmpl: Template used to perform unfolding;</span>
<a name="line-1350"></a>  <span class='hs-comment'>--           NB: Occurrence info is guaranteed correct:</span>
<a name="line-1351"></a>  <span class='hs-comment'>--               see Note [OccInfo in unfoldings and rules]</span>
<a name="line-1352"></a>  <span class='hs-comment'>--</span>
<a name="line-1353"></a>  <span class='hs-comment'>--  uf_is_top: Is this a top level binding?</span>
<a name="line-1354"></a>  <span class='hs-comment'>--</span>
<a name="line-1355"></a>  <span class='hs-comment'>--  uf_is_value: 'exprIsHNF' template (cached); it is ok to discard a 'seq' on</span>
<a name="line-1356"></a>  <span class='hs-comment'>--     this variable</span>
<a name="line-1357"></a>  <span class='hs-comment'>--</span>
<a name="line-1358"></a>  <span class='hs-comment'>--  uf_is_work_free:  Does this waste only a little work if we expand it inside an inlining?</span>
<a name="line-1359"></a>  <span class='hs-comment'>--     Basically this is a cached version of 'exprIsWorkFree'</span>
<a name="line-1360"></a>  <span class='hs-comment'>--</span>
<a name="line-1361"></a>  <span class='hs-comment'>--  uf_guidance:  Tells us about the /size/ of the unfolding template</span>
<a name="line-1362"></a>
<a name="line-1363"></a>
<a name="line-1364"></a><a name="UnfoldingSource"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1365"></a><a name="UnfoldingSource"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UnfoldingSource</span>
<a name="line-1366"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See also Note [Historical note: unfoldings for wrappers]</span>
<a name="line-1367"></a>
<a name="line-1368"></a>    <span class='hs-conid'>InlineRhs</span>          <span class='hs-comment'>-- The current rhs of the function</span>
<a name="line-1369"></a>                       <span class='hs-comment'>-- Replace uf_tmpl each time around</span>
<a name="line-1370"></a>
<a name="line-1371"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>InlineStable</span>       <span class='hs-comment'>-- From an INLINE or INLINABLE pragma</span>
<a name="line-1372"></a>                       <span class='hs-comment'>--   INLINE     if guidance is UnfWhen</span>
<a name="line-1373"></a>                       <span class='hs-comment'>--   INLINABLE  if guidance is UnfIfGoodArgs/UnfoldNever</span>
<a name="line-1374"></a>                       <span class='hs-comment'>-- (well, technically an INLINABLE might be made</span>
<a name="line-1375"></a>                       <span class='hs-comment'>-- UnfWhen if it was small enough, and then</span>
<a name="line-1376"></a>                       <span class='hs-comment'>-- it will behave like INLINE outside the current</span>
<a name="line-1377"></a>                       <span class='hs-comment'>-- module, but that is the way automatic unfoldings</span>
<a name="line-1378"></a>                       <span class='hs-comment'>-- work so it is consistent with the intended</span>
<a name="line-1379"></a>                       <span class='hs-comment'>-- meaning of INLINABLE).</span>
<a name="line-1380"></a>                       <span class='hs-comment'>--</span>
<a name="line-1381"></a>                       <span class='hs-comment'>-- uf_tmpl may change, but only as a result of</span>
<a name="line-1382"></a>                       <span class='hs-comment'>-- gentle simplification, it doesn't get updated</span>
<a name="line-1383"></a>                       <span class='hs-comment'>-- to the current RHS during compilation as with</span>
<a name="line-1384"></a>                       <span class='hs-comment'>-- InlineRhs.</span>
<a name="line-1385"></a>                       <span class='hs-comment'>--</span>
<a name="line-1386"></a>                       <span class='hs-comment'>-- See Note [InlineStable]</span>
<a name="line-1387"></a>
<a name="line-1388"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>InlineCompulsory</span>   <span class='hs-comment'>-- Something that *has* no binding, so you *must* inline it</span>
<a name="line-1389"></a>                       <span class='hs-comment'>-- Only a few primop-like things have this property</span>
<a name="line-1390"></a>                       <span class='hs-comment'>-- (see MkId.hs, calls to mkCompulsoryUnfolding).</span>
<a name="line-1391"></a>                       <span class='hs-comment'>-- Inline absolutely always, however boring the context.</span>
<a name="line-1392"></a>
<a name="line-1393"></a>
<a name="line-1394"></a>
<a name="line-1395"></a><a name="UnfoldingGuidance"></a><span class='hs-comment'>-- | 'UnfoldingGuidance' says when unfolding should take place</span>
<a name="line-1396"></a><a name="UnfoldingGuidance"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UnfoldingGuidance</span>
<a name="line-1397"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- Inline without thinking about the *size* of the uf_tmpl</span>
<a name="line-1398"></a>                <span class='hs-comment'>-- Used (a) for small *and* cheap unfoldings</span>
<a name="line-1399"></a>                <span class='hs-comment'>--      (b) for INLINE functions</span>
<a name="line-1400"></a>                <span class='hs-comment'>-- See Note [INLINE for small functions] in CoreUnfold</span>
<a name="line-1401"></a>      <span class='hs-varid'>ug_arity</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- Number of value arguments expected</span>
<a name="line-1402"></a>
<a name="line-1403"></a>      <span class='hs-varid'>ug_unsat_ok</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- True &lt;=&gt; ok to inline even if unsaturated</span>
<a name="line-1404"></a>      <span class='hs-varid'>ug_boring_ok</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>      <span class='hs-comment'>-- True &lt;=&gt; ok to inline even if the context is boring</span>
<a name="line-1405"></a>                <span class='hs-comment'>-- So True,True means "always"</span>
<a name="line-1406"></a>    <span class='hs-layout'>}</span>
<a name="line-1407"></a>
<a name="line-1408"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span>     <span class='hs-comment'>-- Arose from a normal Id; the info here is the</span>
<a name="line-1409"></a>                        <span class='hs-comment'>-- result of a simple analysis of the RHS</span>
<a name="line-1410"></a>
<a name="line-1411"></a>      <span class='hs-varid'>ug_args</span> <span class='hs-keyglyph'>::</span>  <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- Discount if the argument is evaluated.</span>
<a name="line-1412"></a>                          <span class='hs-comment'>-- (i.e., a simplification will definitely</span>
<a name="line-1413"></a>                          <span class='hs-comment'>-- be possible).  One elt of the list per *value* arg.</span>
<a name="line-1414"></a>
<a name="line-1415"></a>      <span class='hs-varid'>ug_size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- The "size" of the unfolding.</span>
<a name="line-1416"></a>
<a name="line-1417"></a>      <span class='hs-varid'>ug_res</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>       <span class='hs-comment'>-- Scrutinee discount: the discount to substract if the thing is in</span>
<a name="line-1418"></a>    <span class='hs-layout'>}</span>                     <span class='hs-comment'>-- a context (case (thing args) of ...),</span>
<a name="line-1419"></a>                          <span class='hs-comment'>-- (where there are the right number of arguments.)</span>
<a name="line-1420"></a>
<a name="line-1421"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnfNever</span>        <span class='hs-comment'>-- The RHS is big, so don't inline it</span>
<a name="line-1422"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-1423"></a>
<a name="line-1424"></a><span class='hs-comment'>{-
<a name="line-1425"></a>Note [Historical note: unfoldings for wrappers]
<a name="line-1426"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1427"></a>We used to have a nice clever scheme in interface files for
<a name="line-1428"></a>wrappers. A wrapper's unfolding can be reconstructed from its worker's
<a name="line-1429"></a>id and its strictness. This decreased .hi file size (sometimes
<a name="line-1430"></a>significantly, for modules like GHC.Classes with many high-arity w/w
<a name="line-1431"></a>splits) and had a slight corresponding effect on compile times.
<a name="line-1432"></a>
<a name="line-1433"></a>However, when we added the second demand analysis, this scheme lead to
<a name="line-1434"></a>some Core lint errors. The second analysis could change the strictness
<a name="line-1435"></a>signatures, which sometimes resulted in a wrapper's regenerated
<a name="line-1436"></a>unfolding applying the wrapper to too many arguments.
<a name="line-1437"></a>
<a name="line-1438"></a>Instead of repairing the clever .hi scheme, we abandoned it in favor
<a name="line-1439"></a>of simplicity. The .hi sizes are usually insignificant (excluding the
<a name="line-1440"></a>+1M for base libraries), and compile time barely increases (~+1% for
<a name="line-1441"></a>nofib). The nicer upshot is that the UnfoldingSource no longer mentions
<a name="line-1442"></a>an Id, so, eg, substitutions need not traverse them.
<a name="line-1443"></a>
<a name="line-1444"></a>
<a name="line-1445"></a>Note [DFun unfoldings]
<a name="line-1446"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1447"></a>The Arity in a DFunUnfolding is total number of args (type and value)
<a name="line-1448"></a>that the DFun needs to produce a dictionary.  That's not necessarily
<a name="line-1449"></a>related to the ordinary arity of the dfun Id, esp if the class has
<a name="line-1450"></a>one method, so the dictionary is represented by a newtype.  Example
<a name="line-1451"></a>
<a name="line-1452"></a>     class C a where { op :: a -&gt; Int }
<a name="line-1453"></a>     instance C a -&gt; C [a] where op xs = op (head xs)
<a name="line-1454"></a>
<a name="line-1455"></a>The instance translates to
<a name="line-1456"></a>
<a name="line-1457"></a>     $dfCList :: forall a. C a =&gt; C [a]  -- Arity 2!
<a name="line-1458"></a>     $dfCList = /\a.\d. $copList {a} d |&gt; co
<a name="line-1459"></a>
<a name="line-1460"></a>     $copList :: forall a. C a =&gt; [a] -&gt; Int  -- Arity 2!
<a name="line-1461"></a>     $copList = /\a.\d.\xs. op {a} d (head xs)
<a name="line-1462"></a>
<a name="line-1463"></a>Now we might encounter (op (dfCList {ty} d) a1 a2)
<a name="line-1464"></a>and we want the (op (dfList {ty} d)) rule to fire, because $dfCList
<a name="line-1465"></a>has all its arguments, even though its (value) arity is 2.  That's
<a name="line-1466"></a>why we record the number of expected arguments in the DFunUnfolding.
<a name="line-1467"></a>
<a name="line-1468"></a>Note that although it's an Arity, it's most convenient for it to give
<a name="line-1469"></a>the *total* number of arguments, both type and value.  See the use
<a name="line-1470"></a>site in exprIsConApp_maybe.
<a name="line-1471"></a>-}</span>
<a name="line-1472"></a>
<a name="line-1473"></a><a name="needSaturated"></a><span class='hs-comment'>-- Constants for the UnfWhen constructor</span>
<a name="line-1474"></a><span class='hs-definition'>needSaturated</span><span class='hs-layout'>,</span> <span class='hs-varid'>unSaturatedOk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1475"></a><span class='hs-definition'>needSaturated</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1476"></a><a name="unSaturatedOk"></a><span class='hs-definition'>unSaturatedOk</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1477"></a>
<a name="line-1478"></a><a name="boringCxtNotOk"></a><span class='hs-definition'>boringCxtNotOk</span><span class='hs-layout'>,</span> <span class='hs-varid'>boringCxtOk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1479"></a><a name="boringCxtOk"></a><span class='hs-definition'>boringCxtOk</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1480"></a><span class='hs-definition'>boringCxtNotOk</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1481"></a>
<a name="line-1482"></a><a name="noUnfolding"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1483"></a><span class='hs-definition'>noUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1484"></a><a name="evaldUnfolding"></a><span class='hs-comment'>-- ^ There is no known 'Unfolding'</span>
<a name="line-1485"></a><span class='hs-definition'>evaldUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1486"></a><span class='hs-comment'>-- ^ This unfolding marks the associated thing as being evaluated</span>
<a name="line-1487"></a>
<a name="line-1488"></a><span class='hs-definition'>noUnfolding</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUnfolding</span>
<a name="line-1489"></a><span class='hs-definition'>evaldUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OtherCon</span> <span class='hs-conid'>[]</span>
<a name="line-1490"></a>
<a name="line-1491"></a><a name="bootUnfolding"></a><span class='hs-comment'>-- | There is no known 'Unfolding', because this came from an</span>
<a name="line-1492"></a><span class='hs-comment'>-- hi-boot file.</span>
<a name="line-1493"></a><span class='hs-definition'>bootUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1494"></a><span class='hs-definition'>bootUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BootUnfolding</span>
<a name="line-1495"></a>
<a name="line-1496"></a><a name="mkOtherCon"></a><span class='hs-definition'>mkOtherCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1497"></a><span class='hs-definition'>mkOtherCon</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OtherCon</span>
<a name="line-1498"></a>
<a name="line-1499"></a><a name="isStableSource"></a><span class='hs-definition'>isStableSource</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingSource</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1500"></a><span class='hs-comment'>-- Keep the unfolding template</span>
<a name="line-1501"></a><span class='hs-definition'>isStableSource</span> <span class='hs-conid'>InlineCompulsory</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1502"></a><span class='hs-definition'>isStableSource</span> <span class='hs-conid'>InlineStable</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1503"></a><span class='hs-definition'>isStableSource</span> <span class='hs-conid'>InlineRhs</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1504"></a>
<a name="line-1505"></a><a name="unfoldingTemplate"></a><span class='hs-comment'>-- | Retrieves the template of an unfolding: panics if none is known</span>
<a name="line-1506"></a><span class='hs-definition'>unfoldingTemplate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1507"></a><span class='hs-definition'>unfoldingTemplate</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uf_tmpl</span>
<a name="line-1508"></a>
<a name="line-1509"></a><a name="maybeUnfoldingTemplate"></a><span class='hs-comment'>-- | Retrieves the template of an unfolding if possible</span>
<a name="line-1510"></a><span class='hs-comment'>-- maybeUnfoldingTemplate is used mainly wnen specialising, and we do</span>
<a name="line-1511"></a><span class='hs-comment'>-- want to specialise DFuns, so it's important to return a template</span>
<a name="line-1512"></a><span class='hs-comment'>-- for DFunUnfoldings</span>
<a name="line-1513"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1514"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expr</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1515"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>expr</span>
<a name="line-1516"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>df_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>df_con</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>df_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1517"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1518"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-keyword'>_</span>
<a name="line-1519"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1520"></a>
<a name="line-1521"></a><a name="otherCons"></a><span class='hs-comment'>-- | The constructors that the unfolding could never be:</span>
<a name="line-1522"></a><span class='hs-comment'>-- returns @[]@ if no information is available</span>
<a name="line-1523"></a><span class='hs-definition'>otherCons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span>
<a name="line-1524"></a><span class='hs-definition'>otherCons</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherCon</span> <span class='hs-varid'>cons</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cons</span>
<a name="line-1525"></a><span class='hs-definition'>otherCons</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1526"></a>
<a name="line-1527"></a><a name="isValueUnfolding"></a><span class='hs-comment'>-- | Determines if it is certainly the case that the unfolding will</span>
<a name="line-1528"></a><span class='hs-comment'>-- yield a value (something in HNF): returns @False@ if unsure</span>
<a name="line-1529"></a><span class='hs-definition'>isValueUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1530"></a>        <span class='hs-comment'>-- Returns False for OtherCon</span>
<a name="line-1531"></a><span class='hs-definition'>isValueUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_value</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span>
<a name="line-1532"></a><span class='hs-definition'>isValueUnfolding</span> <span class='hs-keyword'>_</span>                                          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1533"></a>
<a name="line-1534"></a><a name="isEvaldUnfolding"></a><span class='hs-comment'>-- | Determines if it possibly the case that the unfolding will</span>
<a name="line-1535"></a><span class='hs-comment'>-- yield a value. Unlike 'isValueUnfolding' it returns @True@</span>
<a name="line-1536"></a><span class='hs-comment'>-- for 'OtherCon'</span>
<a name="line-1537"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1538"></a>        <span class='hs-comment'>-- Returns True for OtherCon</span>
<a name="line-1539"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherCon</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1540"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_value</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span>
<a name="line-1541"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-keyword'>_</span>                                          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1542"></a>
<a name="line-1543"></a><a name="isConLikeUnfolding"></a><span class='hs-comment'>-- | @True@ if the unfolding is a constructor application, the application</span>
<a name="line-1544"></a><span class='hs-comment'>-- of a CONLIKE function or 'OtherCon'</span>
<a name="line-1545"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1546"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherCon</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1547"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_conlike</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span>
<a name="line-1548"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-keyword'>_</span>                                        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1549"></a>
<a name="line-1550"></a><a name="isCheapUnfolding"></a><span class='hs-comment'>-- | Is the thing we will unfold into certainly cheap?</span>
<a name="line-1551"></a><span class='hs-definition'>isCheapUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1552"></a><span class='hs-definition'>isCheapUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_work_free</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_wf</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_wf</span>
<a name="line-1553"></a><span class='hs-definition'>isCheapUnfolding</span> <span class='hs-keyword'>_</span>                                           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1554"></a>
<a name="line-1555"></a><a name="isExpandableUnfolding"></a><span class='hs-definition'>isExpandableUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1556"></a><span class='hs-definition'>isExpandableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_expandable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_expable</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_expable</span>
<a name="line-1557"></a><span class='hs-definition'>isExpandableUnfolding</span> <span class='hs-keyword'>_</span>                                              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1558"></a>
<a name="line-1559"></a><a name="expandUnfolding_maybe"></a><span class='hs-definition'>expandUnfolding_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1560"></a><span class='hs-comment'>-- Expand an expandable unfolding; this is used in rule matching</span>
<a name="line-1561"></a><span class='hs-comment'>--   See Note [Expanding variables] in Rules.hs</span>
<a name="line-1562"></a><span class='hs-comment'>-- The key point here is that CONLIKE things can be expanded</span>
<a name="line-1563"></a><span class='hs-definition'>expandUnfolding_maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_expandable</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs</span>
<a name="line-1564"></a><span class='hs-definition'>expandUnfolding_maybe</span> <span class='hs-keyword'>_</span>                                                       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1565"></a>
<a name="line-1566"></a><a name="isCompulsoryUnfolding"></a><span class='hs-definition'>isCompulsoryUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1567"></a><span class='hs-definition'>isCompulsoryUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InlineCompulsory</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1568"></a><span class='hs-definition'>isCompulsoryUnfolding</span> <span class='hs-keyword'>_</span>                                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1569"></a>
<a name="line-1570"></a><a name="isStableUnfolding"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1571"></a><span class='hs-comment'>-- True of unfoldings that should not be overwritten</span>
<a name="line-1572"></a><span class='hs-comment'>-- by a CoreUnfolding for the RHS of a let-binding</span>
<a name="line-1573"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStableSource</span> <span class='hs-varid'>src</span>
<a name="line-1574"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1575"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-keyword'>_</span>                                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1576"></a>
<a name="line-1577"></a><a name="hasSomeUnfolding"></a><span class='hs-comment'>-- | Only returns False if there is no unfolding information available at all</span>
<a name="line-1578"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1579"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-conid'>NoUnfolding</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1580"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-conid'>BootUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1581"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1582"></a>
<a name="line-1583"></a><a name="isBootUnfolding"></a><span class='hs-definition'>isBootUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1584"></a><span class='hs-definition'>isBootUnfolding</span> <span class='hs-conid'>BootUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1585"></a><span class='hs-definition'>isBootUnfolding</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1586"></a>
<a name="line-1587"></a><a name="neverUnfoldGuidance"></a><span class='hs-definition'>neverUnfoldGuidance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingGuidance</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1588"></a><span class='hs-definition'>neverUnfoldGuidance</span> <span class='hs-conid'>UnfNever</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1589"></a><span class='hs-definition'>neverUnfoldGuidance</span> <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1590"></a>
<a name="line-1591"></a><a name="isFragileUnfolding"></a><span class='hs-definition'>isFragileUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1592"></a><span class='hs-comment'>-- An unfolding is fragile if it mentions free variables or</span>
<a name="line-1593"></a><span class='hs-comment'>-- is otherwise subject to change.  A robust one can be kept.</span>
<a name="line-1594"></a><span class='hs-comment'>-- See Note [Fragile unfoldings]</span>
<a name="line-1595"></a><span class='hs-definition'>isFragileUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1596"></a><span class='hs-definition'>isFragileUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1597"></a><span class='hs-definition'>isFragileUnfolding</span> <span class='hs-keyword'>_</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1598"></a>  <span class='hs-comment'>-- NoUnfolding, BootUnfolding, OtherCon are all non-fragile</span>
<a name="line-1599"></a>
<a name="line-1600"></a><a name="canUnfold"></a><span class='hs-definition'>canUnfold</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1601"></a><span class='hs-definition'>canUnfold</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>neverUnfoldGuidance</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-1602"></a><span class='hs-definition'>canUnfold</span> <span class='hs-keyword'>_</span>                                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1603"></a>
<a name="line-1604"></a><span class='hs-comment'>{- Note [Fragile unfoldings]
<a name="line-1605"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1606"></a>An unfolding is "fragile" if it mentions free variables (and hence would
<a name="line-1607"></a>need substitution) or might be affected by optimisation.  The non-fragile
<a name="line-1608"></a>ones are
<a name="line-1609"></a>
<a name="line-1610"></a>   NoUnfolding, BootUnfolding
<a name="line-1611"></a>
<a name="line-1612"></a>   OtherCon {}    If we know this binder (say a lambda binder) will be
<a name="line-1613"></a>                  bound to an evaluated thing, we want to retain that
<a name="line-1614"></a>                  info in simpleOptExpr; see Trac #13077.
<a name="line-1615"></a>
<a name="line-1616"></a>We consider even a StableUnfolding as fragile, because it needs substitution.
<a name="line-1617"></a>
<a name="line-1618"></a>Note [InlineStable]
<a name="line-1619"></a>~~~~~~~~~~~~~~~~~
<a name="line-1620"></a>When you say
<a name="line-1621"></a>      {-# INLINE f #-}
<a name="line-1622"></a>      f x = &lt;rhs&gt;
<a name="line-1623"></a>you intend that calls (f e) are replaced by &lt;rhs&gt;[e/x] So we
<a name="line-1624"></a>should capture (\x.&lt;rhs&gt;) in the Unfolding of 'f', and never meddle
<a name="line-1625"></a>with it.  Meanwhile, we can optimise &lt;rhs&gt; to our heart's content,
<a name="line-1626"></a>leaving the original unfolding intact in Unfolding of 'f'. For example
<a name="line-1627"></a>        all xs = foldr (&amp;&amp;) True xs
<a name="line-1628"></a>        any p = all . map p  {-# INLINE any #-}
<a name="line-1629"></a>We optimise any's RHS fully, but leave the InlineRule saying "all . map p",
<a name="line-1630"></a>which deforests well at the call site.
<a name="line-1631"></a>
<a name="line-1632"></a>So INLINE pragma gives rise to an InlineRule, which captures the original RHS.
<a name="line-1633"></a>
<a name="line-1634"></a>Moreover, it's only used when 'f' is applied to the
<a name="line-1635"></a>specified number of arguments; that is, the number of argument on
<a name="line-1636"></a>the LHS of the '=' sign in the original source definition.
<a name="line-1637"></a>For example, (.) is now defined in the libraries like this
<a name="line-1638"></a>   {-# INLINE (.) #-}
<a name="line-1639"></a>   (.) f g = \x -&gt; f (g x)
<a name="line-1640"></a>so that it'll inline when applied to two arguments. If 'x' appeared
<a name="line-1641"></a>on the left, thus
<a name="line-1642"></a>   (.) f g x = f (g x)
<a name="line-1643"></a>it'd only inline when applied to three arguments.  This slightly-experimental
<a name="line-1644"></a>change was requested by Roman, but it seems to make sense.
<a name="line-1645"></a>
<a name="line-1646"></a>See also Note [Inlining an InlineRule] in CoreUnfold.
<a name="line-1647"></a>
<a name="line-1648"></a>
<a name="line-1649"></a>Note [OccInfo in unfoldings and rules]
<a name="line-1650"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1651"></a>In unfoldings and rules, we guarantee that the template is occ-analysed,
<a name="line-1652"></a>so that the occurrence info on the binders is correct.  This is important,
<a name="line-1653"></a>because the Simplifier does not re-analyse the template when using it. If
<a name="line-1654"></a>the occurrence info is wrong
<a name="line-1655"></a>  - We may get more simplifier iterations than necessary, because
<a name="line-1656"></a>    once-occ info isn't there
<a name="line-1657"></a>  - More seriously, we may get an infinite loop if there's a Rec
<a name="line-1658"></a>    without a loop breaker marked
<a name="line-1659"></a>
<a name="line-1660"></a>
<a name="line-1661"></a>************************************************************************
<a name="line-1662"></a>*                                                                      *
<a name="line-1663"></a>                  AltCon
<a name="line-1664"></a>*                                                                      *
<a name="line-1665"></a>************************************************************************
<a name="line-1666"></a>-}</span>
<a name="line-1667"></a>
<a name="line-1668"></a><span class='hs-comment'>-- The Ord is needed for the FiniteMap used in the lookForConstructor</span>
<a name="line-1669"></a><span class='hs-comment'>-- in SimplEnv.  If you declared that lookForConstructor *ignores*</span>
<a name="line-1670"></a><span class='hs-comment'>-- constructor-applications with LitArg args, then you could get</span>
<a name="line-1671"></a><span class='hs-comment'>-- rid of this Ord.</span>
<a name="line-1672"></a>
<a name="line-1673"></a><a name="instance%20Outputable%20AltCon"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyword'>where</span>
<a name="line-1674"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dc</span>
<a name="line-1675"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>lit</span>
<a name="line-1676"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"__DEFAULT"</span>
<a name="line-1677"></a>
<a name="line-1678"></a><a name="cmpAlt"></a><span class='hs-definition'>cmpAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-1679"></a><span class='hs-definition'>cmpAlt</span> <span class='hs-layout'>(</span><span class='hs-varid'>con1</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>con2</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con1</span> <span class='hs-varop'>`cmpAltCon`</span> <span class='hs-varid'>con2</span>
<a name="line-1680"></a>
<a name="line-1681"></a><a name="ltAlt"></a><span class='hs-definition'>ltAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1682"></a><span class='hs-definition'>ltAlt</span> <span class='hs-varid'>a1</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-varop'>`cmpAlt`</span> <span class='hs-varid'>a2</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-conid'>LT</span>
<a name="line-1683"></a>
<a name="line-1684"></a><a name="cmpAltCon"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-1685"></a><span class='hs-comment'>-- ^ Compares 'AltCon's within a single list of alternatives</span>
<a name="line-1686"></a><span class='hs-comment'>-- DEFAULT comes out smallest, so that sorting by AltCon</span>
<a name="line-1687"></a><span class='hs-comment'>-- puts alternatives in the order required by #case_invariants#</span>
<a name="line-1688"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-conid'>DEFAULT</span>      <span class='hs-conid'>DEFAULT</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-1689"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-1690"></a>
<a name="line-1691"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>d1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>d2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConTag</span> <span class='hs-varid'>d1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>dataConTag</span> <span class='hs-varid'>d2</span>
<a name="line-1692"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-1693"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span>  <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span>  <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>l2</span>
<a name="line-1694"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-1695"></a>
<a name="line-1696"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-varid'>con1</span> <span class='hs-varid'>con2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Comparing incomparable AltCons"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-1697"></a>                                  <span class='hs-varid'>ppr</span> <span class='hs-varid'>con1</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con2</span> <span class='hs-layout'>)</span>
<a name="line-1698"></a>                      <span class='hs-conid'>LT</span>
<a name="line-1699"></a>
<a name="line-1700"></a><span class='hs-comment'>{-
<a name="line-1701"></a>************************************************************************
<a name="line-1702"></a>*                                                                      *
<a name="line-1703"></a>\subsection{Useful synonyms}
<a name="line-1704"></a>*                                                                      *
<a name="line-1705"></a>************************************************************************
<a name="line-1706"></a>
<a name="line-1707"></a>Note [CoreProgram]
<a name="line-1708"></a>~~~~~~~~~~~~~~~~~~
<a name="line-1709"></a>The top level bindings of a program, a CoreProgram, are represented as
<a name="line-1710"></a>a list of CoreBind
<a name="line-1711"></a>
<a name="line-1712"></a> * Later bindings in the list can refer to earlier ones, but not vice
<a name="line-1713"></a>   versa.  So this is OK
<a name="line-1714"></a>      NonRec { x = 4 }
<a name="line-1715"></a>      Rec { p = ...q...x...
<a name="line-1716"></a>          ; q = ...p...x }
<a name="line-1717"></a>      Rec { f = ...p..x..f.. }
<a name="line-1718"></a>      NonRec { g = ..f..q...x.. }
<a name="line-1719"></a>   But it would NOT be ok for 'f' to refer to 'g'.
<a name="line-1720"></a>
<a name="line-1721"></a> * The occurrence analyser does strongly-connected component analysis
<a name="line-1722"></a>   on each Rec binding, and splits it into a sequence of smaller
<a name="line-1723"></a>   bindings where possible.  So the program typically starts life as a
<a name="line-1724"></a>   single giant Rec, which is then dependency-analysed into smaller
<a name="line-1725"></a>   chunks.
<a name="line-1726"></a>-}</span>
<a name="line-1727"></a>
<a name="line-1728"></a><a name="CoreProgram"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-1729"></a><a name="CoreProgram"></a><span class='hs-comment'>-- See Note [GHC Formalism] in coreSyn/CoreLint.hs</span>
<a name="line-1730"></a><a name="CoreProgram"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- See Note [CoreProgram]</span>
<a name="line-1731"></a>
<a name="line-1732"></a><a name="CoreBndr"></a><span class='hs-comment'>-- | The common case for the type of binders and variables when</span>
<a name="line-1733"></a><a name="CoreBndr"></a><span class='hs-comment'>-- we are manipulating the Core language within GHC</span>
<a name="line-1734"></a><a name="CoreBndr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span>
<a name="line-1735"></a><a name="CoreExpr"></a><span class='hs-comment'>-- | Expressions where binders are 'CoreBndr's</span>
<a name="line-1736"></a><a name="CoreExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-1737"></a><a name="CoreArg"></a><span class='hs-comment'>-- | Argument expressions where binders are 'CoreBndr's</span>
<a name="line-1738"></a><a name="CoreArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreArg</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Arg</span>  <span class='hs-conid'>CoreBndr</span>
<a name="line-1739"></a><a name="CoreBind"></a><span class='hs-comment'>-- | Binding groups where binders are 'CoreBndr's</span>
<a name="line-1740"></a><a name="CoreBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreBind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bind</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-1741"></a><a name="CoreAlt"></a><span class='hs-comment'>-- | Case alternatives where binders are 'CoreBndr's</span>
<a name="line-1742"></a><a name="CoreAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreAlt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span>  <span class='hs-conid'>CoreBndr</span>
<a name="line-1743"></a>
<a name="line-1744"></a><span class='hs-comment'>{-
<a name="line-1745"></a>************************************************************************
<a name="line-1746"></a>*                                                                      *
<a name="line-1747"></a>\subsection{Tagging}
<a name="line-1748"></a>*                                                                      *
<a name="line-1749"></a>************************************************************************
<a name="line-1750"></a>-}</span>
<a name="line-1751"></a>
<a name="line-1752"></a><a name="TaggedBndr"></a><span class='hs-comment'>-- | Binders are /tagged/ with a t</span>
<a name="line-1753"></a><a name="TaggedBndr"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TB</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-varid'>t</span>       <span class='hs-comment'>-- TB for "tagged binder"</span>
<a name="line-1754"></a>
<a name="line-1755"></a><a name="TaggedBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedBind</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bind</span> <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1756"></a><a name="TaggedExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedExpr</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1757"></a><a name="TaggedArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedArg</span>  <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Arg</span>  <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1758"></a><a name="TaggedAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedAlt</span>  <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span>  <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1759"></a>
<a name="line-1760"></a><a name="instance%20Outputable%20(TaggedBndr%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1761"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'&lt;'</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>comma</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>l</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'&gt;'</span>
<a name="line-1762"></a>
<a name="line-1763"></a><a name="deTagExpr"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TaggedExpr</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1764"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span>
<a name="line-1765"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>l</span>
<a name="line-1766"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span>
<a name="line-1767"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span>
<a name="line-1768"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>App</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>
<a name="line-1769"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1770"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagBind</span> <span class='hs-varid'>bind</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1771"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>deTagAlt</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-1772"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1773"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-1774"></a>
<a name="line-1775"></a><a name="deTagBind"></a><span class='hs-definition'>deTagBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TaggedBind</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-1776"></a><span class='hs-definition'>deTagBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1777"></a><span class='hs-definition'>deTagBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Rec</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>prs</span><span class='hs-keyglyph'>]</span>
<a name="line-1778"></a>
<a name="line-1779"></a><a name="deTagAlt"></a><span class='hs-definition'>deTagAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TaggedAlt</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreAlt</span>
<a name="line-1780"></a><span class='hs-definition'>deTagAlt</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1781"></a>
<a name="line-1782"></a><span class='hs-comment'>{-
<a name="line-1783"></a>************************************************************************
<a name="line-1784"></a>*                                                                      *
<a name="line-1785"></a>\subsection{Core-constructing functions with checking}
<a name="line-1786"></a>*                                                                      *
<a name="line-1787"></a>************************************************************************
<a name="line-1788"></a>-}</span>
<a name="line-1789"></a>
<a name="line-1790"></a><a name="mkApps"></a><span class='hs-comment'>-- | Apply a list of argument expressions to a function expression in a nested fashion. Prefer to</span>
<a name="line-1791"></a><span class='hs-comment'>-- use 'MkCore.mkCoreApps' if possible</span>
<a name="line-1792"></a><span class='hs-definition'>mkApps</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1793"></a><a name="mkTyApps"></a><span class='hs-comment'>-- | Apply a list of type argument expressions to a function expression in a nested fashion</span>
<a name="line-1794"></a><span class='hs-definition'>mkTyApps</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1795"></a><a name="mkCoApps"></a><span class='hs-comment'>-- | Apply a list of coercion argument expressions to a function expression in a nested fashion</span>
<a name="line-1796"></a><span class='hs-definition'>mkCoApps</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1797"></a><a name="mkVarApps"></a><span class='hs-comment'>-- | Apply a list of type or value variables to a function expression in a nested fashion</span>
<a name="line-1798"></a><span class='hs-definition'>mkVarApps</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1799"></a><a name="mkConApp"></a><span class='hs-comment'>-- | Apply a list of argument expressions to a data constructor in a nested fashion. Prefer to</span>
<a name="line-1800"></a><span class='hs-comment'>-- use 'MkCore.mkCoreConApps' if possible</span>
<a name="line-1801"></a><span class='hs-definition'>mkConApp</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1802"></a>
<a name="line-1803"></a><span class='hs-definition'>mkApps</span>    <span class='hs-varid'>f</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-conid'>App</span>                       <span class='hs-varid'>f</span> <span class='hs-varid'>args</span>
<a name="line-1804"></a><span class='hs-definition'>mkCoApps</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>args</span>
<a name="line-1805"></a><span class='hs-definition'>mkVarApps</span> <span class='hs-varid'>f</span> <span class='hs-varid'>vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>vars</span>
<a name="line-1806"></a><span class='hs-definition'>mkConApp</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-1807"></a>
<a name="line-1808"></a><span class='hs-definition'>mkTyApps</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyArg</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>args</span>
<a name="line-1809"></a>
<a name="line-1810"></a><a name="mkConApp2"></a><span class='hs-definition'>mkConApp2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1811"></a><span class='hs-definition'>mkConApp2</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>arg_ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-1812"></a>                            <span class='hs-varop'>`mkApps`</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>tys</span>
<a name="line-1813"></a>                            <span class='hs-varop'>`mkApps`</span> <span class='hs-varid'>map</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>arg_ids</span>
<a name="line-1814"></a>
<a name="line-1815"></a><a name="mkTyArg"></a><span class='hs-definition'>mkTyArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1816"></a><span class='hs-definition'>mkTyArg</span> <span class='hs-varid'>ty</span>
<a name="line-1817"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isCoercionTy_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span>
<a name="line-1818"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span>
<a name="line-1819"></a>
<a name="line-1820"></a><a name="mkIntLit"></a><span class='hs-comment'>-- | Create a machine integer literal expression of type @Int#@ from an @Integer@.</span>
<a name="line-1821"></a><span class='hs-comment'>-- If you want an expression of type @Int@ use 'MkCore.mkIntExpr'</span>
<a name="line-1822"></a><span class='hs-definition'>mkIntLit</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1823"></a><a name="mkIntLitInt"></a><span class='hs-comment'>-- | Create a machine integer literal expression of type @Int#@ from an @Int@.</span>
<a name="line-1824"></a><span class='hs-comment'>-- If you want an expression of type @Int@ use 'MkCore.mkIntExpr'</span>
<a name="line-1825"></a><span class='hs-definition'>mkIntLitInt</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1826"></a>
<a name="line-1827"></a><span class='hs-definition'>mkIntLit</span>    <span class='hs-varid'>dflags</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachInt</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-1828"></a><span class='hs-definition'>mkIntLitInt</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachInt</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>toInteger</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1829"></a>
<a name="line-1830"></a><a name="mkWordLit"></a><span class='hs-comment'>-- | Create a machine word literal expression of type  @Word#@ from an @Integer@.</span>
<a name="line-1831"></a><span class='hs-comment'>-- If you want an expression of type @Word@ use 'MkCore.mkWordExpr'</span>
<a name="line-1832"></a><span class='hs-definition'>mkWordLit</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1833"></a><a name="mkWordLitWord"></a><span class='hs-comment'>-- | Create a machine word literal expression of type  @Word#@ from a @Word@.</span>
<a name="line-1834"></a><span class='hs-comment'>-- If you want an expression of type @Word@ use 'MkCore.mkWordExpr'</span>
<a name="line-1835"></a><span class='hs-definition'>mkWordLitWord</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1836"></a>
<a name="line-1837"></a><span class='hs-definition'>mkWordLit</span>     <span class='hs-varid'>dflags</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachWord</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span>
<a name="line-1838"></a><span class='hs-definition'>mkWordLitWord</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachWord</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>toInteger</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1839"></a>
<a name="line-1840"></a><a name="mkWord64LitWord64"></a><span class='hs-definition'>mkWord64LitWord64</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word64</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1841"></a><span class='hs-definition'>mkWord64LitWord64</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachWord64</span> <span class='hs-layout'>(</span><span class='hs-varid'>toInteger</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1842"></a>
<a name="line-1843"></a><a name="mkInt64LitInt64"></a><span class='hs-definition'>mkInt64LitInt64</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int64</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1844"></a><span class='hs-definition'>mkInt64LitInt64</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachInt64</span> <span class='hs-layout'>(</span><span class='hs-varid'>toInteger</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1845"></a>
<a name="line-1846"></a><a name="mkCharLit"></a><span class='hs-comment'>-- | Create a machine character literal expression of type @Char#@.</span>
<a name="line-1847"></a><span class='hs-comment'>-- If you want an expression of type @Char@ use 'MkCore.mkCharExpr'</span>
<a name="line-1848"></a><span class='hs-definition'>mkCharLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1849"></a><a name="mkStringLit"></a><span class='hs-comment'>-- | Create a machine string literal expression of type @Addr#@.</span>
<a name="line-1850"></a><span class='hs-comment'>-- If you want an expression of type @String@ use 'MkCore.mkStringExpr'</span>
<a name="line-1851"></a><span class='hs-definition'>mkStringLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1852"></a>
<a name="line-1853"></a><span class='hs-definition'>mkCharLit</span>   <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachChar</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-1854"></a><span class='hs-definition'>mkStringLit</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachString</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-1855"></a>
<a name="line-1856"></a><a name="mkFloatLit"></a><span class='hs-comment'>-- | Create a machine single precision literal expression of type @Float#@ from a @Rational@.</span>
<a name="line-1857"></a><span class='hs-comment'>-- If you want an expression of type @Float@ use 'MkCore.mkFloatExpr'</span>
<a name="line-1858"></a><span class='hs-definition'>mkFloatLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rational</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1859"></a><a name="mkFloatLitFloat"></a><span class='hs-comment'>-- | Create a machine single precision literal expression of type @Float#@ from a @Float@.</span>
<a name="line-1860"></a><span class='hs-comment'>-- If you want an expression of type @Float@ use 'MkCore.mkFloatExpr'</span>
<a name="line-1861"></a><span class='hs-definition'>mkFloatLitFloat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Float</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1862"></a>
<a name="line-1863"></a><span class='hs-definition'>mkFloatLit</span>      <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachFloat</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-1864"></a><span class='hs-definition'>mkFloatLitFloat</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachFloat</span> <span class='hs-layout'>(</span><span class='hs-varid'>toRational</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1865"></a>
<a name="line-1866"></a><a name="mkDoubleLit"></a><span class='hs-comment'>-- | Create a machine double precision literal expression of type @Double#@ from a @Rational@.</span>
<a name="line-1867"></a><span class='hs-comment'>-- If you want an expression of type @Double@ use 'MkCore.mkDoubleExpr'</span>
<a name="line-1868"></a><span class='hs-definition'>mkDoubleLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rational</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1869"></a><a name="mkDoubleLitDouble"></a><span class='hs-comment'>-- | Create a machine double precision literal expression of type @Double#@ from a @Double@.</span>
<a name="line-1870"></a><span class='hs-comment'>-- If you want an expression of type @Double@ use 'MkCore.mkDoubleExpr'</span>
<a name="line-1871"></a><span class='hs-definition'>mkDoubleLitDouble</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1872"></a>
<a name="line-1873"></a><span class='hs-definition'>mkDoubleLit</span>       <span class='hs-varid'>d</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachDouble</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-1874"></a><span class='hs-definition'>mkDoubleLitDouble</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkMachDouble</span> <span class='hs-layout'>(</span><span class='hs-varid'>toRational</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1875"></a>
<a name="line-1876"></a><a name="mkLets"></a><span class='hs-comment'>-- | Bind all supplied binding groups over an expression in a nested let expression. Assumes</span>
<a name="line-1877"></a><span class='hs-comment'>-- that the rhs satisfies the let/app invariant.  Prefer to use 'MkCore.mkCoreLets' if</span>
<a name="line-1878"></a><span class='hs-comment'>-- possible, which does guarantee the invariant</span>
<a name="line-1879"></a><span class='hs-definition'>mkLets</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1880"></a><a name="mkLams"></a><span class='hs-comment'>-- | Bind all supplied binders over an expression in a nested lambda expression. Prefer to</span>
<a name="line-1881"></a><span class='hs-comment'>-- use 'MkCore.mkCoreLams' if possible</span>
<a name="line-1882"></a><span class='hs-definition'>mkLams</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1883"></a>
<a name="line-1884"></a><span class='hs-definition'>mkLams</span> <span class='hs-varid'>binders</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>body</span> <span class='hs-varid'>binders</span>
<a name="line-1885"></a><span class='hs-definition'>mkLets</span> <span class='hs-varid'>binds</span> <span class='hs-varid'>body</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkLet</span> <span class='hs-varid'>body</span> <span class='hs-varid'>binds</span>
<a name="line-1886"></a>
<a name="line-1887"></a><a name="mkLet"></a><span class='hs-definition'>mkLet</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1888"></a><span class='hs-comment'>-- The desugarer sometimes generates an empty Rec group</span>
<a name="line-1889"></a><span class='hs-comment'>-- which Lint rejects, so we kill it off right away</span>
<a name="line-1890"></a><span class='hs-definition'>mkLet</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1891"></a><span class='hs-definition'>mkLet</span> <span class='hs-varid'>bind</span>     <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span>
<a name="line-1892"></a>
<a name="line-1893"></a><a name="mkLetNonRec"></a><span class='hs-comment'>-- | @mkLetNonRec bndr rhs body@ wraps @body@ in a @let@ binding @bndr@.</span>
<a name="line-1894"></a><span class='hs-definition'>mkLetNonRec</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1895"></a><span class='hs-definition'>mkLetNonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-1896"></a>
<a name="line-1897"></a><a name="mkLetRec"></a><span class='hs-comment'>-- | @mkLetRec binds body@ wraps @body@ in a @let rec@ with the given set of</span>
<a name="line-1898"></a><span class='hs-comment'>-- @binds@ if binds is non-empty.</span>
<a name="line-1899"></a><span class='hs-definition'>mkLetRec</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1900"></a><span class='hs-definition'>mkLetRec</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1901"></a><span class='hs-definition'>mkLetRec</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-1902"></a>
<a name="line-1903"></a><a name="mkTyBind"></a><span class='hs-comment'>-- | Create a binding group where a type variable is bound to a type. Per "CoreSyn#type_let",</span>
<a name="line-1904"></a><span class='hs-comment'>-- this can only be used to bind something in a non-recursive @let@ expression</span>
<a name="line-1905"></a><span class='hs-definition'>mkTyBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-1906"></a><span class='hs-definition'>mkTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1907"></a>
<a name="line-1908"></a><a name="mkCoBind"></a><span class='hs-comment'>-- | Create a binding group where a type variable is bound to a type. Per "CoreSyn#type_let",</span>
<a name="line-1909"></a><span class='hs-comment'>-- this can only be used to bind something in a non-recursive @let@ expression</span>
<a name="line-1910"></a><span class='hs-definition'>mkCoBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-1911"></a><span class='hs-definition'>mkCoBind</span> <span class='hs-varid'>cv</span> <span class='hs-varid'>co</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1912"></a>
<a name="line-1913"></a><a name="varToCoreExpr"></a><span class='hs-comment'>-- | Convert a binder into either a 'Var' or 'Type' 'Expr' appropriately</span>
<a name="line-1914"></a><span class='hs-definition'>varToCoreExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1915"></a><span class='hs-definition'>varToCoreExpr</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1916"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoVarCo</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1917"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span> <span class='hs-layout'>)</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span>
<a name="line-1918"></a>
<a name="line-1919"></a><a name="varsToCoreExprs"></a><span class='hs-definition'>varsToCoreExprs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1920"></a><span class='hs-definition'>varsToCoreExprs</span> <span class='hs-varid'>vs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>vs</span>
<a name="line-1921"></a>
<a name="line-1922"></a><span class='hs-comment'>{-
<a name="line-1923"></a>************************************************************************
<a name="line-1924"></a>*                                                                      *
<a name="line-1925"></a>   Getting a result type
<a name="line-1926"></a>*                                                                      *
<a name="line-1927"></a>************************************************************************
<a name="line-1928"></a>
<a name="line-1929"></a>These are defined here to avoid a module loop between CoreUtils and CoreFVs
<a name="line-1930"></a>
<a name="line-1931"></a>-}</span>
<a name="line-1932"></a>
<a name="line-1933"></a><a name="applyTypeToArg"></a><span class='hs-definition'>applyTypeToArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1934"></a><span class='hs-comment'>-- ^ Determines the type resulting from applying an expression with given type</span>
<a name="line-1935"></a><span class='hs-comment'>-- to a given argument expression</span>
<a name="line-1936"></a><span class='hs-definition'>applyTypeToArg</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>piResultTy</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprToType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-1937"></a>
<a name="line-1938"></a><a name="exprToType"></a><span class='hs-comment'>-- | If the expression is a 'Type', converts. Otherwise,</span>
<a name="line-1939"></a><span class='hs-comment'>-- panics. NB: This does /not/ convert 'Coercion' to 'CoercionTy'.</span>
<a name="line-1940"></a><span class='hs-definition'>exprToType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1941"></a><span class='hs-definition'>exprToType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-1942"></a><span class='hs-definition'>exprToType</span> <span class='hs-sel'>_bad</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"exprToType"</span> <span class='hs-varid'>empty</span>
<a name="line-1943"></a>
<a name="line-1944"></a><a name="exprToCoercion_maybe"></a><span class='hs-comment'>-- | If the expression is a 'Coercion', converts.</span>
<a name="line-1945"></a><span class='hs-definition'>exprToCoercion_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Coercion</span>
<a name="line-1946"></a><span class='hs-definition'>exprToCoercion_maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>co</span>
<a name="line-1947"></a><span class='hs-definition'>exprToCoercion_maybe</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1948"></a>
<a name="line-1949"></a><span class='hs-comment'>{-
<a name="line-1950"></a>************************************************************************
<a name="line-1951"></a>*                                                                      *
<a name="line-1952"></a>\subsection{Simple access functions}
<a name="line-1953"></a>*                                                                      *
<a name="line-1954"></a>************************************************************************
<a name="line-1955"></a>-}</span>
<a name="line-1956"></a>
<a name="line-1957"></a><a name="bindersOf"></a><span class='hs-comment'>-- | Extract every variable by this group</span>
<a name="line-1958"></a><span class='hs-definition'>bindersOf</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1959"></a><span class='hs-comment'>-- If you edit this function, you may need to update the GHC formalism</span>
<a name="line-1960"></a><span class='hs-comment'>-- See Note [GHC Formalism] in coreSyn/CoreLint.hs</span>
<a name="line-1961"></a><span class='hs-definition'>bindersOf</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>binder</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>binder</span><span class='hs-keyglyph'>]</span>
<a name="line-1962"></a><span class='hs-definition'>bindersOf</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>binder</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>binder</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span><span class='hs-keyglyph'>]</span>
<a name="line-1963"></a>
<a name="line-1964"></a><a name="bindersOfBinds"></a><span class='hs-comment'>-- | 'bindersOf' applied to a list of binding groups</span>
<a name="line-1965"></a><span class='hs-definition'>bindersOfBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1966"></a><span class='hs-definition'>bindersOfBinds</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>bindersOf</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>binds</span>
<a name="line-1967"></a>
<a name="line-1968"></a><a name="rhssOfBind"></a><span class='hs-definition'>rhssOfBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1969"></a><span class='hs-definition'>rhssOfBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>rhs</span><span class='hs-keyglyph'>]</span>
<a name="line-1970"></a><span class='hs-definition'>rhssOfBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span><span class='hs-keyglyph'>]</span>
<a name="line-1971"></a>
<a name="line-1972"></a><a name="rhssOfAlts"></a><span class='hs-definition'>rhssOfAlts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1973"></a><span class='hs-definition'>rhssOfAlts</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>alts</span><span class='hs-keyglyph'>]</span>
<a name="line-1974"></a>
<a name="line-1975"></a><a name="flattenBinds"></a><span class='hs-comment'>-- | Collapse all the bindings in the supplied groups into a single</span>
<a name="line-1976"></a><span class='hs-comment'>-- list of lhs\/rhs pairs suitable for binding in a 'Rec' binding group</span>
<a name="line-1977"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1978"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>r</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>flattenBinds</span> <span class='hs-varid'>binds</span>
<a name="line-1979"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs1</span>   <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prs1</span> <span class='hs-varop'>++</span> <span class='hs-varid'>flattenBinds</span> <span class='hs-varid'>binds</span>
<a name="line-1980"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-conid'>[]</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1981"></a>
<a name="line-1982"></a><a name="collectBinders"></a><span class='hs-comment'>-- | We often want to strip off leading lambdas before getting down to</span>
<a name="line-1983"></a><span class='hs-comment'>-- business. Variants are 'collectTyBinders', 'collectValBinders',</span>
<a name="line-1984"></a><span class='hs-comment'>-- and 'collectTyAndValBinders'</span>
<a name="line-1985"></a><span class='hs-definition'>collectBinders</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>     <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-1986"></a><a name="collectTyBinders"></a><span class='hs-definition'>collectTyBinders</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1987"></a><a name="collectValBinders"></a><span class='hs-definition'>collectValBinders</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1988"></a><a name="collectTyAndValBinders"></a><span class='hs-definition'>collectTyAndValBinders</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1989"></a><a name="collectNBinders"></a><span class='hs-comment'>-- | Strip off exactly N leading lambdas (type or value). Good for use with</span>
<a name="line-1990"></a><span class='hs-comment'>-- join points.</span>
<a name="line-1991"></a><span class='hs-definition'>collectNBinders</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-1992"></a>
<a name="line-1993"></a><span class='hs-definition'>collectBinders</span> <span class='hs-varid'>expr</span>
<a name="line-1994"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>expr</span>
<a name="line-1995"></a>  <span class='hs-keyword'>where</span>
<a name="line-1996"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1997"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>e</span>          <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1998"></a>
<a name="line-1999"></a><span class='hs-definition'>collectTyBinders</span> <span class='hs-varid'>expr</span>
<a name="line-2000"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>expr</span>
<a name="line-2001"></a>  <span class='hs-keyword'>where</span>
<a name="line-2002"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>tvs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-2003"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>e</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-2004"></a>
<a name="line-2005"></a><span class='hs-definition'>collectValBinders</span> <span class='hs-varid'>expr</span>
<a name="line-2006"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>expr</span>
<a name="line-2007"></a>  <span class='hs-keyword'>where</span>
<a name="line-2008"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ids</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>ids</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-2009"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>body</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2010"></a>
<a name="line-2011"></a><span class='hs-definition'>collectTyAndValBinders</span> <span class='hs-varid'>expr</span>
<a name="line-2012"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2013"></a>  <span class='hs-keyword'>where</span>
<a name="line-2014"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectTyBinders</span> <span class='hs-varid'>expr</span>
<a name="line-2015"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectValBinders</span> <span class='hs-varid'>body1</span>
<a name="line-2016"></a>
<a name="line-2017"></a><span class='hs-definition'>collectNBinders</span> <span class='hs-varid'>orig_n</span> <span class='hs-varid'>orig_expr</span>
<a name="line-2018"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>orig_n</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>orig_expr</span>
<a name="line-2019"></a>  <span class='hs-keyword'>where</span>
<a name="line-2020"></a>    <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>expr</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-2021"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-2022"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"collectNBinders"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>int</span> <span class='hs-varid'>orig_n</span>
<a name="line-2023"></a>
<a name="line-2024"></a><a name="collectArgs"></a><span class='hs-comment'>-- | Takes a nested application expression and returns the the function</span>
<a name="line-2025"></a><span class='hs-comment'>-- being applied and the arguments to which it is applied</span>
<a name="line-2026"></a><span class='hs-definition'>collectArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2027"></a><span class='hs-definition'>collectArgs</span> <span class='hs-varid'>expr</span>
<a name="line-2028"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span>
<a name="line-2029"></a>  <span class='hs-keyword'>where</span>
<a name="line-2030"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-2031"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>         <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-2032"></a>
<a name="line-2033"></a><a name="collectArgsTicks"></a><span class='hs-comment'>-- | Like @collectArgs@, but also collects looks through floatable</span>
<a name="line-2034"></a><span class='hs-comment'>-- ticks if it means that we can find more arguments.</span>
<a name="line-2035"></a><span class='hs-definition'>collectArgsTicks</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tickish</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-2036"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Tickish</span> <span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2037"></a><span class='hs-definition'>collectArgsTicks</span> <span class='hs-varid'>skipTick</span> <span class='hs-varid'>expr</span>
<a name="line-2038"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span>
<a name="line-2039"></a>  <span class='hs-keyword'>where</span>
<a name="line-2040"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>  <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span>
<a name="line-2041"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span>
<a name="line-2042"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>skipTick</span> <span class='hs-varid'>t</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>as</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-2043"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>          <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-2044"></a>
<a name="line-2045"></a>
<a name="line-2046"></a><span class='hs-comment'>{-
<a name="line-2047"></a>************************************************************************
<a name="line-2048"></a>*                                                                      *
<a name="line-2049"></a>\subsection{Predicates}
<a name="line-2050"></a>*                                                                      *
<a name="line-2051"></a>************************************************************************
<a name="line-2052"></a>
<a name="line-2053"></a>At one time we optionally carried type arguments through to runtime.
<a name="line-2054"></a>@isRuntimeVar v@ returns if (Lam v _) really becomes a lambda at runtime,
<a name="line-2055"></a>i.e. if type applications are actual lambdas because types are kept around
<a name="line-2056"></a>at runtime.  Similarly isRuntimeArg.
<a name="line-2057"></a>-}</span>
<a name="line-2058"></a>
<a name="line-2059"></a><a name="isRuntimeVar"></a><span class='hs-comment'>-- | Will this variable exist at runtime?</span>
<a name="line-2060"></a><span class='hs-definition'>isRuntimeVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2061"></a><span class='hs-definition'>isRuntimeVar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isId</span>
<a name="line-2062"></a>
<a name="line-2063"></a><a name="isRuntimeArg"></a><span class='hs-comment'>-- | Will this argument expression exist at runtime?</span>
<a name="line-2064"></a><span class='hs-definition'>isRuntimeArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2065"></a><span class='hs-definition'>isRuntimeArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isValArg</span>
<a name="line-2066"></a>
<a name="line-2067"></a><a name="isValArg"></a><span class='hs-comment'>-- | Returns @True@ for value arguments, false for type args</span>
<a name="line-2068"></a><span class='hs-comment'>-- NB: coercions are value arguments (zero width, to be sure,</span>
<a name="line-2069"></a><span class='hs-comment'>-- like State#, but still value args).</span>
<a name="line-2070"></a><span class='hs-definition'>isValArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2071"></a><span class='hs-definition'>isValArg</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeArg</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-2072"></a>
<a name="line-2073"></a><a name="isTyCoArg"></a><span class='hs-comment'>-- | Returns @True@ iff the expression is a 'Type' or 'Coercion'</span>
<a name="line-2074"></a><span class='hs-comment'>-- expression at its top level</span>
<a name="line-2075"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2076"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2077"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2078"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2079"></a>
<a name="line-2080"></a><a name="isTypeArg"></a><span class='hs-comment'>-- | Returns @True@ iff the expression is a 'Type' expression at its</span>
<a name="line-2081"></a><span class='hs-comment'>-- top level.  Note this does NOT include 'Coercion's.</span>
<a name="line-2082"></a><span class='hs-definition'>isTypeArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2083"></a><span class='hs-definition'>isTypeArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2084"></a><span class='hs-definition'>isTypeArg</span> <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2085"></a>
<a name="line-2086"></a><a name="valBndrCount"></a><span class='hs-comment'>-- | The number of binders that bind values rather than types</span>
<a name="line-2087"></a><span class='hs-definition'>valBndrCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-2088"></a><span class='hs-definition'>valBndrCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isId</span>
<a name="line-2089"></a>
<a name="line-2090"></a><a name="valArgCount"></a><span class='hs-comment'>-- | The number of argument expressions that are values rather than types at their top level</span>
<a name="line-2091"></a><span class='hs-definition'>valArgCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-2092"></a><span class='hs-definition'>valArgCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isValArg</span>
<a name="line-2093"></a>
<a name="line-2094"></a><span class='hs-comment'>{-
<a name="line-2095"></a>************************************************************************
<a name="line-2096"></a>*                                                                      *
<a name="line-2097"></a>\subsection{Annotated core}
<a name="line-2098"></a>*                                                                      *
<a name="line-2099"></a>************************************************************************
<a name="line-2100"></a>-}</span>
<a name="line-2101"></a>
<a name="line-2102"></a><a name="AnnExpr"></a><span class='hs-comment'>-- | Annotated core: allows annotation at every node in the tree</span>
<a name="line-2103"></a><a name="AnnExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>annot</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr'</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2104"></a>
<a name="line-2105"></a><a name="AnnExpr'"></a><span class='hs-comment'>-- | A clone of the 'Expr' type but allowing annotation at every tree node</span>
<a name="line-2106"></a><a name="AnnExpr'"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnnExpr'</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span>
<a name="line-2107"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AnnVar</span>      <span class='hs-conid'>Id</span>
<a name="line-2108"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnLit</span>      <span class='hs-conid'>Literal</span>
<a name="line-2109"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnLam</span>      <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2110"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnApp</span>      <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2111"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnCase</span>     <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AnnAlt</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-keyglyph'>]</span>
<a name="line-2112"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnLet</span>      <span class='hs-layout'>(</span><span class='hs-conid'>AnnBind</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2113"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnCast</span>     <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>annot</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-2114"></a>                   <span class='hs-comment'>-- Put an annotation on the (root of) the coercion</span>
<a name="line-2115"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnTick</span>     <span class='hs-layout'>(</span><span class='hs-conid'>Tickish</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2116"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnType</span>     <span class='hs-conid'>Type</span>
<a name="line-2117"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnCoercion</span> <span class='hs-conid'>Coercion</span>
<a name="line-2118"></a>
<a name="line-2119"></a><a name="AnnAlt"></a><span class='hs-comment'>-- | A clone of the 'Alt' type but allowing annotation at every tree node</span>
<a name="line-2120"></a><a name="AnnAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>AnnAlt</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2121"></a>
<a name="line-2122"></a><a name="AnnBind"></a><span class='hs-comment'>-- | A clone of the 'Bind' type but allowing annotation at every tree node</span>
<a name="line-2123"></a><a name="AnnBind"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnnBind</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span>
<a name="line-2124"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AnnNonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2125"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnRec</span>    <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2126"></a>
<a name="line-2127"></a><a name="collectAnnArgs"></a><span class='hs-comment'>-- | Takes a nested application expression and returns the the function</span>
<a name="line-2128"></a><span class='hs-comment'>-- being applied and the arguments to which it is applied</span>
<a name="line-2129"></a><span class='hs-definition'>collectAnnArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2130"></a><span class='hs-definition'>collectAnnArgs</span> <span class='hs-varid'>expr</span>
<a name="line-2131"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span>
<a name="line-2132"></a>  <span class='hs-keyword'>where</span>
<a name="line-2133"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnApp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-2134"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>               <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-2135"></a>
<a name="line-2136"></a><a name="collectAnnArgsTicks"></a><span class='hs-definition'>collectAnnArgsTicks</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tickish</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span>
<a name="line-2137"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Tickish</span> <span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2138"></a><span class='hs-definition'>collectAnnArgsTicks</span> <span class='hs-varid'>tickishOk</span> <span class='hs-varid'>expr</span>
<a name="line-2139"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span>
<a name="line-2140"></a>  <span class='hs-keyword'>where</span>
<a name="line-2141"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnApp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>  <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span>
<a name="line-2142"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnTick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickishOk</span> <span class='hs-varid'>t</span>
<a name="line-2143"></a>                              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>as</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-2144"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>                <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-2145"></a>
<a name="line-2146"></a><a name="deAnnotate"></a><span class='hs-definition'>deAnnotate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>bndr</span>
<a name="line-2147"></a><span class='hs-definition'>deAnnotate</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deAnnotate'</span> <span class='hs-varid'>e</span>
<a name="line-2148"></a>
<a name="line-2149"></a><a name="deAnnotate'"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr'</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>bndr</span>
<a name="line-2150"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnType</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>t</span>
<a name="line-2151"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnCoercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span>
<a name="line-2152"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnVar</span>  <span class='hs-varid'>v</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span>
<a name="line-2153"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnLit</span>  <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span>
<a name="line-2154"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnLam</span>  <span class='hs-varid'>binder</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>binder</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2155"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnApp</span>  <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>App</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-2156"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnCast</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-2157"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnTick</span> <span class='hs-varid'>tick</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2158"></a>
<a name="line-2159"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnLet</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2160"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnBind</span> <span class='hs-varid'>bind</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2161"></a>  <span class='hs-keyword'>where</span>
<a name="line-2162"></a>    <span class='hs-varid'>deAnnBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnNonRec</span> <span class='hs-varid'>var</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2163"></a>    <span class='hs-varid'>deAnnBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnRec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Rec</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span><span class='hs-keyglyph'>]</span>
<a name="line-2164"></a>
<a name="line-2165"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnCase</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2166"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>scrut</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>deAnnAlt</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2167"></a>
<a name="line-2168"></a><a name="deAnnAlt"></a><span class='hs-definition'>deAnnAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnAlt</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>bndr</span>
<a name="line-2169"></a><span class='hs-definition'>deAnnAlt</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2170"></a>
<a name="line-2171"></a><a name="collectAnnBndrs"></a><span class='hs-comment'>-- | As 'collectBinders' but for 'AnnExpr' rather than 'Expr'</span>
<a name="line-2172"></a><span class='hs-definition'>collectAnnBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2173"></a><span class='hs-definition'>collectAnnBndrs</span> <span class='hs-varid'>e</span>
<a name="line-2174"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>e</span>
<a name="line-2175"></a>  <span class='hs-keyword'>where</span>
<a name="line-2176"></a>    <span class='hs-varid'>collect</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnLam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-2177"></a>    <span class='hs-varid'>collect</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>body</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2178"></a>
<a name="line-2179"></a><a name="collectNAnnBndrs"></a><span class='hs-comment'>-- | As 'collectNBinders' but for 'AnnExpr' rather than 'Expr'</span>
<a name="line-2180"></a><span class='hs-definition'>collectNAnnBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2181"></a><span class='hs-definition'>collectNAnnBndrs</span> <span class='hs-varid'>orig_n</span> <span class='hs-varid'>e</span>
<a name="line-2182"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-varid'>orig_n</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>e</span>
<a name="line-2183"></a>  <span class='hs-keyword'>where</span>
<a name="line-2184"></a>    <span class='hs-varid'>collect</span> <span class='hs-num'>0</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>body</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2185"></a>    <span class='hs-varid'>collect</span> <span class='hs-varid'>n</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnLam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-2186"></a>    <span class='hs-varid'>collect</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"collectNBinders"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>int</span> <span class='hs-varid'>orig_n</span>
</pre></body>
</html>
