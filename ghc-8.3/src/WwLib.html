<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>stranal/WwLib.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The GRASP/AQUA Project, Glasgow University, 1993-1998
<a name="line-3"></a>
<a name="line-4"></a>\section[WwLib]{A library for the ``worker\/wrapper'' back-end to the strictness analyser}
<a name="line-5"></a>-}</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>WwLib</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkWwBodies</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWWstr</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWorkerArgs</span>
<a name="line-10"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>deepSplitProductType_maybe</span><span class='hs-layout'>,</span> <span class='hs-varid'>findTypeShape</span>
<a name="line-11"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>isWorkerSmallEnough</span>
<a name="line-12"></a> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreSyn</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>CoreUtils</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>exprType</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCast</span> <span class='hs-layout'>)</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>IdInfo</span>           <span class='hs-layout'>(</span> <span class='hs-conid'>JoinArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>vanillaIdInfo</span> <span class='hs-layout'>)</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DataCon</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Demand</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MkCore</span>           <span class='hs-layout'>(</span> <span class='hs-varid'>mkRuntimeErrorApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>aBSENT_ERROR_ID</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoreUbxTup</span>
<a name="line-23"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>mkCoreApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoreLet</span> <span class='hs-layout'>)</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MkId</span>             <span class='hs-layout'>(</span> <span class='hs-varid'>voidArgId</span><span class='hs-layout'>,</span> <span class='hs-varid'>voidPrimId</span> <span class='hs-layout'>)</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysPrim</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>voidPrimTy</span> <span class='hs-layout'>)</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TysWiredIn</span>       <span class='hs-layout'>(</span> <span class='hs-varid'>tupleDataCon</span> <span class='hs-layout'>)</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>           <span class='hs-layout'>(</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>)</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>           <span class='hs-layout'>(</span> <span class='hs-conid'>VarSet</span> <span class='hs-layout'>)</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>RepType</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>isVoidTy</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FamInstEnv</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>Boxity</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Literal</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>absentLiteralOf</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>UniqSupply</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unique</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Maybes</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ListSetOps</span>
<a name="line-44"></a>
<a name="line-45"></a><span class='hs-comment'>{-
<a name="line-46"></a>************************************************************************
<a name="line-47"></a>*                                                                      *
<a name="line-48"></a>\subsection[mkWrapperAndWorker]{@mkWrapperAndWorker@}
<a name="line-49"></a>*                                                                      *
<a name="line-50"></a>************************************************************************
<a name="line-51"></a>
<a name="line-52"></a>Here's an example.  The original function is:
<a name="line-53"></a>
<a name="line-54"></a>\begin{verbatim}
<a name="line-55"></a>g :: forall a . Int -&gt; [a] -&gt; a
<a name="line-56"></a>
<a name="line-57"></a>g = \/\ a -&gt; \ x ys -&gt;
<a name="line-58"></a>        case x of
<a name="line-59"></a>          0 -&gt; head ys
<a name="line-60"></a>          _ -&gt; head (tail ys)
<a name="line-61"></a>\end{verbatim}
<a name="line-62"></a>
<a name="line-63"></a>From this, we want to produce:
<a name="line-64"></a>\begin{verbatim}
<a name="line-65"></a>-- wrapper (an unfolding)
<a name="line-66"></a>g :: forall a . Int -&gt; [a] -&gt; a
<a name="line-67"></a>
<a name="line-68"></a>g = \/\ a -&gt; \ x ys -&gt;
<a name="line-69"></a>        case x of
<a name="line-70"></a>          I# x# -&gt; $wg a x# ys
<a name="line-71"></a>            -- call the worker; don't forget the type args!
<a name="line-72"></a>
<a name="line-73"></a>-- worker
<a name="line-74"></a>$wg :: forall a . Int# -&gt; [a] -&gt; a
<a name="line-75"></a>
<a name="line-76"></a>$wg = \/\ a -&gt; \ x# ys -&gt;
<a name="line-77"></a>        let
<a name="line-78"></a>            x = I# x#
<a name="line-79"></a>        in
<a name="line-80"></a>            case x of               -- note: body of g moved intact
<a name="line-81"></a>              0 -&gt; head ys
<a name="line-82"></a>              _ -&gt; head (tail ys)
<a name="line-83"></a>\end{verbatim}
<a name="line-84"></a>
<a name="line-85"></a>Something we have to be careful about:  Here's an example:
<a name="line-86"></a>
<a name="line-87"></a>\begin{verbatim}
<a name="line-88"></a>-- "f" strictness: U(P)U(P)
<a name="line-89"></a>f (I# a) (I# b) = a +# b
<a name="line-90"></a>
<a name="line-91"></a>g = f   -- "g" strictness same as "f"
<a name="line-92"></a>\end{verbatim}
<a name="line-93"></a>
<a name="line-94"></a>\tr{f} will get a worker all nice and friendly-like; that's good.
<a name="line-95"></a>{\em But we don't want a worker for \tr{g}}, even though it has the
<a name="line-96"></a>same strictness as \tr{f}.  Doing so could break laziness, at best.
<a name="line-97"></a>
<a name="line-98"></a>Consequently, we insist that the number of strictness-info items is
<a name="line-99"></a>exactly the same as the number of lambda-bound arguments.  (This is
<a name="line-100"></a>probably slightly paranoid, but OK in practice.)  If it isn't the
<a name="line-101"></a>same, we ``revise'' the strictness info, so that we won't propagate
<a name="line-102"></a>the unusable strictness-info into the interfaces.
<a name="line-103"></a>
<a name="line-104"></a>
<a name="line-105"></a>************************************************************************
<a name="line-106"></a>*                                                                      *
<a name="line-107"></a>\subsection{The worker wrapper core}
<a name="line-108"></a>*                                                                      *
<a name="line-109"></a>************************************************************************
<a name="line-110"></a>
<a name="line-111"></a>@mkWwBodies@ is called when doing the worker\/wrapper split inside a module.
<a name="line-112"></a>-}</span>
<a name="line-113"></a>
<a name="line-114"></a><a name="WwResult"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>WwResult</span>
<a name="line-115"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>              <span class='hs-comment'>-- Demands for worker (value) args</span>
<a name="line-116"></a>     <span class='hs-conid'>JoinArity</span><span class='hs-layout'>,</span>             <span class='hs-comment'>-- Number of worker (type OR value) args</span>
<a name="line-117"></a>     <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Wrapper body, lacking only the worker Id</span>
<a name="line-118"></a>     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Worker body, lacking the original function rhs</span>
<a name="line-119"></a>
<a name="line-120"></a><a name="mkWwBodies"></a><span class='hs-definition'>mkWwBodies</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-121"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-122"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>         <span class='hs-comment'>-- Free vars of RHS</span>
<a name="line-123"></a>                             <span class='hs-comment'>-- See Note [Freshen WW arguments]</span>
<a name="line-124"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span> <span class='hs-comment'>-- Just ar &lt;=&gt; is join point with join arity ar</span>
<a name="line-125"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>           <span class='hs-comment'>-- Type of original function</span>
<a name="line-126"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Strictness of original function</span>
<a name="line-127"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdResult</span>      <span class='hs-comment'>-- Info about function result</span>
<a name="line-128"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>WwResult</span><span class='hs-layout'>)</span>
<a name="line-129"></a>
<a name="line-130"></a><span class='hs-comment'>-- wrap_fn_args E       = \x y -&gt; E</span>
<a name="line-131"></a><span class='hs-comment'>-- work_fn_args E       = E x y</span>
<a name="line-132"></a>
<a name="line-133"></a><span class='hs-comment'>-- wrap_fn_str E        = case x of { (a,b) -&gt;</span>
<a name="line-134"></a><span class='hs-comment'>--                        case a of { (a1,a2) -&gt;</span>
<a name="line-135"></a><span class='hs-comment'>--                        E a1 a2 b y }}</span>
<a name="line-136"></a><span class='hs-comment'>-- work_fn_str E        = \a2 a2 b y -&gt;</span>
<a name="line-137"></a><span class='hs-comment'>--                        let a = (a1,a2) in</span>
<a name="line-138"></a><span class='hs-comment'>--                        let x = (a,b) in</span>
<a name="line-139"></a><span class='hs-comment'>--                        E</span>
<a name="line-140"></a>
<a name="line-141"></a><span class='hs-definition'>mkWwBodies</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>rhs_fvs</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>demands</span> <span class='hs-varid'>res_info</span>
<a name="line-142"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>empty_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkInScopeSet</span> <span class='hs-varid'>rhs_fvs</span><span class='hs-layout'>)</span>
<a name="line-143"></a>                <span class='hs-comment'>-- See Note [Freshen WW arguments]</span>
<a name="line-144"></a>
<a name="line-145"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>empty_subst</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>demands</span>
<a name="line-146"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_str</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_str</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>wrap_args</span>
<a name="line-147"></a>
<a name="line-148"></a>        <span class='hs-comment'>-- Do CPR w/w.  See Note [Always do CPR w/w]</span>
<a name="line-149"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_cpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_cpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>cpr_res_ty</span><span class='hs-layout'>)</span>
<a name="line-150"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWcpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_CprAnal</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>res_ty</span> <span class='hs-varid'>res_info</span>
<a name="line-151"></a>
<a name="line-152"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_lam_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWorkerArgs</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>work_args</span> <span class='hs-varid'>cpr_res_ty</span>
<a name="line-153"></a>              <span class='hs-varid'>worker_args_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span>
<a name="line-154"></a>              <span class='hs-varid'>wrapper_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrap_fn_args</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_cpr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_str</span> <span class='hs-varop'>.</span> <span class='hs-varid'>applyToVars</span> <span class='hs-varid'>work_call_args</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Var</span>
<a name="line-155"></a>              <span class='hs-varid'>worker_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>work_lam_args</span><span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_str</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_cpr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_args</span>
<a name="line-156"></a>
<a name="line-157"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isWorkerSmallEnough</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>work_args</span>
<a name="line-158"></a>             <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>too_many_args_for_join_point</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>)</span>
<a name="line-159"></a>             <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-varid'>only_one_void_argument</span> <span class='hs-varop'>||</span> <span class='hs-varid'>useful2</span><span class='hs-layout'>)</span>
<a name="line-160"></a>          <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>worker_args_dmds</span><span class='hs-layout'>,</span> <span class='hs-varid'>length</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>,</span>
<a name="line-161"></a>                       <span class='hs-varid'>wrapper_body</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_body</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-162"></a>          <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-163"></a>        <span class='hs-layout'>}</span>
<a name="line-164"></a>        <span class='hs-comment'>-- We use an INLINE unconditionally, even if the wrapper turns out to be</span>
<a name="line-165"></a>        <span class='hs-comment'>-- something trivial like</span>
<a name="line-166"></a>        <span class='hs-comment'>--      fw = ...</span>
<a name="line-167"></a>        <span class='hs-comment'>--      f = __inline__ (coerce T fw)</span>
<a name="line-168"></a>        <span class='hs-comment'>-- The point is to propagate the coerce to f's call sites, so even though</span>
<a name="line-169"></a>        <span class='hs-comment'>-- f's RHS is now trivial (size 1) we still want the __inline__ to prevent</span>
<a name="line-170"></a>        <span class='hs-comment'>-- fw from being inlined into f's RHS</span>
<a name="line-171"></a>  <span class='hs-keyword'>where</span>
<a name="line-172"></a>    <span class='hs-comment'>-- Note [Do not split void functions]</span>
<a name="line-173"></a>    <span class='hs-varid'>only_one_void_argument</span>
<a name="line-174"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>demands</span>
<a name="line-175"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty1</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-176"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isAbsDmd</span> <span class='hs-varid'>d</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isVoidTy</span> <span class='hs-varid'>arg_ty1</span>
<a name="line-177"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-178"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-179"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-180"></a>
<a name="line-181"></a>    <span class='hs-comment'>-- Note [Join points returning functions]</span>
<a name="line-182"></a>    <span class='hs-varid'>too_many_args_for_join_point</span> <span class='hs-varid'>wrap_args</span>
<a name="line-183"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mb_join_arity</span>
<a name="line-184"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>wrap_args</span> <span class='hs-varop'>`lengthExceeds`</span> <span class='hs-varid'>join_arity</span>
<a name="line-185"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Unable to worker/wrapper join point with arity "</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-186"></a>                     <span class='hs-varid'>int</span> <span class='hs-varid'>join_arity</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"but"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-187"></a>                     <span class='hs-varid'>int</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"args"</span><span class='hs-layout'>)</span>
<a name="line-188"></a>        <span class='hs-conid'>True</span>
<a name="line-189"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-190"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-191"></a>
<a name="line-192"></a><a name="isWorkerSmallEnough"></a><span class='hs-comment'>-- See Note [Limit w/w arity]</span>
<a name="line-193"></a><span class='hs-definition'>isWorkerSmallEnough</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-194"></a><span class='hs-definition'>isWorkerSmallEnough</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>vars</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>maxWorkerArgs</span> <span class='hs-varid'>dflags</span>
<a name="line-195"></a>    <span class='hs-comment'>-- We count only Free variables (isId) to skip Type, Kind</span>
<a name="line-196"></a>    <span class='hs-comment'>-- variables which have no runtime representation.</span>
<a name="line-197"></a>
<a name="line-198"></a><span class='hs-comment'>{-
<a name="line-199"></a>Note [Always do CPR w/w]
<a name="line-200"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-201"></a>At one time we refrained from doing CPR w/w for thunks, on the grounds that
<a name="line-202"></a>we might duplicate work.  But that is already handled by the demand analyser,
<a name="line-203"></a>which doesn't give the CPR proprety if w/w might waste work: see
<a name="line-204"></a>Note [CPR for thunks] in DmdAnal.
<a name="line-205"></a>
<a name="line-206"></a>And if something *has* been given the CPR property and we don't w/w, it's
<a name="line-207"></a>a disaster, because then the enclosing function might say it has the CPR
<a name="line-208"></a>property, but now doesn't and there a cascade of disaster.  A good example
<a name="line-209"></a>is Trac #5920.
<a name="line-210"></a>
<a name="line-211"></a>Note [Limit w/w arity]
<a name="line-212"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-213"></a>Guard against high worker arity as it generates a lot of stack traffic.
<a name="line-214"></a>A simplified example is Trac #11565#comment:6
<a name="line-215"></a>
<a name="line-216"></a>Current strategy is very simple: don't perform w/w transformation at all
<a name="line-217"></a>if the result produces a wrapper with arity higher than -fmax-worker-args=.
<a name="line-218"></a>
<a name="line-219"></a>It is a bit all or nothing, consider
<a name="line-220"></a>
<a name="line-221"></a>        f (x,y) (a,b,c,d,e ... , z) = rhs
<a name="line-222"></a>
<a name="line-223"></a>Currently we will remove all w/w ness entirely. But actually we could
<a name="line-224"></a>w/w on the (x,y) pair... it's the huge product that is the problem.
<a name="line-225"></a>
<a name="line-226"></a>Could we instead refrain from w/w on an arg-by-arg basis? Yes, that'd
<a name="line-227"></a>solve f. But we can get a lot of args from deeply-nested products:
<a name="line-228"></a>
<a name="line-229"></a>        g (a, (b, (c, (d, ...)))) = rhs
<a name="line-230"></a>
<a name="line-231"></a>This is harder to spot on an arg-by-arg basis. Previously mkWwStr was
<a name="line-232"></a>given some "fuel" saying how many arguments it could add; when we ran
<a name="line-233"></a>out of fuel it would stop w/wing.
<a name="line-234"></a>Still not very clever because it had a left-right bias.
<a name="line-235"></a>
<a name="line-236"></a>************************************************************************
<a name="line-237"></a>*                                                                      *
<a name="line-238"></a>\subsection{Making wrapper args}
<a name="line-239"></a>*                                                                      *
<a name="line-240"></a>************************************************************************
<a name="line-241"></a>
<a name="line-242"></a>During worker-wrapper stuff we may end up with an unlifted thing
<a name="line-243"></a>which we want to let-bind without losing laziness.  So we
<a name="line-244"></a>add a void argument.  E.g.
<a name="line-245"></a>
<a name="line-246"></a>        f = /\a -&gt; \x y z -&gt; E::Int#    -- E does not mention x,y,z
<a name="line-247"></a>==&gt;
<a name="line-248"></a>        fw = /\ a -&gt; \void -&gt; E
<a name="line-249"></a>        f  = /\ a -&gt; \x y z -&gt; fw realworld
<a name="line-250"></a>
<a name="line-251"></a>We use the state-token type which generates no code.
<a name="line-252"></a>-}</span>
<a name="line-253"></a>
<a name="line-254"></a><a name="mkWorkerArgs"></a><span class='hs-definition'>mkWorkerArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>
<a name="line-255"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- Type of body</span>
<a name="line-256"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- Lambda bound args</span>
<a name="line-257"></a>                 <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Args at call site</span>
<a name="line-258"></a><span class='hs-definition'>mkWorkerArgs</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>args</span> <span class='hs-varid'>res_ty</span>
<a name="line-259"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>args</span> <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-varid'>needsAValueLambda</span>
<a name="line-260"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-261"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-262"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>args</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>voidArgId</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>voidPrimId</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-263"></a>    <span class='hs-keyword'>where</span>
<a name="line-264"></a>      <span class='hs-varid'>needsAValueLambda</span> <span class='hs-keyglyph'>=</span>
<a name="line-265"></a>        <span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>res_ty</span>
<a name="line-266"></a>        <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_FunToThunk</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-267"></a>           <span class='hs-comment'>-- see Note [Protecting the last value argument]</span>
<a name="line-268"></a>
<a name="line-269"></a><span class='hs-comment'>{-
<a name="line-270"></a>Note [Protecting the last value argument]
<a name="line-271"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-272"></a>If the user writes (\_ -&gt; E), they might be intentionally disallowing
<a name="line-273"></a>the sharing of E. Since absence analysis and worker-wrapper are keen
<a name="line-274"></a>to remove such unused arguments, we add in a void argument to prevent
<a name="line-275"></a>the function from becoming a thunk.
<a name="line-276"></a>
<a name="line-277"></a>The user can avoid adding the void argument with the -ffun-to-thunk
<a name="line-278"></a>flag. However, this can create sharing, which may be bad in two ways. 1) It can
<a name="line-279"></a>create a space leak. 2) It can prevent inlining *under a lambda*. If w/w
<a name="line-280"></a>removes the last argument from a function f, then f now looks like a thunk, and
<a name="line-281"></a>so f can't be inlined *under a lambda*.
<a name="line-282"></a>
<a name="line-283"></a>Note [Join points and beta-redexes]
<a name="line-284"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-285"></a>
<a name="line-286"></a>Originally, the worker would invoke the original function by calling it with
<a name="line-287"></a>arguments, thus producing a beta-redex for the simplifier to munch away:
<a name="line-288"></a>
<a name="line-289"></a>  \x y z -&gt; e =&gt; (\x y z -&gt; e) wx wy wz
<a name="line-290"></a>
<a name="line-291"></a>Now that we have special rules about join points, however, this is Not Good if
<a name="line-292"></a>the original function is itself a join point, as then it may contain invocations
<a name="line-293"></a>of other join points:
<a name="line-294"></a>
<a name="line-295"></a>  join j1 x = ...
<a name="line-296"></a>  join j2 y = if y == 0 then 0 else j1 y
<a name="line-297"></a>
<a name="line-298"></a>  =&gt;
<a name="line-299"></a>
<a name="line-300"></a>  join j1 x = ...
<a name="line-301"></a>  join $wj2 y# = let wy = I# y# in (\y -&gt; if y == 0 then 0 else jump j1 y) wy
<a name="line-302"></a>  join j2 y = case y of I# y# -&gt; jump $wj2 y#
<a name="line-303"></a>
<a name="line-304"></a>There can't be an intervening lambda between a join point's declaration and its
<a name="line-305"></a>occurrences, so $wj2 here is wrong. But of course, this is easy enough to fix:
<a name="line-306"></a>
<a name="line-307"></a>  ...
<a name="line-308"></a>  let join $wj2 y# = let wy = I# y# in let y = wy in if y == 0 then 0 else j1 y
<a name="line-309"></a>  ...
<a name="line-310"></a>
<a name="line-311"></a>Hence we simply do the beta-reduction here. (This would be harder if we had to
<a name="line-312"></a>worry about hygiene, but luckily wy is freshly generated.)
<a name="line-313"></a>
<a name="line-314"></a>Note [Join points returning functions]
<a name="line-315"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-316"></a>
<a name="line-317"></a>It is crucial that the arity of a join point depends on its *callers,* not its
<a name="line-318"></a>own syntax. What this means is that a join point can have "extra lambdas":
<a name="line-319"></a>
<a name="line-320"></a>f :: Int -&gt; Int -&gt; (Int, Int) -&gt; Int
<a name="line-321"></a>f x y = join j (z, w) = \(u, v) -&gt; ...
<a name="line-322"></a>        in jump j (x, y)
<a name="line-323"></a>
<a name="line-324"></a>Typically this happens with functions that are seen as computing functions,
<a name="line-325"></a>rather than being curried. (The real-life example was GraphOps.addConflicts.)
<a name="line-326"></a>
<a name="line-327"></a>When we create the wrapper, it *must* be in "eta-contracted" form so that the
<a name="line-328"></a>jump has the right number of arguments:
<a name="line-329"></a>
<a name="line-330"></a>f x y = join $wj z' w' = \u' v' -&gt; let {z = z'; w = w'; u = u'; v = v'} in ...
<a name="line-331"></a>             j (z, w)  = jump $wj z w
<a name="line-332"></a>
<a name="line-333"></a>(See Note [Join points and beta-redexes] for where the lets come from.) If j
<a name="line-334"></a>were a function, we would instead say
<a name="line-335"></a>
<a name="line-336"></a>f x y = let $wj = \z' w' u' v' -&gt; let {z = z'; w = w'; u = u'; v = v'} in ...
<a name="line-337"></a>            j (z, w) (u, v) = $wj z w u v
<a name="line-338"></a>
<a name="line-339"></a>Notice that the worker ends up with the same lambdas; it's only the wrapper we
<a name="line-340"></a>have to be concerned about.
<a name="line-341"></a>
<a name="line-342"></a>FIXME Currently the functionality to produce "eta-contracted" wrappers is
<a name="line-343"></a>unimplemented; we simply give up.
<a name="line-344"></a>
<a name="line-345"></a>************************************************************************
<a name="line-346"></a>*                                                                      *
<a name="line-347"></a>\subsection{Coercion stuff}
<a name="line-348"></a>*                                                                      *
<a name="line-349"></a>************************************************************************
<a name="line-350"></a>
<a name="line-351"></a>We really want to "look through" coerces.
<a name="line-352"></a>Reason: I've seen this situation:
<a name="line-353"></a>
<a name="line-354"></a>        let f = coerce T (\s -&gt; E)
<a name="line-355"></a>        in \x -&gt; case x of
<a name="line-356"></a>                    p -&gt; coerce T' f
<a name="line-357"></a>                    q -&gt; \s -&gt; E2
<a name="line-358"></a>                    r -&gt; coerce T' f
<a name="line-359"></a>
<a name="line-360"></a>If only we w/w'd f, we'd get
<a name="line-361"></a>        let f = coerce T (\s -&gt; fw s)
<a name="line-362"></a>            fw = \s -&gt; E
<a name="line-363"></a>        in ...
<a name="line-364"></a>
<a name="line-365"></a>Now we'll inline f to get
<a name="line-366"></a>
<a name="line-367"></a>        let fw = \s -&gt; E
<a name="line-368"></a>        in \x -&gt; case x of
<a name="line-369"></a>                    p -&gt; fw
<a name="line-370"></a>                    q -&gt; \s -&gt; E2
<a name="line-371"></a>                    r -&gt; fw
<a name="line-372"></a>
<a name="line-373"></a>Now we'll see that fw has arity 1, and will arity expand
<a name="line-374"></a>the \x to get what we want.
<a name="line-375"></a>-}</span>
<a name="line-376"></a>
<a name="line-377"></a><span class='hs-comment'>-- mkWWargs just does eta expansion</span>
<a name="line-378"></a><span class='hs-comment'>-- is driven off the function type and arity.</span>
<a name="line-379"></a><span class='hs-comment'>-- It chomps bites off foralls, arrows, newtypes</span>
<a name="line-380"></a><span class='hs-comment'>-- and keeps repeating that until it's satisfied the supplied arity</span>
<a name="line-381"></a>
<a name="line-382"></a><a name="mkWWargs"></a><span class='hs-definition'>mkWWargs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TCvSubst</span>            <span class='hs-comment'>-- Freshening substitution to apply to the type</span>
<a name="line-383"></a>                                <span class='hs-comment'>--   See Note [Freshen WW arguments]</span>
<a name="line-384"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>                <span class='hs-comment'>-- The type of the function</span>
<a name="line-385"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Demands and one-shot info for value arguments</span>
<a name="line-386"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span>  <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- Wrapper args</span>
<a name="line-387"></a>                     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Wrapper fn</span>
<a name="line-388"></a>                     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Worker fn</span>
<a name="line-389"></a>                     <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>                      <span class='hs-comment'>-- Type of wrapper body</span>
<a name="line-390"></a>
<a name="line-391"></a><span class='hs-definition'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>demands</span>
<a name="line-392"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>demands</span>
<a name="line-393"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span>
<a name="line-394"></a>
<a name="line-395"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd</span><span class='hs-conop'>:</span><span class='hs-varid'>demands'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>demands</span>
<a name="line-396"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-397"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-398"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>arg_ty</span>
<a name="line-399"></a>              <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_wrap_arg</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>arg_ty'</span> <span class='hs-varid'>dmd</span>
<a name="line-400"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-401"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>demands'</span>
<a name="line-402"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-403"></a>                  <span class='hs-conid'>Lam</span> <span class='hs-varid'>id</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span>
<a name="line-404"></a>                  <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>work_fn_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-405"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-406"></a>
<a name="line-407"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-408"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-409"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cloneTyVarBndr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>uniq</span>
<a name="line-410"></a>                <span class='hs-comment'>-- See Note [Freshen WW arguments]</span>
<a name="line-411"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-412"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>demands</span>
<a name="line-413"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-414"></a>                  <span class='hs-conid'>Lam</span> <span class='hs-varid'>tv'</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span>
<a name="line-415"></a>                  <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>work_fn_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyArg</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-416"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-417"></a>
<a name="line-418"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>topNormaliseNewType_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-419"></a>        <span class='hs-comment'>-- The newtype case is for when the function has</span>
<a name="line-420"></a>        <span class='hs-comment'>-- a newtype after the arrow (rare)</span>
<a name="line-421"></a>        <span class='hs-comment'>--</span>
<a name="line-422"></a>        <span class='hs-comment'>-- It's also important when we have a function returning (say) a pair</span>
<a name="line-423"></a>        <span class='hs-comment'>-- wrapped in a  newtype, at least if CPR analysis can look</span>
<a name="line-424"></a>        <span class='hs-comment'>-- through such newtypes, which it probably can since they are</span>
<a name="line-425"></a>        <span class='hs-comment'>-- simply coerces.</span>
<a name="line-426"></a>
<a name="line-427"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-428"></a>            <span class='hs-keyglyph'>&lt;-</span>  <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>rep_ty</span> <span class='hs-varid'>demands</span>
<a name="line-429"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substCo</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>co</span>
<a name="line-430"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-431"></a>                  <span class='hs-keyglyph'>\</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_fn_args</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-432"></a>                  <span class='hs-keyglyph'>\</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>work_fn_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-433"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-434"></a>
<a name="line-435"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-436"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>)</span>                    <span class='hs-comment'>-- Should not happen: if there is a demand</span>
<a name="line-437"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- then there should be a function arrow</span>
<a name="line-438"></a>  <span class='hs-keyword'>where</span>
<a name="line-439"></a>    <span class='hs-comment'>-- See Note [Join points and beta-redexes]</span>
<a name="line-440"></a>    <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>k</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-441"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCoreLet</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Important that arg is fresh!</span>
<a name="line-442"></a>    <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>k</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>fun</span>
<a name="line-443"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkCoreApp</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"mkWWargs"</span><span class='hs-layout'>)</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span>
<a name="line-444"></a><a name="applyToVars"></a><span class='hs-definition'>applyToVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-445"></a><span class='hs-definition'>applyToVars</span> <span class='hs-varid'>vars</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarApps</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>vars</span>
<a name="line-446"></a>
<a name="line-447"></a><a name="mk_wrap_arg"></a><span class='hs-definition'>mk_wrap_arg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-448"></a><span class='hs-definition'>mk_wrap_arg</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>dmd</span>
<a name="line-449"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSysLocalOrCoVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"w"</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span>
<a name="line-450"></a>       <span class='hs-varop'>`setIdDemandInfo`</span> <span class='hs-varid'>dmd</span>
<a name="line-451"></a>
<a name="line-452"></a><span class='hs-comment'>{- Note [Freshen WW arguments]
<a name="line-453"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-454"></a>Wen we do a worker/wrapper split, we must not in-scope names as the arguments
<a name="line-455"></a>of the worker, else we'll get name capture.  E.g.
<a name="line-456"></a>
<a name="line-457"></a>   -- y1 is in scope from further out
<a name="line-458"></a>   f x = ..y1..
<a name="line-459"></a>
<a name="line-460"></a>If we accidentally choose y1 as a worker argument disaster results:
<a name="line-461"></a>
<a name="line-462"></a>   fww y1 y2 = let x = (y1,y2) in ...y1...
<a name="line-463"></a>
<a name="line-464"></a>To avoid this:
<a name="line-465"></a>
<a name="line-466"></a>  * We use a fresh unique for both type-variable and term-variable binders
<a name="line-467"></a>    Originally we lacked this freshness for type variables, and that led
<a name="line-468"></a>    to the very obscure Trac #12562.  (A type variable in the worker shadowed
<a name="line-469"></a>    an outer term-variable binding.)
<a name="line-470"></a>
<a name="line-471"></a>  * Because of this cloning we have to substitute in the type/kind of the
<a name="line-472"></a>    new binders.  That's why we carry the TCvSubst through mkWWargs.
<a name="line-473"></a>
<a name="line-474"></a>    So we need a decent in-scope set, just in case that type/kind
<a name="line-475"></a>    itself has foralls.  We get this from the free vars of the RHS of the
<a name="line-476"></a>    function since those are the only variables that might be captured.
<a name="line-477"></a>    It's a lazy thunk, which will only be poked if the type/kind has a forall.
<a name="line-478"></a>
<a name="line-479"></a>    Another tricky case was when f :: forall a. a -&gt; forall a. a-&gt;a
<a name="line-480"></a>    (i.e. with shadowing), and then the worker used the same 'a' twice.
<a name="line-481"></a>
<a name="line-482"></a>************************************************************************
<a name="line-483"></a>*                                                                      *
<a name="line-484"></a>\subsection{Strictness stuff}
<a name="line-485"></a>*                                                                      *
<a name="line-486"></a>************************************************************************
<a name="line-487"></a>-}</span>
<a name="line-488"></a>
<a name="line-489"></a><a name="mkWWstr"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-490"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-491"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>                                <span class='hs-comment'>-- Wrapper args; have their demand info on them</span>
<a name="line-492"></a>                                                <span class='hs-comment'>--  *Includes type variables*</span>
<a name="line-493"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                        <span class='hs-comment'>-- Is this useful</span>
<a name="line-494"></a>                   <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>                       <span class='hs-comment'>-- Worker args</span>
<a name="line-495"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Wrapper body, lacking the worker call</span>
<a name="line-496"></a>                                                <span class='hs-comment'>-- and without its lambdas</span>
<a name="line-497"></a>                                                <span class='hs-comment'>-- This fn adds the unboxing</span>
<a name="line-498"></a>
<a name="line-499"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Worker body, lacking the original body of the function,</span>
<a name="line-500"></a>                                                <span class='hs-comment'>-- and lacking its lambdas.</span>
<a name="line-501"></a>                                                <span class='hs-comment'>-- This fn does the reboxing</span>
<a name="line-502"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>
<a name="line-503"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-504"></a>
<a name="line-505"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-506"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span><span class='hs-layout'>,</span> <span class='hs-varid'>args1</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn1</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span>
<a name="line-507"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>args2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn2</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>args</span>
<a name="line-508"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>args1</span> <span class='hs-varop'>++</span> <span class='hs-varid'>args2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn2</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn2</span><span class='hs-layout'>)</span>
<a name="line-509"></a>
<a name="line-510"></a><span class='hs-comment'>{-
<a name="line-511"></a>Note [Unpacking arguments with product and polymorphic demands]
<a name="line-512"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-513"></a>The argument is unpacked in a case if it has a product type and has a
<a name="line-514"></a>strict *and* used demand put on it. I.e., arguments, with demands such
<a name="line-515"></a>as the following ones:
<a name="line-516"></a>
<a name="line-517"></a>   &lt;S,U(U, L)&gt;
<a name="line-518"></a>   &lt;S(L,S),U&gt;
<a name="line-519"></a>
<a name="line-520"></a>will be unpacked, but
<a name="line-521"></a>
<a name="line-522"></a>   &lt;S,U&gt; or &lt;B,U&gt;
<a name="line-523"></a>
<a name="line-524"></a>will not, because the pieces aren't used. This is quite important otherwise
<a name="line-525"></a>we end up unpacking massive tuples passed to the bottoming function. Example:
<a name="line-526"></a>
<a name="line-527"></a>        f :: ((Int,Int) -&gt; String) -&gt; (Int,Int) -&gt; a
<a name="line-528"></a>        f g pr = error (g pr)
<a name="line-529"></a>
<a name="line-530"></a>        main = print (f fst (1, error "no"))
<a name="line-531"></a>
<a name="line-532"></a>Does 'main' print "error 1" or "error no"?  We don't really want 'f'
<a name="line-533"></a>to unbox its second argument.  This actually happened in GHC's onwn
<a name="line-534"></a>source code, in Packages.applyPackageFlag, which ended up un-boxing
<a name="line-535"></a>the enormous DynFlags tuple, and being strict in the
<a name="line-536"></a>as-yet-un-filled-in pkgState files.
<a name="line-537"></a>-}</span>
<a name="line-538"></a>
<a name="line-539"></a><a name="mkWWstr_one"></a><span class='hs-comment'>----------------------</span>
<a name="line-540"></a><span class='hs-comment'>-- mkWWstr_one wrap_arg = (useful, work_args, wrap_fn, work_fn)</span>
<a name="line-541"></a><span class='hs-comment'>--   *  wrap_fn assumes wrap_arg is in scope,</span>
<a name="line-542"></a><span class='hs-comment'>--        brings into scope work_args (via cases)</span>
<a name="line-543"></a><span class='hs-comment'>--   * work_fn assumes work_args are in scope, a</span>
<a name="line-544"></a><span class='hs-comment'>--        brings into scope wrap_arg (via lets)</span>
<a name="line-545"></a><span class='hs-definition'>mkWWstr_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span>
<a name="line-546"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-547"></a><span class='hs-definition'>mkWWstr_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span>
<a name="line-548"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>arg</span>
<a name="line-549"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>  <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-550"></a>
<a name="line-551"></a>  <span class='hs-comment'>-- See Note [Worker-wrapper for bottoming functions]</span>
<a name="line-552"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isAbsDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-553"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>work_fn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_absent_let</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>arg</span>
<a name="line-554"></a>     <span class='hs-comment'>-- Absent case.  We can't always handle absence for arbitrary</span>
<a name="line-555"></a>     <span class='hs-comment'>-- unlifted types, so we need to choose just the cases we can</span>
<a name="line-556"></a>     <span class='hs-comment'>--- (that's what mk_absent_let does)</span>
<a name="line-557"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span>
<a name="line-558"></a>
<a name="line-559"></a>  <span class='hs-comment'>-- See Note [Worthy functions for Worker-Wrapper split]</span>
<a name="line-560"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSeqDmd</span> <span class='hs-varid'>dmd</span>  <span class='hs-comment'>-- `seq` demand; evaluate in wrapper in the hope</span>
<a name="line-561"></a>                  <span class='hs-comment'>-- of dropping seqs in the worker</span>
<a name="line-562"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_w_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>evaldUnfolding</span>
<a name="line-563"></a>          <span class='hs-comment'>-- Tell the worker arg that it's sure to be evaluated</span>
<a name="line-564"></a>          <span class='hs-comment'>-- so that internal seqs can be dropped</span>
<a name="line-565"></a>    <span class='hs-keyword'>in</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_w_unf</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>mk_seq_case</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-566"></a>                <span class='hs-comment'>-- Pass the arg, anyway, even if it is in theory discarded</span>
<a name="line-567"></a>                <span class='hs-comment'>-- Consider</span>
<a name="line-568"></a>                <span class='hs-comment'>--      f x y = x `seq` y</span>
<a name="line-569"></a>                <span class='hs-comment'>-- x gets a (Eval (Poly Abs)) demand, but if we fail to pass it to the worker</span>
<a name="line-570"></a>                <span class='hs-comment'>-- we ABSOLUTELY MUST record that x is evaluated in the wrapper.</span>
<a name="line-571"></a>                <span class='hs-comment'>-- Something like:</span>
<a name="line-572"></a>                <span class='hs-comment'>--      f x y = x `seq` fw y</span>
<a name="line-573"></a>                <span class='hs-comment'>--      fw y = let x{Evald} = error "oops" in (x `seq` y)</span>
<a name="line-574"></a>                <span class='hs-comment'>-- If we don't pin on the "Evald" flag, the seq doesn't disappear, and</span>
<a name="line-575"></a>                <span class='hs-comment'>-- we end up evaluating the absent thunk.</span>
<a name="line-576"></a>                <span class='hs-comment'>-- But the Evald flag is pretty weird, and I worry that it might disappear</span>
<a name="line-577"></a>                <span class='hs-comment'>-- during simplification, so for now I've just nuked this whole case</span>
<a name="line-578"></a>
<a name="line-579"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStrictDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-580"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitProdDmd_maybe</span> <span class='hs-varid'>dmd</span>
<a name="line-581"></a>      <span class='hs-comment'>-- See Note [Unpacking arguments with product and polymorphic demands]</span>
<a name="line-582"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>data_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_con_arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-583"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deepSplitProductType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-584"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>cs</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>inst_con_arg_tys</span>
<a name="line-585"></a>      <span class='hs-comment'>-- See Note [mkWWstr and unsafeCoerce]</span>
<a name="line-586"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>uniq1</span><span class='hs-conop'>:</span><span class='hs-varid'>uniqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-587"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span>   <span class='hs-varid'>unpk_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith3</span> <span class='hs-varid'>mk_ww_arg</span> <span class='hs-varid'>uniqs</span> <span class='hs-varid'>inst_con_arg_tys</span> <span class='hs-varid'>cs</span>
<a name="line-588"></a>                <span class='hs-varid'>unbox_fn</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq1</span>
<a name="line-589"></a>                                         <span class='hs-varid'>data_con</span> <span class='hs-varid'>unpk_args</span>
<a name="line-590"></a>                <span class='hs-varid'>arg_no_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapStableUnfolding</span> <span class='hs-varid'>arg</span>
<a name="line-591"></a>                             <span class='hs-comment'>-- See Note [Zap unfolding when beta-reducing]</span>
<a name="line-592"></a>                             <span class='hs-comment'>-- in Simplify.hs; and see Trac #13890</span>
<a name="line-593"></a>                <span class='hs-varid'>rebox_fn</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg_no_unf</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span>
<a name="line-594"></a>                <span class='hs-varid'>con_app</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>unpk_args</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-595"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>unpk_args</span>
<a name="line-596"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>unbox_fn</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rebox_fn</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-597"></a>                           <span class='hs-comment'>-- Don't pass the arg, rebox instead</span>
<a name="line-598"></a>
<a name="line-599"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- Other cases</span>
<a name="line-600"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-601"></a>
<a name="line-602"></a>  <span class='hs-keyword'>where</span>
<a name="line-603"></a>    <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>arg</span>
<a name="line-604"></a>    <span class='hs-varid'>mk_ww_arg</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>sub_dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>sub_dmd</span>
<a name="line-605"></a>
<a name="line-606"></a><a name="nop_fn"></a><span class='hs-comment'>----------------------</span>
<a name="line-607"></a><span class='hs-definition'>nop_fn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-608"></a><span class='hs-definition'>nop_fn</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-609"></a>
<a name="line-610"></a><span class='hs-comment'>{-
<a name="line-611"></a>Note [mkWWstr and unsafeCoerce]
<a name="line-612"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-613"></a>By using unsafeCoerce, it is possible to make the number of demands fail to
<a name="line-614"></a>match the number of constructor arguments; this happened in Trac #8037.
<a name="line-615"></a>If so, the worker/wrapper split doesn't work right and we get a Core Lint
<a name="line-616"></a>bug.  The fix here is simply to decline to do w/w if that happens.
<a name="line-617"></a>
<a name="line-618"></a>Note [Record evaluated-ness in worker/wrapper]
<a name="line-619"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-620"></a>Suppose we have
<a name="line-621"></a>
<a name="line-622"></a>   data T = MkT !Int Int
<a name="line-623"></a>
<a name="line-624"></a>   f :: T -&gt; T
<a name="line-625"></a>   f x = e
<a name="line-626"></a>
<a name="line-627"></a>and f's is strict, and has the CPR property.  The we are going to generate
<a name="line-628"></a>this w/w split
<a name="line-629"></a>
<a name="line-630"></a>   f x = case x of
<a name="line-631"></a>           MkT x1 x2 -&gt; case $wf x1 x2 of
<a name="line-632"></a>                           (# r1, r2 #) -&gt; MkT r1 r2
<a name="line-633"></a>
<a name="line-634"></a>   $wfw x1 x2 = let x = MkT x1 x2 in
<a name="line-635"></a>                case e of
<a name="line-636"></a>                  MkT r1 r2 -&gt; (# r1, r2 #)
<a name="line-637"></a>
<a name="line-638"></a>Note that
<a name="line-639"></a>
<a name="line-640"></a>* In the worker $wf, inside 'e' we can be sure that x1 will be
<a name="line-641"></a>  evaluated (it came from unpacking the argument MkT.  But that's no
<a name="line-642"></a>  immediately apparent in $wf
<a name="line-643"></a>
<a name="line-644"></a>* In the wrapper 'f', which we'll inline at call sites, we can be sure
<a name="line-645"></a>  that 'r1' has been evaluated (because it came from unpacking the result
<a name="line-646"></a>  MkT.  But that is not immediately apparent from the wrapper code.
<a name="line-647"></a>
<a name="line-648"></a>Missing these facts isn't unsound, but it loses possible future
<a name="line-649"></a>opportunities for optimisation.
<a name="line-650"></a>
<a name="line-651"></a>Solution: use setCaseBndrEvald when creating
<a name="line-652"></a> (A) The arg binders x1,x2 in mkWstr_one
<a name="line-653"></a>         See Trac #13077, test T13077
<a name="line-654"></a> (B) The result binders r1,r2 in mkWWcpr_help
<a name="line-655"></a>         See Trace #13077, test T13077a
<a name="line-656"></a>         And Trac #13027 comment:20, item (4)
<a name="line-657"></a>to record that the relevant binder is evaluated.
<a name="line-658"></a>
<a name="line-659"></a>
<a name="line-660"></a>************************************************************************
<a name="line-661"></a>*                                                                      *
<a name="line-662"></a>         Type scrutiny that is specific to demand analysis
<a name="line-663"></a>*                                                                      *
<a name="line-664"></a>************************************************************************
<a name="line-665"></a>
<a name="line-666"></a>Note [Do not unpack class dictionaries]
<a name="line-667"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-668"></a>If we have
<a name="line-669"></a>   f :: Ord a =&gt; [a] -&gt; Int -&gt; a
<a name="line-670"></a>   {-# INLINABLE f #-}
<a name="line-671"></a>and we worker/wrapper f, we'll get a worker with an INLINABLE pragma
<a name="line-672"></a>(see Note [Worker-wrapper for INLINABLE functions] in WorkWrap), which
<a name="line-673"></a>can still be specialised by the type-class specialiser, something like
<a name="line-674"></a>   fw :: Ord a =&gt; [a] -&gt; Int# -&gt; a
<a name="line-675"></a>
<a name="line-676"></a>BUT if f is strict in the Ord dictionary, we might unpack it, to get
<a name="line-677"></a>   fw :: (a-&gt;a-&gt;Bool) -&gt; [a] -&gt; Int# -&gt; a
<a name="line-678"></a>and the type-class specialiser can't specialise that.  An example is
<a name="line-679"></a>Trac #6056.
<a name="line-680"></a>
<a name="line-681"></a>Moreover, dictionaries can have a lot of fields, so unpacking them can
<a name="line-682"></a>increase closure sizes.
<a name="line-683"></a>
<a name="line-684"></a>Conclusion: don't unpack dictionaries.
<a name="line-685"></a>-}</span>
<a name="line-686"></a>
<a name="line-687"></a><a name="deepSplitProductType_maybe"></a><span class='hs-definition'>deepSplitProductType_maybe</span>
<a name="line-688"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-689"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>StrictnessMark</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-690"></a><span class='hs-comment'>-- If    deepSplitProductType_maybe ty = Just (dc, tys, arg_tys, co)</span>
<a name="line-691"></a><span class='hs-comment'>-- then  dc @ tys (args::arg_tys) :: rep_ty</span>
<a name="line-692"></a><span class='hs-comment'>--       co :: ty ~ rep_ty</span>
<a name="line-693"></a><span class='hs-comment'>-- Why do we return the strictness of the data-con arguments?</span>
<a name="line-694"></a><span class='hs-comment'>-- Answer: see Note [Record evaluated-ness in worker/wrapper]</span>
<a name="line-695"></a><span class='hs-definition'>deepSplitProductType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-696"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-697"></a>                    <span class='hs-varop'>`orElse`</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkRepReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-698"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-699"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isDataProductTyCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-700"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isClassTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [Do not unpack class dictionaries]</span>
<a name="line-701"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span>
<a name="line-702"></a>        <span class='hs-varid'>strict_marks</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>con</span>
<a name="line-703"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>zipEqual</span> <span class='hs-str'>"dspt"</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>strict_marks</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-704"></a><span class='hs-definition'>deepSplitProductType_maybe</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-705"></a>
<a name="line-706"></a><a name="deepSplitCprType_maybe"></a><span class='hs-definition'>deepSplitCprType_maybe</span>
<a name="line-707"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConTag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-708"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>StrictnessMark</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-709"></a><span class='hs-comment'>-- If    deepSplitCprType_maybe n ty = Just (dc, tys, arg_tys, co)</span>
<a name="line-710"></a><span class='hs-comment'>-- then  dc @ tys (args::arg_tys) :: rep_ty</span>
<a name="line-711"></a><span class='hs-comment'>--       co :: ty ~ rep_ty</span>
<a name="line-712"></a><span class='hs-comment'>-- Why do we return the strictness of the data-con arguments?</span>
<a name="line-713"></a><span class='hs-comment'>-- Answer: see Note [Record evaluated-ness in worker/wrapper]</span>
<a name="line-714"></a><span class='hs-definition'>deepSplitCprType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>con_tag</span> <span class='hs-varid'>ty</span>
<a name="line-715"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-716"></a>                    <span class='hs-varop'>`orElse`</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkRepReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-717"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-718"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isDataTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-719"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tc</span>
<a name="line-720"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>cons</span> <span class='hs-varop'>`lengthAtLeast`</span> <span class='hs-varid'>con_tag</span> <span class='hs-comment'>-- This might not be true if we import the</span>
<a name="line-721"></a>                                 <span class='hs-comment'>-- type constructor via a .hs-bool file (#8743)</span>
<a name="line-722"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cons</span> <span class='hs-varop'>`getNth`</span> <span class='hs-layout'>(</span><span class='hs-varid'>con_tag</span> <span class='hs-comment'>-</span> <span class='hs-varid'>fIRST_TAG</span><span class='hs-layout'>)</span>
<a name="line-723"></a>        <span class='hs-varid'>arg_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span>
<a name="line-724"></a>        <span class='hs-varid'>strict_marks</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>con</span>
<a name="line-725"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>zipEqual</span> <span class='hs-str'>"dsct"</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>strict_marks</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-726"></a><span class='hs-definition'>deepSplitCprType_maybe</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-727"></a>
<a name="line-728"></a><a name="findTypeShape"></a><span class='hs-definition'>findTypeShape</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeShape</span>
<a name="line-729"></a><span class='hs-comment'>-- Uncover the arrow and product shape of a type</span>
<a name="line-730"></a><span class='hs-comment'>-- The data type TypeShape is defined in Demand</span>
<a name="line-731"></a><span class='hs-comment'>-- See Note [Trimming a demand to a type] in Demand</span>
<a name="line-732"></a><span class='hs-definition'>findTypeShape</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-733"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-734"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isDataProductTyCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-735"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TsProd</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>findTypeShape</span> <span class='hs-varid'>fam_envs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span>
<a name="line-736"></a>
<a name="line-737"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-738"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TsFun</span> <span class='hs-layout'>(</span><span class='hs-varid'>findTypeShape</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<a name="line-739"></a>
<a name="line-740"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTy_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-741"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findTypeShape</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty'</span>
<a name="line-742"></a>
<a name="line-743"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-744"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findTypeShape</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty'</span>
<a name="line-745"></a>
<a name="line-746"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-747"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TsUnk</span>
<a name="line-748"></a>
<a name="line-749"></a><span class='hs-comment'>{-
<a name="line-750"></a>************************************************************************
<a name="line-751"></a>*                                                                      *
<a name="line-752"></a>\subsection{CPR stuff}
<a name="line-753"></a>*                                                                      *
<a name="line-754"></a>************************************************************************
<a name="line-755"></a>
<a name="line-756"></a>
<a name="line-757"></a>@mkWWcpr@ takes the worker/wrapper pair produced from the strictness
<a name="line-758"></a>info and adds in the CPR transformation.  The worker returns an
<a name="line-759"></a>unboxed tuple containing non-CPR components.  The wrapper takes this
<a name="line-760"></a>tuple and re-produces the correct structured output.
<a name="line-761"></a>
<a name="line-762"></a>The non-CPR results appear ordered in the unboxed tuple as if by a
<a name="line-763"></a>left-to-right traversal of the result structure.
<a name="line-764"></a>-}</span>
<a name="line-765"></a>
<a name="line-766"></a><a name="mkWWcpr"></a><span class='hs-definition'>mkWWcpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-767"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-768"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>                              <span class='hs-comment'>-- function body type</span>
<a name="line-769"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdResult</span>                         <span class='hs-comment'>-- CPR analysis results</span>
<a name="line-770"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                     <span class='hs-comment'>-- Is w/w'ing useful?</span>
<a name="line-771"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- New wrapper</span>
<a name="line-772"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- New worker</span>
<a name="line-773"></a>                   <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>                     <span class='hs-comment'>-- Type of worker's body</span>
<a name="line-774"></a>
<a name="line-775"></a><span class='hs-definition'>mkWWcpr</span> <span class='hs-varid'>opt_CprAnal</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>res</span>
<a name="line-776"></a>    <span class='hs-comment'>-- CPR explicitly turned off (or in -O0)</span>
<a name="line-777"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>opt_CprAnal</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>
<a name="line-778"></a>    <span class='hs-comment'>-- CPR is turned on by default for -O and O2</span>
<a name="line-779"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-780"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>returnsCPR_maybe</span> <span class='hs-varid'>res</span> <span class='hs-keyword'>of</span>
<a name="line-781"></a>       <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- No CPR info</span>
<a name="line-782"></a>       <span class='hs-conid'>Just</span> <span class='hs-varid'>con_tag</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deepSplitCprType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>con_tag</span> <span class='hs-varid'>body_ty</span>
<a name="line-783"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkWWcpr_help</span> <span class='hs-varid'>stuff</span>
<a name="line-784"></a>                    <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>otherwise</span>
<a name="line-785"></a>                       <span class='hs-comment'>-- See Note [non-algebraic or open body type warning]</span>
<a name="line-786"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"mkWWcpr: non-algebraic or open body type"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>body_ty</span> <span class='hs-layout'>)</span>
<a name="line-787"></a>                       <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>
<a name="line-788"></a>
<a name="line-789"></a><a name="mkWWcpr_help"></a><span class='hs-definition'>mkWWcpr_help</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span><span class='hs-conid'>StrictnessMark</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-790"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-791"></a>
<a name="line-792"></a><span class='hs-definition'>mkWWcpr_help</span> <span class='hs-layout'>(</span><span class='hs-varid'>data_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-793"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>arg_ty1</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>arg_tys</span>
<a name="line-794"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>arg_ty1</span>
<a name="line-795"></a>        <span class='hs-comment'>-- Special case when there is a single result of unlifted type</span>
<a name="line-796"></a>        <span class='hs-comment'>--</span>
<a name="line-797"></a>        <span class='hs-comment'>-- Wrapper:     case (..call worker..) of x -&gt; C x</span>
<a name="line-798"></a>        <span class='hs-comment'>-- Worker:      case (   ..body..    ) of C x -&gt; x</span>
<a name="line-799"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>arg_uniq</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-800"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>arg_uniq</span> <span class='hs-varid'>arg1</span>
<a name="line-801"></a>             <span class='hs-varid'>con_app</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>inst_tys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-802"></a>
<a name="line-803"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-conid'>True</span>
<a name="line-804"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>wkr_call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>wkr_call</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DEFAULT</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-805"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>body</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span> <span class='hs-varid'>work_uniq</span> <span class='hs-varid'>data_con</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-806"></a>                                <span class='hs-comment'>-- varToCoreExpr important here: arg can be a coercion</span>
<a name="line-807"></a>                                <span class='hs-comment'>-- Lacking this caused Trac #10658</span>
<a name="line-808"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty1</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-809"></a>
<a name="line-810"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- The general case</span>
<a name="line-811"></a>        <span class='hs-comment'>-- Wrapper: case (..call worker..) of (# a, b #) -&gt; C a b</span>
<a name="line-812"></a>        <span class='hs-comment'>-- Worker:  case (   ...body...  ) of C a b -&gt; (# a, b #)</span>
<a name="line-813"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wild_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>uniqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-814"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wrap_wild</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>wild_uniq</span> <span class='hs-layout'>(</span><span class='hs-varid'>ubx_tup_ty</span><span class='hs-layout'>,</span><span class='hs-conid'>MarkedStrict</span><span class='hs-layout'>)</span>
<a name="line-815"></a>             <span class='hs-varid'>args</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>uniqs</span> <span class='hs-varid'>arg_tys</span>
<a name="line-816"></a>             <span class='hs-varid'>ubx_tup_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>ubx_tup_app</span>
<a name="line-817"></a>             <span class='hs-varid'>ubx_tup_app</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCoreUbxTup</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-818"></a>             <span class='hs-varid'>con_app</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>args</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-819"></a>
<a name="line-820"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span>
<a name="line-821"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>wkr_call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>wkr_call</span> <span class='hs-varid'>wrap_wild</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-layout'>(</span><span class='hs-varid'>tupleDataCon</span> <span class='hs-conid'>Unboxed</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-822"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>body</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span> <span class='hs-varid'>work_uniq</span> <span class='hs-varid'>data_con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>ubx_tup_app</span>
<a name="line-823"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>ubx_tup_ty</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-824"></a>
<a name="line-825"></a><a name="mkUnpackCase"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-826"></a><span class='hs-comment'>-- (mkUnpackCase e co uniq Con args body)</span>
<a name="line-827"></a><span class='hs-comment'>--      returns</span>
<a name="line-828"></a><span class='hs-comment'>-- case e |&gt; co of bndr { Con args -&gt; body }</span>
<a name="line-829"></a>
<a name="line-830"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>body</span>   <span class='hs-comment'>-- See Note [Profiling and unpacking]</span>
<a name="line-831"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-832"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>co</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>boxing_con</span> <span class='hs-varid'>unpk_args</span> <span class='hs-varid'>body</span>
<a name="line-833"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>casted_scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-834"></a>         <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>boxing_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpk_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-835"></a>  <span class='hs-keyword'>where</span>
<a name="line-836"></a>    <span class='hs-varid'>casted_scrut</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scrut</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>co</span>
<a name="line-837"></a>    <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>uniq</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>casted_scrut</span><span class='hs-layout'>,</span> <span class='hs-conid'>MarkedStrict</span><span class='hs-layout'>)</span>
<a name="line-838"></a>
<a name="line-839"></a><span class='hs-comment'>{-
<a name="line-840"></a>Note [non-algebraic or open body type warning]
<a name="line-841"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-842"></a>
<a name="line-843"></a>There are a few cases where the W/W transformation is told that something
<a name="line-844"></a>returns a constructor, but the type at hand doesn't really match this. One
<a name="line-845"></a>real-world example involves unsafeCoerce:
<a name="line-846"></a>  foo = IO a
<a name="line-847"></a>  foo = unsafeCoerce c_exit
<a name="line-848"></a>  foreign import ccall "c_exit" c_exit :: IO ()
<a name="line-849"></a>Here CPR will tell you that `foo` returns a () constructor for sure, but trying
<a name="line-850"></a>to create a worker/wrapper for type `a` obviously fails.
<a name="line-851"></a>(This was a real example until ee8e792  in libraries/base.)
<a name="line-852"></a>
<a name="line-853"></a>It does not seem feasible to avoid all such cases already in the analyser (and
<a name="line-854"></a>after all, the analysis is not really wrong), so we simply do nothing here in
<a name="line-855"></a>mkWWcpr. But we still want to emit warning with -DDEBUG, to hopefully catch
<a name="line-856"></a>other cases where something went avoidably wrong.
<a name="line-857"></a>
<a name="line-858"></a>
<a name="line-859"></a>Note [Profiling and unpacking]
<a name="line-860"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-861"></a>If the original function looked like
<a name="line-862"></a>        f = \ x -&gt; {-# SCC "foo" #-} E
<a name="line-863"></a>
<a name="line-864"></a>then we want the CPR'd worker to look like
<a name="line-865"></a>        \ x -&gt; {-# SCC "foo" #-} (case E of I# x -&gt; x)
<a name="line-866"></a>and definitely not
<a name="line-867"></a>        \ x -&gt; case ({-# SCC "foo" #-} E) of I# x -&gt; x)
<a name="line-868"></a>
<a name="line-869"></a>This transform doesn't move work or allocation
<a name="line-870"></a>from one cost centre to another.
<a name="line-871"></a>
<a name="line-872"></a>Later [SDM]: presumably this is because we want the simplifier to
<a name="line-873"></a>eliminate the case, and the scc would get in the way?  I'm ok with
<a name="line-874"></a>including the case itself in the cost centre, since it is morally
<a name="line-875"></a>part of the function (post transformation) anyway.
<a name="line-876"></a>
<a name="line-877"></a>
<a name="line-878"></a>************************************************************************
<a name="line-879"></a>*                                                                      *
<a name="line-880"></a>\subsection{Utilities}
<a name="line-881"></a>*                                                                      *
<a name="line-882"></a>************************************************************************
<a name="line-883"></a>
<a name="line-884"></a>Note [Absent errors]
<a name="line-885"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-886"></a>We make a new binding for Ids that are marked absent, thus
<a name="line-887"></a>   let x = absentError "x :: Int"
<a name="line-888"></a>The idea is that this binding will never be used; but if it
<a name="line-889"></a>buggily is used we'll get a runtime error message.
<a name="line-890"></a>
<a name="line-891"></a>Coping with absence for *unlifted* types is important; see, for
<a name="line-892"></a>example, Trac #4306.  For these we find a suitable literal,
<a name="line-893"></a>using Literal.absentLiteralOf.  We don't have literals for
<a name="line-894"></a>every primitive type, so the function is partial.
<a name="line-895"></a>
<a name="line-896"></a>    [I did try the experiment of using an error thunk for unlifted
<a name="line-897"></a>    things too, relying on the simplifier to drop it as dead code,
<a name="line-898"></a>    by making absentError
<a name="line-899"></a>      (a) *not* be a bottoming Id,
<a name="line-900"></a>      (b) be "ok for speculation"
<a name="line-901"></a>    But that relies on the simplifier finding that it really
<a name="line-902"></a>    is dead code, which is fragile, and indeed failed when
<a name="line-903"></a>    profiling is on, which disables various optimisations.  So
<a name="line-904"></a>    using a literal will do.]
<a name="line-905"></a>-}</span>
<a name="line-906"></a>
<a name="line-907"></a><a name="mk_absent_let"></a><span class='hs-definition'>mk_absent_let</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-908"></a><span class='hs-definition'>mk_absent_let</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>arg</span>
<a name="line-909"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-910"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>lifted_arg</span> <span class='hs-varid'>abs_rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-911"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-varid'>arg_ty</span>
<a name="line-912"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>absentLiteralOf</span> <span class='hs-varid'>tc</span>
<a name="line-913"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-914"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>voidPrimTy</span>
<a name="line-915"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>voidPrimId</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-916"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-917"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"No absent value for"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_ty</span> <span class='hs-layout'>)</span>
<a name="line-918"></a>    <span class='hs-conid'>Nothing</span>
<a name="line-919"></a>  <span class='hs-keyword'>where</span>
<a name="line-920"></a>    <span class='hs-varid'>arg_ty</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span>
<a name="line-921"></a>    <span class='hs-varid'>abs_rhs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkRuntimeErrorApp</span> <span class='hs-varid'>aBSENT_ERROR_ID</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>msg</span>
<a name="line-922"></a>    <span class='hs-varid'>lifted_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>`setIdStrictness`</span> <span class='hs-varid'>exnSig</span>
<a name="line-923"></a>              <span class='hs-comment'>-- Note in strictness signature that this is bottoming</span>
<a name="line-924"></a>              <span class='hs-comment'>-- (for the sake of the "empty case scrutinee not known to</span>
<a name="line-925"></a>              <span class='hs-comment'>-- diverge for sure lint" warning)</span>
<a name="line-926"></a>    <span class='hs-varid'>msg</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showSDoc</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt_set</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_SuppressUniques</span><span class='hs-layout'>)</span>
<a name="line-927"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-928"></a>              <span class='hs-comment'>-- We need to suppress uniques here because otherwise they'd</span>
<a name="line-929"></a>              <span class='hs-comment'>-- end up in the generated code as strings. This is bad for</span>
<a name="line-930"></a>              <span class='hs-comment'>-- determinism, because with different uniques the strings</span>
<a name="line-931"></a>              <span class='hs-comment'>-- will have different lengths and hence different costs for</span>
<a name="line-932"></a>              <span class='hs-comment'>-- the inliner leading to different inlining.</span>
<a name="line-933"></a>              <span class='hs-comment'>-- See also Note [Unique Determinism] in Unique</span>
<a name="line-934"></a>
<a name="line-935"></a><a name="mk_seq_case"></a><span class='hs-definition'>mk_seq_case</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-936"></a><span class='hs-definition'>mk_seq_case</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>sanitiseCaseBndr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>DEFAULT</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-937"></a>
<a name="line-938"></a><a name="sanitiseCaseBndr"></a><span class='hs-definition'>sanitiseCaseBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-939"></a><span class='hs-comment'>-- The argument we are scrutinising has the right type to be</span>
<a name="line-940"></a><span class='hs-comment'>-- a case binder, so it's convenient to re-use it for that purpose.</span>
<a name="line-941"></a><span class='hs-comment'>-- But we *must* throw away all its IdInfo.  In particular, the argument</span>
<a name="line-942"></a><span class='hs-comment'>-- will have demand info on it, and that demand info may be incorrect for</span>
<a name="line-943"></a><span class='hs-comment'>-- the case binder.  e.g.       case ww_arg of ww_arg { I# x -&gt; ... }</span>
<a name="line-944"></a><span class='hs-comment'>-- Quite likely ww_arg isn't used in '...'.  The case may get discarded</span>
<a name="line-945"></a><span class='hs-comment'>-- if the case binder says "I'm demanded".  This happened in a situation</span>
<a name="line-946"></a><span class='hs-comment'>-- like         (x+y) `seq` ....</span>
<a name="line-947"></a><span class='hs-definition'>sanitiseCaseBndr</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span> <span class='hs-varop'>`setIdInfo`</span> <span class='hs-varid'>vanillaIdInfo</span>
<a name="line-948"></a>
<a name="line-949"></a><a name="mk_ww_local"></a><span class='hs-definition'>mk_ww_local</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>StrictnessMark</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-950"></a><span class='hs-comment'>-- The StrictnessMark comes form the data constructor and says</span>
<a name="line-951"></a><span class='hs-comment'>-- whether this field is strict</span>
<a name="line-952"></a><span class='hs-comment'>-- See Note [Record evaluated-ness in worker/wrapper]</span>
<a name="line-953"></a><span class='hs-definition'>mk_ww_local</span> <span class='hs-varid'>uniq</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span><span class='hs-varid'>str</span><span class='hs-layout'>)</span>
<a name="line-954"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setCaseBndrEvald</span> <span class='hs-varid'>str</span> <span class='hs-varop'>$</span>
<a name="line-955"></a>    <span class='hs-varid'>mkSysLocalOrCoVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"ww"</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>ty</span>
</pre></body>
</html>
