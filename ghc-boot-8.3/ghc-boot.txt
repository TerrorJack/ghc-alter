-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shared functionality between GHC and its boot libraries
--   
--   This library is shared between GHC, ghc-pkg, and other boot libraries.
--   
--   A note about <a>GHC.PackageDb</a>: it only deals with the subset of
--   the package database that the compiler cares about: modules paths etc
--   and not package metadata like description, authors etc. It is thus not
--   a library interface to ghc-pkg and is *not* suitable for modifying GHC
--   package databases.
--   
--   The package database format and this library are constructed in such a
--   way that while ghc-pkg depends on Cabal, the GHC library and program
--   do not have to depend on Cabal.
@package ghc-boot
@version 8.3


-- | See <tt>GHC.LanguageExtensions</tt> for an explanation on why this is
--   needed
module GHC.ForeignSrcLang
instance Data.Binary.Class.Binary GHC.ForeignSrcLang.Type.ForeignSrcLang


-- | This module re-exports the <a>Extension</a> type along with an orphan
--   <a>Binary</a> instance for it.
--   
--   Note that the <tt>ghc-boot</tt> package has a large set of
--   dependencies; for this reason the <a>Extension</a> type itself is
--   defined in the <a>GHC.LanguageExtensions.Type</a> module provided by
--   the <tt>ghc-boot-th</tt> package, which has no dependencies outside of
--   <tt>base</tt>. For this reason <tt>template-haskell</tt> depends upon
--   <tt>ghc-boot-th</tt>, not <tt>ghc-boot</tt>.
module GHC.LanguageExtensions
instance Data.Binary.Class.Binary GHC.LanguageExtensions.Type.Extension


-- | This module provides the view of GHC's database of registered packages
--   that is shared between GHC the compiler/library, and the ghc-pkg
--   program. It defines the database format that is shared between GHC and
--   ghc-pkg.
--   
--   The database format, and this library are constructed so that GHC does
--   not have to depend on the Cabal library. The ghc-pkg program acts as
--   the gateway between the external package format (which is defined by
--   Cabal) and the internal package format which is specialised just for
--   GHC.
--   
--   GHC the compiler only needs some of the information which is kept
--   about registerd packages, such as module names, various paths etc. On
--   the other hand ghc-pkg has to keep all the information from Cabal
--   packages and be able to regurgitate it for users and other tools.
--   
--   The first trick is that we duplicate some of the information in the
--   package database. We essentially keep two versions of the datbase in
--   one file, one version used only by ghc-pkg which keeps the full
--   information (using the serialised form of the
--   <a>InstalledPackageInfo</a> type defined by the Cabal library); and a
--   second version written by ghc-pkg and read by GHC which has just the
--   subset of information that GHC needs.
--   
--   The second trick is that this module only defines in detail the format
--   of the second version -- the bit GHC uses -- and the part managed by
--   ghc-pkg is kept in the file but here we treat it as an opaque blob of
--   data. That way this library avoids depending on Cabal.
module GHC.PackageDb

-- | This is a subset of Cabal's <a>InstalledPackageInfo</a>, with just the
--   bits that GHC is interested in. See Cabal's documentation for a more
--   detailed description of all of the fields.
data InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
InstalledPackageInfo :: instunitid -> compid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> String -> [instunitid] -> [(instunitid, String)] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [FilePath] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
[unitId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> instunitid
[componentId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> compid
[instantiatedWith] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, mod)]
[sourcePackageId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgid
[packageName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgname
[packageVersion] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Version
[sourceLibName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Maybe srcpkgname
[abiHash] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> String
[depends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [instunitid]

-- | Like <a>depends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[abiDepends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(instunitid, String)]
[importDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[hsLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraGHCiLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[libraryDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[libraryDynDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[frameworks] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[frameworkDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[ldOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[ccOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includes] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includeDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockInterfaces] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockHTMLs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[exposedModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, Maybe mod)]
[hiddenModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [modulename]
[indefinite] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[exposed] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[trusted] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool

-- | <tt>ghc-boot</tt>'s copy of <tt>Module</tt>, i.e. what is serialized
--   to the database. Use <a>DbUnitIdModuleRep</a> to convert it into an
--   actual <tt>Module</tt>. It has phantom type parameters as this is the
--   most convenient way to avoid undecidable instances.
data DbModule instunitid compid unitid modulename mod
DbModule :: unitid -> modulename -> DbModule instunitid compid unitid modulename mod
[dbModuleUnitId] :: DbModule instunitid compid unitid modulename mod -> unitid
[dbModuleName] :: DbModule instunitid compid unitid modulename mod -> modulename
DbModuleVar :: modulename -> DbModule instunitid compid unitid modulename mod
[dbModuleVarName] :: DbModule instunitid compid unitid modulename mod -> modulename

-- | <tt>ghc-boot</tt>'s copy of <tt>UnitId</tt>, i.e. what is serialized
--   to the database. Use <a>DbUnitIdModuleRep</a> to convert it into an
--   actual <tt>UnitId</tt>. It has phantom type parameters as this is the
--   most convenient way to avoid undecidable instances.
data DbUnitId instunitid compid unitid modulename mod
DbUnitId :: compid -> [(modulename, mod)] -> DbUnitId instunitid compid unitid modulename mod
DbInstalledUnitId :: instunitid -> DbUnitId instunitid compid unitid modulename mod
class BinaryStringRep a
fromStringRep :: BinaryStringRep a => ByteString -> a
toStringRep :: BinaryStringRep a => a -> ByteString

-- | A type-class for the types which can be converted into
--   'DbModule'/'DbUnitId'. There is only one type class because these
--   types are mutually recursive. NB: The functional dependency helps out
--   type inference in cases where types would be ambiguous.
class DbUnitIdModuleRep instunitid compid unitid modulename mod | mod -> unitid, unitid -> mod, mod -> modulename, unitid -> compid, unitid -> instunitid
fromDbModule :: DbUnitIdModuleRep instunitid compid unitid modulename mod => DbModule instunitid compid unitid modulename mod -> mod
toDbModule :: DbUnitIdModuleRep instunitid compid unitid modulename mod => mod -> DbModule instunitid compid unitid modulename mod
fromDbUnitId :: DbUnitIdModuleRep instunitid compid unitid modulename mod => DbUnitId instunitid compid unitid modulename mod -> unitid
toDbUnitId :: DbUnitIdModuleRep instunitid compid unitid modulename mod => unitid -> DbUnitId instunitid compid unitid modulename mod
emptyInstalledPackageInfo :: RepInstalledPackageInfo a b c d e f g => InstalledPackageInfo a b c d e f g

-- | Represents a lock of a package db.
data PackageDbLock

-- | Acquire an exclusive lock related to package DB under given location.
lockPackageDb :: FilePath -> IO PackageDbLock

-- | Release the lock related to package DB.
unlockPackageDb :: PackageDbLock -> IO ()

-- | Mode to open a package db in.
data DbMode
DbReadOnly :: DbMode
DbReadWrite :: DbMode

-- | <a>DbOpenMode</a> holds a value of type <tt>t</tt> but only in
--   <a>DbReadWrite</a> mode. So it is like <a>Maybe</a> but with a type
--   argument for the mode to enforce that the mode is used consistently.
data DbOpenMode (mode :: DbMode) t
[DbOpenReadOnly] :: DbOpenMode  'DbReadOnly t
[DbOpenReadWrite] :: t -> DbOpenMode  'DbReadWrite t
isDbOpenReadMode :: DbOpenMode mode t -> Bool

-- | Read the part of the package DB that GHC is interested in.
readPackageDbForGhc :: RepInstalledPackageInfo a b c d e f g => FilePath -> IO [InstalledPackageInfo a b c d e f g]

-- | Read the part of the package DB that ghc-pkg is interested in
--   
--   Note that the Binary instance for ghc-pkg's representation of packages
--   is not defined in this package. This is because ghc-pkg uses Cabal
--   types (and Binary instances for these) which this package does not
--   depend on.
--   
--   If we open the package db in read only mode, we get its contents.
--   Otherwise we additionally receive a PackageDbLock that represents a
--   lock on the database, so that we can safely update it later.
readPackageDbForGhcPkg :: Binary pkgs => FilePath -> DbOpenMode mode t -> IO (pkgs, DbOpenMode mode PackageDbLock)

-- | Write the whole of the package DB, both parts.
writePackageDb :: (Binary pkgs, RepInstalledPackageInfo a b c d e f g) => FilePath -> [InstalledPackageInfo a b c d e f g] -> pkgs -> IO ()
instance (GHC.Show.Show instunitid, GHC.Show.Show mod, GHC.Show.Show modulename, GHC.Show.Show compid) => GHC.Show.Show (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)
instance (GHC.Classes.Eq instunitid, GHC.Classes.Eq mod, GHC.Classes.Eq modulename, GHC.Classes.Eq compid) => GHC.Classes.Eq (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)
instance (GHC.Show.Show modulename, GHC.Show.Show unitid) => GHC.Show.Show (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.Classes.Eq modulename, GHC.Classes.Eq unitid) => GHC.Classes.Eq (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.Show.Show srcpkgname, GHC.Show.Show srcpkgid, GHC.Show.Show mod, GHC.Show.Show modulename, GHC.Show.Show compid, GHC.Show.Show instunitid) => GHC.Show.Show (GHC.PackageDb.InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod)
instance (GHC.Classes.Eq srcpkgname, GHC.Classes.Eq srcpkgid, GHC.Classes.Eq mod, GHC.Classes.Eq modulename, GHC.Classes.Eq compid, GHC.Classes.Eq instunitid) => GHC.Classes.Eq (GHC.PackageDb.InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod)
instance GHC.Base.Functor (GHC.PackageDb.DbOpenMode mode)
instance Data.Foldable.Foldable (GHC.PackageDb.DbOpenMode mode)
instance Data.Traversable.Traversable (GHC.PackageDb.DbOpenMode mode)
instance GHC.PackageDb.RepInstalledPackageInfo a b c d e f g => Data.Binary.Class.Binary (GHC.PackageDb.InstalledPackageInfo a b c d e f g)
instance (GHC.PackageDb.BinaryStringRep modulename, GHC.PackageDb.BinaryStringRep compid, GHC.PackageDb.BinaryStringRep instunitid, GHC.PackageDb.DbUnitIdModuleRep instunitid compid unitid modulename mod) => Data.Binary.Class.Binary (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.PackageDb.BinaryStringRep modulename, GHC.PackageDb.BinaryStringRep compid, GHC.PackageDb.BinaryStringRep instunitid, GHC.PackageDb.DbUnitIdModuleRep instunitid compid unitid modulename mod) => Data.Binary.Class.Binary (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)

module GHC.Serialized

-- | Represents a serialized value of a particular type. Attempts can be
--   made to deserialize it at certain types
data Serialized
Serialized :: TypeRep -> [Word8] -> Serialized

-- | Put a Typeable value that we are able to actually turn into bytes into
--   a <a>Serialized</a> value ready for deserialization later
toSerialized :: forall a. Typeable a => (a -> [Word8]) -> a -> Serialized

-- | If the <a>Serialized</a> value contains something of the given type,
--   then use the specified deserializer to return <tt>Just</tt> that.
--   Otherwise return <tt>Nothing</tt>.
fromSerialized :: forall a. Typeable a => ([Word8] -> a) -> Serialized -> Maybe a

-- | Use a <a>Data</a> instance to implement a serialization scheme dual to
--   that of <a>deserializeWithData</a>
serializeWithData :: Data a => a -> [Word8]

-- | Use a <a>Data</a> instance to implement a deserialization scheme dual
--   to that of <a>serializeWithData</a>
deserializeWithData :: Data a => [Word8] -> a
