{-
This is a generated file (generated by genprimopcode).
It is not code to actually be used. Its only purpose is to be
consumed by haddock.
-}

-----------------------------------------------------------------------------
-- |
-- Module      :  GHC.Prim
-- 
-- Maintainer  :  ghc-devs@haskell.org
-- Stability   :  internal
-- Portability :  non-portable (GHC extensions)
--
-- GHC's primitive types and operations.
-- Use GHC.Exts from the base package instead of importing this
-- module directly.
--
-----------------------------------------------------------------------------
{-# LANGUAGE Unsafe #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE UnboxedTuples #-}
{-# OPTIONS_GHC -fno-warn-redundant-constraints #-}
module GHC.Prim (
        
-- * The word size story.
-- |Haskell98 specifies that signed integers (type @Int@)
--          must contain at least 30 bits. GHC always implements @Int@ using the primitive type @Int\#@, whose size equals
--          the @MachDeps.h@ constant @WORD\_SIZE\_IN\_BITS@.
--          This is normally set based on the @config.h@ parameter
--          @SIZEOF\_HSWORD@, i.e., 32 bits on 32-bit machines, 64
--          bits on 64-bit machines.  However, it can also be explicitly
--          set to a smaller number, e.g., 31 bits, to allow the
--          possibility of using tag bits. Currently GHC itself has only
--          32-bit and 64-bit variants, but 30 or 31-bit code can be
--          exported as an external core file for use in other back ends.
-- 
--          GHC also implements a primitive unsigned integer type @Word\#@ which always has the same number of bits as @Int\#@.
-- 
--          In addition, GHC supports families of explicit-sized integers
--          and words at 8, 16, 32, and 64 bits, with the usual
--          arithmetic operations, comparisons, and a range of
--          conversions.  The 8-bit and 16-bit sizes are always
--          represented as @Int\#@ and @Word\#@, and the
--          operations implemented in terms of the the primops on these
--          types, with suitable range restrictions on the results (using
--          the @narrow$n$Int\#@ and @narrow$n$Word\#@ families
--          of primops.  The 32-bit sizes are represented using @Int\#@ and @Word\#@ when @WORD\_SIZE\_IN\_BITS@
--          $\geq$ 32; otherwise, these are represented using distinct
--          primitive types @Int32\#@ and @Word32\#@. These (when
--          needed) have a complete set of corresponding operations;
--          however, nearly all of these are implemented as external C
--          functions rather than as primops.  Exactly the same story
--          applies to the 64-bit sizes.  All of these details are hidden
--          under the @PrelInt@ and @PrelWord@ modules, which use
--          @\#if@-defs to invoke the appropriate types and
--          operators.
-- 
--          Word size also matters for the families of primops for
--          indexing\/reading\/writing fixed-size quantities at offsets
--          from an array base, address, or foreign pointer.  Here, a
--          slightly different approach is taken.  The names of these
--          primops are fixed, but their /types/ vary according to
--          the value of @WORD\_SIZE\_IN\_BITS@. For example, if word
--          size is at least 32 bits then an operator like
--          @indexInt32Array\#@ has type @ByteArray\# -> Int\#          -> Int\#@; otherwise it has type @ByteArray\# -> Int\# ->          Int32\#@.  This approach confines the necessary @\#if@-defs to this file; no conditional compilation is needed
--          in the files that expose these primops.
-- 
--          Finally, there are strongly deprecated primops for coercing
--          between @Addr\#@, the primitive type of machine
--          addresses, and @Int\#@.  These are pretty bogus anyway,
--          but will work on existing 32-bit and 64-bit GHC targets; they
--          are completely bogus when tag bits are used in @Int\#@,
--          so are not available in this case.  


        
-- * Char#
-- |Operations on 31-bit characters.


        Char#,
        gtChar#,
        geChar#,
        eqChar#,
        neChar#,
        ltChar#,
        leChar#,
        ord#,
        
-- * Int#
-- |Operations on native-size integers (30+ bits).


        Int#,
        (+#),
        (-#),
        (*#),
        mulIntMayOflo#,
        quotInt#,
        remInt#,
        quotRemInt#,
        andI#,
        orI#,
        xorI#,
        notI#,
        negateInt#,
        addIntC#,
        subIntC#,
        (>#),
        (>=#),
        (==#),
        (/=#),
        (<#),
        (<=#),
        chr#,
        int2Word#,
        int2Float#,
        int2Double#,
        word2Float#,
        word2Double#,
        uncheckedIShiftL#,
        uncheckedIShiftRA#,
        uncheckedIShiftRL#,
        
-- * Word#
-- |Operations on native-sized unsigned words (30+ bits).


        Word#,
        plusWord#,
        subWordC#,
        plusWord2#,
        minusWord#,
        timesWord#,
        timesWord2#,
        quotWord#,
        remWord#,
        quotRemWord#,
        quotRemWord2#,
        and#,
        or#,
        xor#,
        not#,
        uncheckedShiftL#,
        uncheckedShiftRL#,
        word2Int#,
        gtWord#,
        geWord#,
        eqWord#,
        neWord#,
        ltWord#,
        leWord#,
        popCnt8#,
        popCnt16#,
        popCnt32#,
        popCnt64#,
        popCnt#,
        clz8#,
        clz16#,
        clz32#,
        clz64#,
        clz#,
        ctz8#,
        ctz16#,
        ctz32#,
        ctz64#,
        ctz#,
        byteSwap16#,
        byteSwap32#,
        byteSwap64#,
        byteSwap#,
        
-- * Narrowings
-- |Explicit narrowing of native-sized ints or words.


        narrow8Int#,
        narrow16Int#,
        narrow32Int#,
        narrow8Word#,
        narrow16Word#,
        narrow32Word#,
        
-- * Double#
-- |Operations on double-precision (64 bit) floating-point numbers.


        Double#,
        (>##),
        (>=##),
        (==##),
        (/=##),
        (<##),
        (<=##),
        (+##),
        (-##),
        (*##),
        (/##),
        negateDouble#,
        fabsDouble#,
        double2Int#,
        double2Float#,
        expDouble#,
        logDouble#,
        sqrtDouble#,
        sinDouble#,
        cosDouble#,
        tanDouble#,
        asinDouble#,
        acosDouble#,
        atanDouble#,
        sinhDouble#,
        coshDouble#,
        tanhDouble#,
        (**##),
        decodeDouble_2Int#,
        decodeDouble_Int64#,
        
-- * Float#
-- |Operations on single-precision (32-bit) floating-point numbers.


        Float#,
        gtFloat#,
        geFloat#,
        eqFloat#,
        neFloat#,
        ltFloat#,
        leFloat#,
        plusFloat#,
        minusFloat#,
        timesFloat#,
        divideFloat#,
        negateFloat#,
        fabsFloat#,
        float2Int#,
        expFloat#,
        logFloat#,
        sqrtFloat#,
        sinFloat#,
        cosFloat#,
        tanFloat#,
        asinFloat#,
        acosFloat#,
        atanFloat#,
        sinhFloat#,
        coshFloat#,
        tanhFloat#,
        powerFloat#,
        float2Double#,
        decodeFloat_Int#,
        
-- * Arrays
-- |Operations on @Array\#@.


        Array#,
        MutableArray#,
        newArray#,
        sameMutableArray#,
        readArray#,
        writeArray#,
        sizeofArray#,
        sizeofMutableArray#,
        indexArray#,
        unsafeFreezeArray#,
        unsafeThawArray#,
        copyArray#,
        copyMutableArray#,
        cloneArray#,
        cloneMutableArray#,
        freezeArray#,
        thawArray#,
        casArray#,
        
-- * Small Arrays
-- |Operations on @SmallArray\#@. A @SmallArray\#@ works
--          just like an @Array\#@, but with different space use and
--          performance characteristics (that are often useful with small
--          arrays). The @SmallArray\#@ and @SmallMutableArray#@
--          lack a \`card table\'. The purpose of a card table is to avoid
--          having to scan every element of the array on each GC by
--          keeping track of which elements have changed since the last GC
--          and only scanning those that have changed. So the consequence
--          of there being no card table is that the representation is
--          somewhat smaller and the writes are somewhat faster (because
--          the card table does not need to be updated). The disadvantage
--          of course is that for a @SmallMutableArray#@ the whole
--          array has to be scanned on each GC. Thus it is best suited for
--          use cases where the mutable array is not long lived, e.g.
--          where a mutable array is initialised quickly and then frozen
--          to become an immutable @SmallArray\#@.
--         


        SmallArray#,
        SmallMutableArray#,
        newSmallArray#,
        sameSmallMutableArray#,
        readSmallArray#,
        writeSmallArray#,
        sizeofSmallArray#,
        sizeofSmallMutableArray#,
        indexSmallArray#,
        unsafeFreezeSmallArray#,
        unsafeThawSmallArray#,
        copySmallArray#,
        copySmallMutableArray#,
        cloneSmallArray#,
        cloneSmallMutableArray#,
        freezeSmallArray#,
        thawSmallArray#,
        casSmallArray#,
        
-- * Byte Arrays
-- |Operations on @ByteArray\#@. A @ByteArray\#@ is a just a region of
--          raw memory in the garbage-collected heap, which is not
--          scanned for pointers. It carries its own size (in bytes).
--          There are
--          three sets of operations for accessing byte array contents:
--          index for reading from immutable byte arrays, and read\/write
--          for mutable byte arrays.  Each set contains operations for a
--          range of useful primitive data types.  Each operation takes
--          an offset measured in terms of the size of the primitive type
--          being read or written.


        ByteArray#,
        MutableByteArray#,
        newByteArray#,
        newPinnedByteArray#,
        newAlignedPinnedByteArray#,
        isMutableByteArrayPinned#,
        isByteArrayPinned#,
        byteArrayContents#,
        sameMutableByteArray#,
        shrinkMutableByteArray#,
        resizeMutableByteArray#,
        unsafeFreezeByteArray#,
        sizeofByteArray#,
        sizeofMutableByteArray#,
        getSizeofMutableByteArray#,
        indexCharArray#,
        indexWideCharArray#,
        indexIntArray#,
        indexWordArray#,
        indexAddrArray#,
        indexFloatArray#,
        indexDoubleArray#,
        indexStablePtrArray#,
        indexInt8Array#,
        indexInt16Array#,
        indexInt32Array#,
        indexInt64Array#,
        indexWord8Array#,
        indexWord16Array#,
        indexWord32Array#,
        indexWord64Array#,
        readCharArray#,
        readWideCharArray#,
        readIntArray#,
        readWordArray#,
        readAddrArray#,
        readFloatArray#,
        readDoubleArray#,
        readStablePtrArray#,
        readInt8Array#,
        readInt16Array#,
        readInt32Array#,
        readInt64Array#,
        readWord8Array#,
        readWord16Array#,
        readWord32Array#,
        readWord64Array#,
        writeCharArray#,
        writeWideCharArray#,
        writeIntArray#,
        writeWordArray#,
        writeAddrArray#,
        writeFloatArray#,
        writeDoubleArray#,
        writeStablePtrArray#,
        writeInt8Array#,
        writeInt16Array#,
        writeInt32Array#,
        writeInt64Array#,
        writeWord8Array#,
        writeWord16Array#,
        writeWord32Array#,
        writeWord64Array#,
        copyByteArray#,
        copyMutableByteArray#,
        copyByteArrayToAddr#,
        copyMutableByteArrayToAddr#,
        copyAddrToByteArray#,
        setByteArray#,
        atomicReadIntArray#,
        atomicWriteIntArray#,
        casIntArray#,
        fetchAddIntArray#,
        fetchSubIntArray#,
        fetchAndIntArray#,
        fetchNandIntArray#,
        fetchOrIntArray#,
        fetchXorIntArray#,
        
-- * Arrays of arrays
-- |Operations on @ArrayArray\#@. An @ArrayArray\#@ contains references to {\em unpointed}
--          arrays, such as @ByteArray\#s@. Hence, it is not parameterised by the element types,
--          just like a @ByteArray\#@, but it needs to be scanned during GC, just like an @Array#@.
--          We represent an @ArrayArray\#@ exactly as a @Array\#@, but provide element-type-specific
--          indexing, reading, and writing.


        ArrayArray#,
        MutableArrayArray#,
        newArrayArray#,
        sameMutableArrayArray#,
        unsafeFreezeArrayArray#,
        sizeofArrayArray#,
        sizeofMutableArrayArray#,
        indexByteArrayArray#,
        indexArrayArrayArray#,
        readByteArrayArray#,
        readMutableByteArrayArray#,
        readArrayArrayArray#,
        readMutableArrayArrayArray#,
        writeByteArrayArray#,
        writeMutableByteArrayArray#,
        writeArrayArrayArray#,
        writeMutableArrayArrayArray#,
        copyArrayArray#,
        copyMutableArrayArray#,
        
-- * Addr#
-- |


        Addr#,
        nullAddr#,
        plusAddr#,
        minusAddr#,
        remAddr#,
        addr2Int#,
        int2Addr#,
        gtAddr#,
        geAddr#,
        eqAddr#,
        neAddr#,
        ltAddr#,
        leAddr#,
        indexCharOffAddr#,
        indexWideCharOffAddr#,
        indexIntOffAddr#,
        indexWordOffAddr#,
        indexAddrOffAddr#,
        indexFloatOffAddr#,
        indexDoubleOffAddr#,
        indexStablePtrOffAddr#,
        indexInt8OffAddr#,
        indexInt16OffAddr#,
        indexInt32OffAddr#,
        indexInt64OffAddr#,
        indexWord8OffAddr#,
        indexWord16OffAddr#,
        indexWord32OffAddr#,
        indexWord64OffAddr#,
        readCharOffAddr#,
        readWideCharOffAddr#,
        readIntOffAddr#,
        readWordOffAddr#,
        readAddrOffAddr#,
        readFloatOffAddr#,
        readDoubleOffAddr#,
        readStablePtrOffAddr#,
        readInt8OffAddr#,
        readInt16OffAddr#,
        readInt32OffAddr#,
        readInt64OffAddr#,
        readWord8OffAddr#,
        readWord16OffAddr#,
        readWord32OffAddr#,
        readWord64OffAddr#,
        writeCharOffAddr#,
        writeWideCharOffAddr#,
        writeIntOffAddr#,
        writeWordOffAddr#,
        writeAddrOffAddr#,
        writeFloatOffAddr#,
        writeDoubleOffAddr#,
        writeStablePtrOffAddr#,
        writeInt8OffAddr#,
        writeInt16OffAddr#,
        writeInt32OffAddr#,
        writeInt64OffAddr#,
        writeWord8OffAddr#,
        writeWord16OffAddr#,
        writeWord32OffAddr#,
        writeWord64OffAddr#,
        
-- * Mutable variables
-- |Operations on MutVar\#s.


        MutVar#,
        newMutVar#,
        readMutVar#,
        writeMutVar#,
        sameMutVar#,
        atomicModifyMutVar#,
        casMutVar#,
        
-- * Exceptions
-- |


        catch#,
        raise#,
        raiseIO#,
        maskAsyncExceptions#,
        maskUninterruptible#,
        unmaskAsyncExceptions#,
        getMaskingState#,
        
-- * STM-accessible Mutable Variables
-- |


        TVar#,
        atomically#,
        retry#,
        catchRetry#,
        catchSTM#,
        check#,
        newTVar#,
        readTVar#,
        readTVarIO#,
        writeTVar#,
        sameTVar#,
        
-- * Synchronized Mutable Variables
-- |Operations on @MVar\#@s. 


        MVar#,
        newMVar#,
        takeMVar#,
        tryTakeMVar#,
        putMVar#,
        tryPutMVar#,
        readMVar#,
        tryReadMVar#,
        sameMVar#,
        isEmptyMVar#,
        
-- * Delay\/wait operations
-- |


        delay#,
        waitRead#,
        waitWrite#,
        
-- * Concurrency primitives
-- |


        State#,
        RealWorld,
        ThreadId#,
        fork#,
        forkOn#,
        killThread#,
        yield#,
        myThreadId#,
        labelThread#,
        isCurrentThreadBound#,
        noDuplicate#,
        threadStatus#,
        
-- * Weak pointers
-- |


        Weak#,
        mkWeak#,
        mkWeakNoFinalizer#,
        addCFinalizerToWeak#,
        deRefWeak#,
        finalizeWeak#,
        touch#,
        
-- * Stable pointers and names
-- |


        StablePtr#,
        StableName#,
        makeStablePtr#,
        deRefStablePtr#,
        eqStablePtr#,
        makeStableName#,
        eqStableName#,
        stableNameToInt#,
        
-- * Compact normal form
-- |


        Compact#,
        compactNew#,
        compactResize#,
        compactContains#,
        compactContainsAny#,
        compactGetFirstBlock#,
        compactGetNextBlock#,
        compactAllocateBlock#,
        compactFixupPointers#,
        compactAdd#,
        compactAddWithSharing#,
        compactSize#,
        
-- * Unsafe pointer equality
-- |


        reallyUnsafePtrEquality#,
        
-- * Parallelism
-- |


        par#,
        spark#,
        seq#,
        getSpark#,
        numSparks#,
        
-- * Tag to enum stuff
-- |Convert back and forth between values of enumerated types
--         and small integers.


        dataToTag#,
        tagToEnum#,
        
-- * Bytecode operations
-- |Support for manipulating bytecode objects used by the interpreter and
--         linker.
-- 
--         Bytecode objects are heap objects which represent top-level bindings and
--         contain a list of instructions and data needed by these instructions.


        BCO#,
        addrToAny#,
        anyToAddr#,
        mkApUpd0#,
        newBCO#,
        unpackClosure#,
        getApStackVal#,
        
-- * Misc
-- |These aren\'t nearly as wired in as Etc...


        getCCSOf#,
        getCurrentCCS#,
        clearCCS#,
        
-- * Etc
-- |Miscellaneous built-ins


        Proxy#,
        proxy#,
        seq,
        unsafeCoerce#,
        traceEvent#,
        traceMarker#,
        
-- * Safe coercions
-- |


        coerce,
        
-- * SIMD Vectors
-- |Operations on SIMD vectors.


        Int8X16#,
        Int16X8#,
        Int32X4#,
        Int64X2#,
        Int8X32#,
        Int16X16#,
        Int32X8#,
        Int64X4#,
        Int8X64#,
        Int16X32#,
        Int32X16#,
        Int64X8#,
        Word8X16#,
        Word16X8#,
        Word32X4#,
        Word64X2#,
        Word8X32#,
        Word16X16#,
        Word32X8#,
        Word64X4#,
        Word8X64#,
        Word16X32#,
        Word32X16#,
        Word64X8#,
        FloatX4#,
        DoubleX2#,
        FloatX8#,
        DoubleX4#,
        FloatX16#,
        DoubleX8#,
        broadcastInt8X16#,
        broadcastInt16X8#,
        broadcastInt32X4#,
        broadcastInt64X2#,
        broadcastInt8X32#,
        broadcastInt16X16#,
        broadcastInt32X8#,
        broadcastInt64X4#,
        broadcastInt8X64#,
        broadcastInt16X32#,
        broadcastInt32X16#,
        broadcastInt64X8#,
        broadcastWord8X16#,
        broadcastWord16X8#,
        broadcastWord32X4#,
        broadcastWord64X2#,
        broadcastWord8X32#,
        broadcastWord16X16#,
        broadcastWord32X8#,
        broadcastWord64X4#,
        broadcastWord8X64#,
        broadcastWord16X32#,
        broadcastWord32X16#,
        broadcastWord64X8#,
        broadcastFloatX4#,
        broadcastDoubleX2#,
        broadcastFloatX8#,
        broadcastDoubleX4#,
        broadcastFloatX16#,
        broadcastDoubleX8#,
        packInt8X16#,
        packInt16X8#,
        packInt32X4#,
        packInt64X2#,
        packInt8X32#,
        packInt16X16#,
        packInt32X8#,
        packInt64X4#,
        packInt8X64#,
        packInt16X32#,
        packInt32X16#,
        packInt64X8#,
        packWord8X16#,
        packWord16X8#,
        packWord32X4#,
        packWord64X2#,
        packWord8X32#,
        packWord16X16#,
        packWord32X8#,
        packWord64X4#,
        packWord8X64#,
        packWord16X32#,
        packWord32X16#,
        packWord64X8#,
        packFloatX4#,
        packDoubleX2#,
        packFloatX8#,
        packDoubleX4#,
        packFloatX16#,
        packDoubleX8#,
        unpackInt8X16#,
        unpackInt16X8#,
        unpackInt32X4#,
        unpackInt64X2#,
        unpackInt8X32#,
        unpackInt16X16#,
        unpackInt32X8#,
        unpackInt64X4#,
        unpackInt8X64#,
        unpackInt16X32#,
        unpackInt32X16#,
        unpackInt64X8#,
        unpackWord8X16#,
        unpackWord16X8#,
        unpackWord32X4#,
        unpackWord64X2#,
        unpackWord8X32#,
        unpackWord16X16#,
        unpackWord32X8#,
        unpackWord64X4#,
        unpackWord8X64#,
        unpackWord16X32#,
        unpackWord32X16#,
        unpackWord64X8#,
        unpackFloatX4#,
        unpackDoubleX2#,
        unpackFloatX8#,
        unpackDoubleX4#,
        unpackFloatX16#,
        unpackDoubleX8#,
        insertInt8X16#,
        insertInt16X8#,
        insertInt32X4#,
        insertInt64X2#,
        insertInt8X32#,
        insertInt16X16#,
        insertInt32X8#,
        insertInt64X4#,
        insertInt8X64#,
        insertInt16X32#,
        insertInt32X16#,
        insertInt64X8#,
        insertWord8X16#,
        insertWord16X8#,
        insertWord32X4#,
        insertWord64X2#,
        insertWord8X32#,
        insertWord16X16#,
        insertWord32X8#,
        insertWord64X4#,
        insertWord8X64#,
        insertWord16X32#,
        insertWord32X16#,
        insertWord64X8#,
        insertFloatX4#,
        insertDoubleX2#,
        insertFloatX8#,
        insertDoubleX4#,
        insertFloatX16#,
        insertDoubleX8#,
        plusInt8X16#,
        plusInt16X8#,
        plusInt32X4#,
        plusInt64X2#,
        plusInt8X32#,
        plusInt16X16#,
        plusInt32X8#,
        plusInt64X4#,
        plusInt8X64#,
        plusInt16X32#,
        plusInt32X16#,
        plusInt64X8#,
        plusWord8X16#,
        plusWord16X8#,
        plusWord32X4#,
        plusWord64X2#,
        plusWord8X32#,
        plusWord16X16#,
        plusWord32X8#,
        plusWord64X4#,
        plusWord8X64#,
        plusWord16X32#,
        plusWord32X16#,
        plusWord64X8#,
        plusFloatX4#,
        plusDoubleX2#,
        plusFloatX8#,
        plusDoubleX4#,
        plusFloatX16#,
        plusDoubleX8#,
        minusInt8X16#,
        minusInt16X8#,
        minusInt32X4#,
        minusInt64X2#,
        minusInt8X32#,
        minusInt16X16#,
        minusInt32X8#,
        minusInt64X4#,
        minusInt8X64#,
        minusInt16X32#,
        minusInt32X16#,
        minusInt64X8#,
        minusWord8X16#,
        minusWord16X8#,
        minusWord32X4#,
        minusWord64X2#,
        minusWord8X32#,
        minusWord16X16#,
        minusWord32X8#,
        minusWord64X4#,
        minusWord8X64#,
        minusWord16X32#,
        minusWord32X16#,
        minusWord64X8#,
        minusFloatX4#,
        minusDoubleX2#,
        minusFloatX8#,
        minusDoubleX4#,
        minusFloatX16#,
        minusDoubleX8#,
        timesInt8X16#,
        timesInt16X8#,
        timesInt32X4#,
        timesInt64X2#,
        timesInt8X32#,
        timesInt16X16#,
        timesInt32X8#,
        timesInt64X4#,
        timesInt8X64#,
        timesInt16X32#,
        timesInt32X16#,
        timesInt64X8#,
        timesWord8X16#,
        timesWord16X8#,
        timesWord32X4#,
        timesWord64X2#,
        timesWord8X32#,
        timesWord16X16#,
        timesWord32X8#,
        timesWord64X4#,
        timesWord8X64#,
        timesWord16X32#,
        timesWord32X16#,
        timesWord64X8#,
        timesFloatX4#,
        timesDoubleX2#,
        timesFloatX8#,
        timesDoubleX4#,
        timesFloatX16#,
        timesDoubleX8#,
        divideFloatX4#,
        divideDoubleX2#,
        divideFloatX8#,
        divideDoubleX4#,
        divideFloatX16#,
        divideDoubleX8#,
        quotInt8X16#,
        quotInt16X8#,
        quotInt32X4#,
        quotInt64X2#,
        quotInt8X32#,
        quotInt16X16#,
        quotInt32X8#,
        quotInt64X4#,
        quotInt8X64#,
        quotInt16X32#,
        quotInt32X16#,
        quotInt64X8#,
        quotWord8X16#,
        quotWord16X8#,
        quotWord32X4#,
        quotWord64X2#,
        quotWord8X32#,
        quotWord16X16#,
        quotWord32X8#,
        quotWord64X4#,
        quotWord8X64#,
        quotWord16X32#,
        quotWord32X16#,
        quotWord64X8#,
        remInt8X16#,
        remInt16X8#,
        remInt32X4#,
        remInt64X2#,
        remInt8X32#,
        remInt16X16#,
        remInt32X8#,
        remInt64X4#,
        remInt8X64#,
        remInt16X32#,
        remInt32X16#,
        remInt64X8#,
        remWord8X16#,
        remWord16X8#,
        remWord32X4#,
        remWord64X2#,
        remWord8X32#,
        remWord16X16#,
        remWord32X8#,
        remWord64X4#,
        remWord8X64#,
        remWord16X32#,
        remWord32X16#,
        remWord64X8#,
        negateInt8X16#,
        negateInt16X8#,
        negateInt32X4#,
        negateInt64X2#,
        negateInt8X32#,
        negateInt16X16#,
        negateInt32X8#,
        negateInt64X4#,
        negateInt8X64#,
        negateInt16X32#,
        negateInt32X16#,
        negateInt64X8#,
        negateFloatX4#,
        negateDoubleX2#,
        negateFloatX8#,
        negateDoubleX4#,
        negateFloatX16#,
        negateDoubleX8#,
        indexInt8X16Array#,
        indexInt16X8Array#,
        indexInt32X4Array#,
        indexInt64X2Array#,
        indexInt8X32Array#,
        indexInt16X16Array#,
        indexInt32X8Array#,
        indexInt64X4Array#,
        indexInt8X64Array#,
        indexInt16X32Array#,
        indexInt32X16Array#,
        indexInt64X8Array#,
        indexWord8X16Array#,
        indexWord16X8Array#,
        indexWord32X4Array#,
        indexWord64X2Array#,
        indexWord8X32Array#,
        indexWord16X16Array#,
        indexWord32X8Array#,
        indexWord64X4Array#,
        indexWord8X64Array#,
        indexWord16X32Array#,
        indexWord32X16Array#,
        indexWord64X8Array#,
        indexFloatX4Array#,
        indexDoubleX2Array#,
        indexFloatX8Array#,
        indexDoubleX4Array#,
        indexFloatX16Array#,
        indexDoubleX8Array#,
        readInt8X16Array#,
        readInt16X8Array#,
        readInt32X4Array#,
        readInt64X2Array#,
        readInt8X32Array#,
        readInt16X16Array#,
        readInt32X8Array#,
        readInt64X4Array#,
        readInt8X64Array#,
        readInt16X32Array#,
        readInt32X16Array#,
        readInt64X8Array#,
        readWord8X16Array#,
        readWord16X8Array#,
        readWord32X4Array#,
        readWord64X2Array#,
        readWord8X32Array#,
        readWord16X16Array#,
        readWord32X8Array#,
        readWord64X4Array#,
        readWord8X64Array#,
        readWord16X32Array#,
        readWord32X16Array#,
        readWord64X8Array#,
        readFloatX4Array#,
        readDoubleX2Array#,
        readFloatX8Array#,
        readDoubleX4Array#,
        readFloatX16Array#,
        readDoubleX8Array#,
        writeInt8X16Array#,
        writeInt16X8Array#,
        writeInt32X4Array#,
        writeInt64X2Array#,
        writeInt8X32Array#,
        writeInt16X16Array#,
        writeInt32X8Array#,
        writeInt64X4Array#,
        writeInt8X64Array#,
        writeInt16X32Array#,
        writeInt32X16Array#,
        writeInt64X8Array#,
        writeWord8X16Array#,
        writeWord16X8Array#,
        writeWord32X4Array#,
        writeWord64X2Array#,
        writeWord8X32Array#,
        writeWord16X16Array#,
        writeWord32X8Array#,
        writeWord64X4Array#,
        writeWord8X64Array#,
        writeWord16X32Array#,
        writeWord32X16Array#,
        writeWord64X8Array#,
        writeFloatX4Array#,
        writeDoubleX2Array#,
        writeFloatX8Array#,
        writeDoubleX4Array#,
        writeFloatX16Array#,
        writeDoubleX8Array#,
        indexInt8X16OffAddr#,
        indexInt16X8OffAddr#,
        indexInt32X4OffAddr#,
        indexInt64X2OffAddr#,
        indexInt8X32OffAddr#,
        indexInt16X16OffAddr#,
        indexInt32X8OffAddr#,
        indexInt64X4OffAddr#,
        indexInt8X64OffAddr#,
        indexInt16X32OffAddr#,
        indexInt32X16OffAddr#,
        indexInt64X8OffAddr#,
        indexWord8X16OffAddr#,
        indexWord16X8OffAddr#,
        indexWord32X4OffAddr#,
        indexWord64X2OffAddr#,
        indexWord8X32OffAddr#,
        indexWord16X16OffAddr#,
        indexWord32X8OffAddr#,
        indexWord64X4OffAddr#,
        indexWord8X64OffAddr#,
        indexWord16X32OffAddr#,
        indexWord32X16OffAddr#,
        indexWord64X8OffAddr#,
        indexFloatX4OffAddr#,
        indexDoubleX2OffAddr#,
        indexFloatX8OffAddr#,
        indexDoubleX4OffAddr#,
        indexFloatX16OffAddr#,
        indexDoubleX8OffAddr#,
        readInt8X16OffAddr#,
        readInt16X8OffAddr#,
        readInt32X4OffAddr#,
        readInt64X2OffAddr#,
        readInt8X32OffAddr#,
        readInt16X16OffAddr#,
        readInt32X8OffAddr#,
        readInt64X4OffAddr#,
        readInt8X64OffAddr#,
        readInt16X32OffAddr#,
        readInt32X16OffAddr#,
        readInt64X8OffAddr#,
        readWord8X16OffAddr#,
        readWord16X8OffAddr#,
        readWord32X4OffAddr#,
        readWord64X2OffAddr#,
        readWord8X32OffAddr#,
        readWord16X16OffAddr#,
        readWord32X8OffAddr#,
        readWord64X4OffAddr#,
        readWord8X64OffAddr#,
        readWord16X32OffAddr#,
        readWord32X16OffAddr#,
        readWord64X8OffAddr#,
        readFloatX4OffAddr#,
        readDoubleX2OffAddr#,
        readFloatX8OffAddr#,
        readDoubleX4OffAddr#,
        readFloatX16OffAddr#,
        readDoubleX8OffAddr#,
        writeInt8X16OffAddr#,
        writeInt16X8OffAddr#,
        writeInt32X4OffAddr#,
        writeInt64X2OffAddr#,
        writeInt8X32OffAddr#,
        writeInt16X16OffAddr#,
        writeInt32X8OffAddr#,
        writeInt64X4OffAddr#,
        writeInt8X64OffAddr#,
        writeInt16X32OffAddr#,
        writeInt32X16OffAddr#,
        writeInt64X8OffAddr#,
        writeWord8X16OffAddr#,
        writeWord16X8OffAddr#,
        writeWord32X4OffAddr#,
        writeWord64X2OffAddr#,
        writeWord8X32OffAddr#,
        writeWord16X16OffAddr#,
        writeWord32X8OffAddr#,
        writeWord64X4OffAddr#,
        writeWord8X64OffAddr#,
        writeWord16X32OffAddr#,
        writeWord32X16OffAddr#,
        writeWord64X8OffAddr#,
        writeFloatX4OffAddr#,
        writeDoubleX2OffAddr#,
        writeFloatX8OffAddr#,
        writeDoubleX4OffAddr#,
        writeFloatX16OffAddr#,
        writeDoubleX8OffAddr#,
        indexInt8ArrayAsInt8X16#,
        indexInt16ArrayAsInt16X8#,
        indexInt32ArrayAsInt32X4#,
        indexInt64ArrayAsInt64X2#,
        indexInt8ArrayAsInt8X32#,
        indexInt16ArrayAsInt16X16#,
        indexInt32ArrayAsInt32X8#,
        indexInt64ArrayAsInt64X4#,
        indexInt8ArrayAsInt8X64#,
        indexInt16ArrayAsInt16X32#,
        indexInt32ArrayAsInt32X16#,
        indexInt64ArrayAsInt64X8#,
        indexWord8ArrayAsWord8X16#,
        indexWord16ArrayAsWord16X8#,
        indexWord32ArrayAsWord32X4#,
        indexWord64ArrayAsWord64X2#,
        indexWord8ArrayAsWord8X32#,
        indexWord16ArrayAsWord16X16#,
        indexWord32ArrayAsWord32X8#,
        indexWord64ArrayAsWord64X4#,
        indexWord8ArrayAsWord8X64#,
        indexWord16ArrayAsWord16X32#,
        indexWord32ArrayAsWord32X16#,
        indexWord64ArrayAsWord64X8#,
        indexFloatArrayAsFloatX4#,
        indexDoubleArrayAsDoubleX2#,
        indexFloatArrayAsFloatX8#,
        indexDoubleArrayAsDoubleX4#,
        indexFloatArrayAsFloatX16#,
        indexDoubleArrayAsDoubleX8#,
        readInt8ArrayAsInt8X16#,
        readInt16ArrayAsInt16X8#,
        readInt32ArrayAsInt32X4#,
        readInt64ArrayAsInt64X2#,
        readInt8ArrayAsInt8X32#,
        readInt16ArrayAsInt16X16#,
        readInt32ArrayAsInt32X8#,
        readInt64ArrayAsInt64X4#,
        readInt8ArrayAsInt8X64#,
        readInt16ArrayAsInt16X32#,
        readInt32ArrayAsInt32X16#,
        readInt64ArrayAsInt64X8#,
        readWord8ArrayAsWord8X16#,
        readWord16ArrayAsWord16X8#,
        readWord32ArrayAsWord32X4#,
        readWord64ArrayAsWord64X2#,
        readWord8ArrayAsWord8X32#,
        readWord16ArrayAsWord16X16#,
        readWord32ArrayAsWord32X8#,
        readWord64ArrayAsWord64X4#,
        readWord8ArrayAsWord8X64#,
        readWord16ArrayAsWord16X32#,
        readWord32ArrayAsWord32X16#,
        readWord64ArrayAsWord64X8#,
        readFloatArrayAsFloatX4#,
        readDoubleArrayAsDoubleX2#,
        readFloatArrayAsFloatX8#,
        readDoubleArrayAsDoubleX4#,
        readFloatArrayAsFloatX16#,
        readDoubleArrayAsDoubleX8#,
        writeInt8ArrayAsInt8X16#,
        writeInt16ArrayAsInt16X8#,
        writeInt32ArrayAsInt32X4#,
        writeInt64ArrayAsInt64X2#,
        writeInt8ArrayAsInt8X32#,
        writeInt16ArrayAsInt16X16#,
        writeInt32ArrayAsInt32X8#,
        writeInt64ArrayAsInt64X4#,
        writeInt8ArrayAsInt8X64#,
        writeInt16ArrayAsInt16X32#,
        writeInt32ArrayAsInt32X16#,
        writeInt64ArrayAsInt64X8#,
        writeWord8ArrayAsWord8X16#,
        writeWord16ArrayAsWord16X8#,
        writeWord32ArrayAsWord32X4#,
        writeWord64ArrayAsWord64X2#,
        writeWord8ArrayAsWord8X32#,
        writeWord16ArrayAsWord16X16#,
        writeWord32ArrayAsWord32X8#,
        writeWord64ArrayAsWord64X4#,
        writeWord8ArrayAsWord8X64#,
        writeWord16ArrayAsWord16X32#,
        writeWord32ArrayAsWord32X16#,
        writeWord64ArrayAsWord64X8#,
        writeFloatArrayAsFloatX4#,
        writeDoubleArrayAsDoubleX2#,
        writeFloatArrayAsFloatX8#,
        writeDoubleArrayAsDoubleX4#,
        writeFloatArrayAsFloatX16#,
        writeDoubleArrayAsDoubleX8#,
        indexInt8OffAddrAsInt8X16#,
        indexInt16OffAddrAsInt16X8#,
        indexInt32OffAddrAsInt32X4#,
        indexInt64OffAddrAsInt64X2#,
        indexInt8OffAddrAsInt8X32#,
        indexInt16OffAddrAsInt16X16#,
        indexInt32OffAddrAsInt32X8#,
        indexInt64OffAddrAsInt64X4#,
        indexInt8OffAddrAsInt8X64#,
        indexInt16OffAddrAsInt16X32#,
        indexInt32OffAddrAsInt32X16#,
        indexInt64OffAddrAsInt64X8#,
        indexWord8OffAddrAsWord8X16#,
        indexWord16OffAddrAsWord16X8#,
        indexWord32OffAddrAsWord32X4#,
        indexWord64OffAddrAsWord64X2#,
        indexWord8OffAddrAsWord8X32#,
        indexWord16OffAddrAsWord16X16#,
        indexWord32OffAddrAsWord32X8#,
        indexWord64OffAddrAsWord64X4#,
        indexWord8OffAddrAsWord8X64#,
        indexWord16OffAddrAsWord16X32#,
        indexWord32OffAddrAsWord32X16#,
        indexWord64OffAddrAsWord64X8#,
        indexFloatOffAddrAsFloatX4#,
        indexDoubleOffAddrAsDoubleX2#,
        indexFloatOffAddrAsFloatX8#,
        indexDoubleOffAddrAsDoubleX4#,
        indexFloatOffAddrAsFloatX16#,
        indexDoubleOffAddrAsDoubleX8#,
        readInt8OffAddrAsInt8X16#,
        readInt16OffAddrAsInt16X8#,
        readInt32OffAddrAsInt32X4#,
        readInt64OffAddrAsInt64X2#,
        readInt8OffAddrAsInt8X32#,
        readInt16OffAddrAsInt16X16#,
        readInt32OffAddrAsInt32X8#,
        readInt64OffAddrAsInt64X4#,
        readInt8OffAddrAsInt8X64#,
        readInt16OffAddrAsInt16X32#,
        readInt32OffAddrAsInt32X16#,
        readInt64OffAddrAsInt64X8#,
        readWord8OffAddrAsWord8X16#,
        readWord16OffAddrAsWord16X8#,
        readWord32OffAddrAsWord32X4#,
        readWord64OffAddrAsWord64X2#,
        readWord8OffAddrAsWord8X32#,
        readWord16OffAddrAsWord16X16#,
        readWord32OffAddrAsWord32X8#,
        readWord64OffAddrAsWord64X4#,
        readWord8OffAddrAsWord8X64#,
        readWord16OffAddrAsWord16X32#,
        readWord32OffAddrAsWord32X16#,
        readWord64OffAddrAsWord64X8#,
        readFloatOffAddrAsFloatX4#,
        readDoubleOffAddrAsDoubleX2#,
        readFloatOffAddrAsFloatX8#,
        readDoubleOffAddrAsDoubleX4#,
        readFloatOffAddrAsFloatX16#,
        readDoubleOffAddrAsDoubleX8#,
        writeInt8OffAddrAsInt8X16#,
        writeInt16OffAddrAsInt16X8#,
        writeInt32OffAddrAsInt32X4#,
        writeInt64OffAddrAsInt64X2#,
        writeInt8OffAddrAsInt8X32#,
        writeInt16OffAddrAsInt16X16#,
        writeInt32OffAddrAsInt32X8#,
        writeInt64OffAddrAsInt64X4#,
        writeInt8OffAddrAsInt8X64#,
        writeInt16OffAddrAsInt16X32#,
        writeInt32OffAddrAsInt32X16#,
        writeInt64OffAddrAsInt64X8#,
        writeWord8OffAddrAsWord8X16#,
        writeWord16OffAddrAsWord16X8#,
        writeWord32OffAddrAsWord32X4#,
        writeWord64OffAddrAsWord64X2#,
        writeWord8OffAddrAsWord8X32#,
        writeWord16OffAddrAsWord16X16#,
        writeWord32OffAddrAsWord32X8#,
        writeWord64OffAddrAsWord64X4#,
        writeWord8OffAddrAsWord8X64#,
        writeWord16OffAddrAsWord16X32#,
        writeWord32OffAddrAsWord32X16#,
        writeWord64OffAddrAsWord64X8#,
        writeFloatOffAddrAsFloatX4#,
        writeDoubleOffAddrAsDoubleX2#,
        writeFloatOffAddrAsFloatX8#,
        writeDoubleOffAddrAsDoubleX4#,
        writeFloatOffAddrAsFloatX16#,
        writeDoubleOffAddrAsDoubleX8#,
        
-- * Prefetch
-- |Prefetch operations: Note how every prefetch operation has a name
--   with the pattern prefetch*N#, where N is either 0,1,2, or 3.
-- 
--   This suffix number, N, is the \"locality level\" of the prefetch, following the
--   convention in GCC and other compilers.
--   Higher locality numbers correspond to the memory being loaded in more
--   levels of the cpu cache, and being retained after initial use. The naming
--   convention follows the naming convention of the prefetch intrinsic found
--   in the GCC and Clang C compilers.
-- 
--   On the LLVM backend, prefetch*N# uses the LLVM prefetch intrinsic
--   with locality level N. The code generated by LLVM is target architecture
--   dependent, but should agree with the GHC NCG on x86 systems.
-- 
--   On the Sparc and PPC native backends, prefetch*N is a No-Op.
-- 
--   On the x86 NCG, N=0 will generate prefetchNTA,
--   N=1 generates prefetcht2, N=2 generates prefetcht1, and
--   N=3 generates prefetcht0.
-- 
--   For streaming workloads, the prefetch*0 operations are recommended.
--   For workloads which do many reads or writes to a memory location in a short period of time,
--   prefetch*3 operations are recommended.
-- 
--   For further reading about prefetch and associated systems performance optimization,
--   the instruction set and optimization manuals by Intel and other CPU vendors are
--   excellent starting place.
-- 
-- 
--   The \"Intel 64 and IA-32 Architectures Optimization Reference Manual\" is
--   especially a helpful read, even if your software is meant for other CPU
--   architectures or vendor hardware. The manual can be found at
--   http:\/\/www.intel.com\/content\/www\/us\/en\/architecture-and-technology\/64-ia-32-architectures-optimization-manual.html .
-- 
--   The @prefetch*@ family of operations has the order of operations
--   determined by passing around the @State#@ token.
-- 
--   To get a \"pure\" version of these operations, use @inlinePerformIO@ which is quite safe in this context.
-- 
--   It is important to note that while the prefetch operations will never change the
--   answer to a pure computation, They CAN change the memory locations resident
--   in a CPU cache and that may change the performance and timing characteristics
--   of an application. The prefetch operations are marked has_side_effects=True
--   to reflect that these operations have side effects with respect to the runtime
--   performance characteristics of the resulting code. Additionally, if the prefetchValue
--   operations did not have this attribute, GHC does a float out transformation that
--   results in a let\/app violation, at least with the current design.
--   


        prefetchByteArray3#,
        prefetchMutableByteArray3#,
        prefetchAddr3#,
        prefetchValue3#,
        prefetchByteArray2#,
        prefetchMutableByteArray2#,
        prefetchAddr2#,
        prefetchValue2#,
        prefetchByteArray1#,
        prefetchMutableByteArray1#,
        prefetchAddr1#,
        prefetchValue1#,
        prefetchByteArray0#,
        prefetchMutableByteArray0#,
        prefetchAddr0#,
        prefetchValue0#,
) where

{-
has_side_effects = False
out_of_line = False
can_fail = False
commutable = False
code_size = {  primOpCodeSizeDefault }
strictness = {  \ arity -> mkClosedStrictSig (replicate arity topDmd) topRes }
fixity = Nothing
llvm_only = False

-}
import GHC.Types (Coercible)
default ()
data Char#

gtChar# :: Char# -> Char# -> Int#
gtChar# = gtChar#

geChar# :: Char# -> Char# -> Int#
geChar# = geChar#

eqChar# :: Char# -> Char# -> Int#
eqChar# = eqChar#

neChar# :: Char# -> Char# -> Int#
neChar# = neChar#

ltChar# :: Char# -> Char# -> Int#
ltChar# = ltChar#

leChar# :: Char# -> Char# -> Int#
leChar# = leChar#

ord# :: Char# -> Int#
ord# = ord#

data Int#

infixl 6 +#
(+#) :: Int# -> Int# -> Int#
(+#) = (+#)

infixl 6 -#
(-#) :: Int# -> Int# -> Int#
(-#) = (-#)

-- |Low word of signed integer multiply.

infixl 7 *#
(*#) :: Int# -> Int# -> Int#
(*#) = (*#)

-- |Return non-zero if there is any possibility that the upper word of a
--     signed integer multiply might contain useful information.  Return
--     zero only if you are completely sure that no overflow can occur.
--     On a 32-bit platform, the recommmended implementation is to do a
--     32 x 32 -> 64 signed multiply, and subtract result[63:32] from
--     (result[31] >>signed 31).  If this is zero, meaning that the
--     upper word is merely a sign extension of the lower one, no
--     overflow can occur.
-- 
--     On a 64-bit platform it is not always possible to
--     acquire the top 64 bits of the result.  Therefore, a recommended
--     implementation is to take the absolute value of both operands, and
--     return 0 iff bits[63:31] of them are zero, since that means that their
--     magnitudes fit within 31 bits, so the magnitude of the product must fit
--     into 62 bits.
-- 
--     If in doubt, return non-zero, but do make an effort to create the
--     correct answer for small args, since otherwise the performance of
--     @(*) :: Integer -> Integer -> Integer@ will be poor.
--    

mulIntMayOflo# :: Int# -> Int# -> Int#
mulIntMayOflo# = mulIntMayOflo#

-- |Rounds towards zero. The behavior is undefined if the second argument is
--     zero.
--    

quotInt# :: Int# -> Int# -> Int#
quotInt# = quotInt#

-- |Satisfies @(quotInt\# x y) *\# y +\# (remInt\# x y) == x@. The
--     behavior is undefined if the second argument is zero.
--    

remInt# :: Int# -> Int# -> Int#
remInt# = remInt#

-- |Rounds towards zero.

quotRemInt# :: Int# -> Int# -> (# Int#,Int# #)
quotRemInt# = quotRemInt#

andI# :: Int# -> Int# -> Int#
andI# = andI#

orI# :: Int# -> Int# -> Int#
orI# = orI#

xorI# :: Int# -> Int# -> Int#
xorI# = xorI#

notI# :: Int# -> Int#
notI# = notI#

negateInt# :: Int# -> Int#
negateInt# = negateInt#

-- |Add signed integers reporting overflow.
--           First member of result is the sum truncated to an @Int#@;
--           second member is zero if the true sum fits in an @Int#@,
--           nonzero if overflow occurred (the sum is either too large
--           or too small to fit in an @Int#@).

addIntC# :: Int# -> Int# -> (# Int#,Int# #)
addIntC# = addIntC#

-- |Subtract signed integers reporting overflow.
--           First member of result is the difference truncated to an @Int#@;
--           second member is zero if the true difference fits in an @Int#@,
--           nonzero if overflow occurred (the difference is either too large
--           or too small to fit in an @Int#@).

subIntC# :: Int# -> Int# -> (# Int#,Int# #)
subIntC# = subIntC#

infix 4 >#
(>#) :: Int# -> Int# -> Int#
(>#) = (>#)

infix 4 >=#
(>=#) :: Int# -> Int# -> Int#
(>=#) = (>=#)

infix 4 ==#
(==#) :: Int# -> Int# -> Int#
(==#) = (==#)

infix 4 /=#
(/=#) :: Int# -> Int# -> Int#
(/=#) = (/=#)

infix 4 <#
(<#) :: Int# -> Int# -> Int#
(<#) = (<#)

infix 4 <=#
(<=#) :: Int# -> Int# -> Int#
(<=#) = (<=#)

chr# :: Int# -> Char#
chr# = chr#

int2Word# :: Int# -> Word#
int2Word# = int2Word#

int2Float# :: Int# -> Float#
int2Float# = int2Float#

int2Double# :: Int# -> Double#
int2Double# = int2Double#

word2Float# :: Word# -> Float#
word2Float# = word2Float#

word2Double# :: Word# -> Double#
word2Double# = word2Double#

-- |Shift left.  Result undefined if shift amount is not
--           in the range 0 to word size - 1 inclusive.

uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftL# = uncheckedIShiftL#

-- |Shift right arithmetic.  Result undefined if shift amount is not
--           in the range 0 to word size - 1 inclusive.

uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRA# = uncheckedIShiftRA#

-- |Shift right logical.  Result undefined if shift amount is not
--           in the range 0 to word size - 1 inclusive.

uncheckedIShiftRL# :: Int# -> Int# -> Int#
uncheckedIShiftRL# = uncheckedIShiftRL#

data Word#

plusWord# :: Word# -> Word# -> Word#
plusWord# = plusWord#

-- |Subtract unsigned integers reporting overflow.
--           The first element of the pair is the result.  The second element is
--           the carry flag, which is nonzero on overflow.

subWordC# :: Word# -> Word# -> (# Word#,Int# #)
subWordC# = subWordC#

plusWord2# :: Word# -> Word# -> (# Word#,Word# #)
plusWord2# = plusWord2#

minusWord# :: Word# -> Word# -> Word#
minusWord# = minusWord#

timesWord# :: Word# -> Word# -> Word#
timesWord# = timesWord#

timesWord2# :: Word# -> Word# -> (# Word#,Word# #)
timesWord2# = timesWord2#

quotWord# :: Word# -> Word# -> Word#
quotWord# = quotWord#

remWord# :: Word# -> Word# -> Word#
remWord# = remWord#

quotRemWord# :: Word# -> Word# -> (# Word#,Word# #)
quotRemWord# = quotRemWord#

quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#,Word# #)
quotRemWord2# = quotRemWord2#

and# :: Word# -> Word# -> Word#
and# = and#

or# :: Word# -> Word# -> Word#
or# = or#

xor# :: Word# -> Word# -> Word#
xor# = xor#

not# :: Word# -> Word#
not# = not#

-- |Shift left logical.   Result undefined if shift amount is not
--           in the range 0 to word size - 1 inclusive.

uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftL# = uncheckedShiftL#

-- |Shift right logical.   Result undefined if shift  amount is not
--           in the range 0 to word size - 1 inclusive.

uncheckedShiftRL# :: Word# -> Int# -> Word#
uncheckedShiftRL# = uncheckedShiftRL#

word2Int# :: Word# -> Int#
word2Int# = word2Int#

gtWord# :: Word# -> Word# -> Int#
gtWord# = gtWord#

geWord# :: Word# -> Word# -> Int#
geWord# = geWord#

eqWord# :: Word# -> Word# -> Int#
eqWord# = eqWord#

neWord# :: Word# -> Word# -> Int#
neWord# = neWord#

ltWord# :: Word# -> Word# -> Int#
ltWord# = ltWord#

leWord# :: Word# -> Word# -> Int#
leWord# = leWord#

-- |Count the number of set bits in the lower 8 bits of a word.

popCnt8# :: Word# -> Word#
popCnt8# = popCnt8#

-- |Count the number of set bits in the lower 16 bits of a word.

popCnt16# :: Word# -> Word#
popCnt16# = popCnt16#

-- |Count the number of set bits in the lower 32 bits of a word.

popCnt32# :: Word# -> Word#
popCnt32# = popCnt32#

-- |Count the number of set bits in a 64-bit word.

popCnt64# :: Word# -> Word#
popCnt64# = popCnt64#

-- |Count the number of set bits in a word.

popCnt# :: Word# -> Word#
popCnt# = popCnt#

-- |Count leading zeros in the lower 8 bits of a word.

clz8# :: Word# -> Word#
clz8# = clz8#

-- |Count leading zeros in the lower 16 bits of a word.

clz16# :: Word# -> Word#
clz16# = clz16#

-- |Count leading zeros in the lower 32 bits of a word.

clz32# :: Word# -> Word#
clz32# = clz32#

-- |Count leading zeros in a 64-bit word.

clz64# :: Word# -> Word#
clz64# = clz64#

-- |Count leading zeros in a word.

clz# :: Word# -> Word#
clz# = clz#

-- |Count trailing zeros in the lower 8 bits of a word.

ctz8# :: Word# -> Word#
ctz8# = ctz8#

-- |Count trailing zeros in the lower 16 bits of a word.

ctz16# :: Word# -> Word#
ctz16# = ctz16#

-- |Count trailing zeros in the lower 32 bits of a word.

ctz32# :: Word# -> Word#
ctz32# = ctz32#

-- |Count trailing zeros in a 64-bit word.

ctz64# :: Word# -> Word#
ctz64# = ctz64#

-- |Count trailing zeros in a word.

ctz# :: Word# -> Word#
ctz# = ctz#

-- |Swap bytes in the lower 16 bits of a word. The higher bytes are undefined. 

byteSwap16# :: Word# -> Word#
byteSwap16# = byteSwap16#

-- |Swap bytes in the lower 32 bits of a word. The higher bytes are undefined. 

byteSwap32# :: Word# -> Word#
byteSwap32# = byteSwap32#

-- |Swap bytes in a 64 bits of a word.

byteSwap64# :: Word# -> Word#
byteSwap64# = byteSwap64#

-- |Swap bytes in a word.

byteSwap# :: Word# -> Word#
byteSwap# = byteSwap#

narrow8Int# :: Int# -> Int#
narrow8Int# = narrow8Int#

narrow16Int# :: Int# -> Int#
narrow16Int# = narrow16Int#

narrow32Int# :: Int# -> Int#
narrow32Int# = narrow32Int#

narrow8Word# :: Word# -> Word#
narrow8Word# = narrow8Word#

narrow16Word# :: Word# -> Word#
narrow16Word# = narrow16Word#

narrow32Word# :: Word# -> Word#
narrow32Word# = narrow32Word#

data Double#

infix 4 >##
(>##) :: Double# -> Double# -> Int#
(>##) = (>##)

infix 4 >=##
(>=##) :: Double# -> Double# -> Int#
(>=##) = (>=##)

infix 4 ==##
(==##) :: Double# -> Double# -> Int#
(==##) = (==##)

infix 4 /=##
(/=##) :: Double# -> Double# -> Int#
(/=##) = (/=##)

infix 4 <##
(<##) :: Double# -> Double# -> Int#
(<##) = (<##)

infix 4 <=##
(<=##) :: Double# -> Double# -> Int#
(<=##) = (<=##)

infixl 6 +##
(+##) :: Double# -> Double# -> Double#
(+##) = (+##)

infixl 6 -##
(-##) :: Double# -> Double# -> Double#
(-##) = (-##)

infixl 7 *##
(*##) :: Double# -> Double# -> Double#
(*##) = (*##)

infixl 7 /##
(/##) :: Double# -> Double# -> Double#
(/##) = (/##)

negateDouble# :: Double# -> Double#
negateDouble# = negateDouble#

fabsDouble# :: Double# -> Double#
fabsDouble# = fabsDouble#

-- |Truncates a @Double#@ value to the nearest @Int#@.
--     Results are undefined if the truncation if truncation yields
--     a value outside the range of @Int#@.

double2Int# :: Double# -> Int#
double2Int# = double2Int#

double2Float# :: Double# -> Float#
double2Float# = double2Float#

expDouble# :: Double# -> Double#
expDouble# = expDouble#

logDouble# :: Double# -> Double#
logDouble# = logDouble#

sqrtDouble# :: Double# -> Double#
sqrtDouble# = sqrtDouble#

sinDouble# :: Double# -> Double#
sinDouble# = sinDouble#

cosDouble# :: Double# -> Double#
cosDouble# = cosDouble#

tanDouble# :: Double# -> Double#
tanDouble# = tanDouble#

asinDouble# :: Double# -> Double#
asinDouble# = asinDouble#

acosDouble# :: Double# -> Double#
acosDouble# = acosDouble#

atanDouble# :: Double# -> Double#
atanDouble# = atanDouble#

sinhDouble# :: Double# -> Double#
sinhDouble# = sinhDouble#

coshDouble# :: Double# -> Double#
coshDouble# = coshDouble#

tanhDouble# :: Double# -> Double#
tanhDouble# = tanhDouble#

-- |Exponentiation.

(**##) :: Double# -> Double# -> Double#
(**##) = (**##)

-- |Convert to integer.
--     First component of the result is -1 or 1, indicating the sign of the
--     mantissa. The next two are the high and low 32 bits of the mantissa
--     respectively, and the last is the exponent.

decodeDouble_2Int# :: Double# -> (# Int#,Word#,Word#,Int# #)
decodeDouble_2Int# = decodeDouble_2Int#

-- |Decode @Double\#@ into mantissa and base-2 exponent.

decodeDouble_Int64# :: Double# -> (# Int#,Int# #)
decodeDouble_Int64# = decodeDouble_Int64#

data Float#

gtFloat# :: Float# -> Float# -> Int#
gtFloat# = gtFloat#

geFloat# :: Float# -> Float# -> Int#
geFloat# = geFloat#

eqFloat# :: Float# -> Float# -> Int#
eqFloat# = eqFloat#

neFloat# :: Float# -> Float# -> Int#
neFloat# = neFloat#

ltFloat# :: Float# -> Float# -> Int#
ltFloat# = ltFloat#

leFloat# :: Float# -> Float# -> Int#
leFloat# = leFloat#

plusFloat# :: Float# -> Float# -> Float#
plusFloat# = plusFloat#

minusFloat# :: Float# -> Float# -> Float#
minusFloat# = minusFloat#

timesFloat# :: Float# -> Float# -> Float#
timesFloat# = timesFloat#

divideFloat# :: Float# -> Float# -> Float#
divideFloat# = divideFloat#

negateFloat# :: Float# -> Float#
negateFloat# = negateFloat#

fabsFloat# :: Float# -> Float#
fabsFloat# = fabsFloat#

-- |Truncates a @Float#@ value to the nearest @Int#@.
--     Results are undefined if the truncation if truncation yields
--     a value outside the range of @Int#@.

float2Int# :: Float# -> Int#
float2Int# = float2Int#

expFloat# :: Float# -> Float#
expFloat# = expFloat#

logFloat# :: Float# -> Float#
logFloat# = logFloat#

sqrtFloat# :: Float# -> Float#
sqrtFloat# = sqrtFloat#

sinFloat# :: Float# -> Float#
sinFloat# = sinFloat#

cosFloat# :: Float# -> Float#
cosFloat# = cosFloat#

tanFloat# :: Float# -> Float#
tanFloat# = tanFloat#

asinFloat# :: Float# -> Float#
asinFloat# = asinFloat#

acosFloat# :: Float# -> Float#
acosFloat# = acosFloat#

atanFloat# :: Float# -> Float#
atanFloat# = atanFloat#

sinhFloat# :: Float# -> Float#
sinhFloat# = sinhFloat#

coshFloat# :: Float# -> Float#
coshFloat# = coshFloat#

tanhFloat# :: Float# -> Float#
tanhFloat# = tanhFloat#

powerFloat# :: Float# -> Float# -> Float#
powerFloat# = powerFloat#

float2Double# :: Float# -> Double#
float2Double# = float2Double#

-- |Convert to integers.
--     First @Int\#@ in result is the mantissa; second is the exponent.

decodeFloat_Int# :: Float# -> (# Int#,Int# #)
decodeFloat_Int# = decodeFloat_Int#

data Array# a

data MutableArray# s a

-- |Create a new mutable array with the specified number of elements,
--     in the specified state thread,
--     with each element containing the specified initial value.

newArray# :: Int# -> a -> State# s -> (# State# s,MutableArray# s a #)
newArray# = newArray#

sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#
sameMutableArray# = sameMutableArray#

-- |Read from specified index of mutable array. Result is not yet evaluated.

readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s,a #)
readArray# = readArray#

-- |Write to specified index of mutable array.

writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s
writeArray# = writeArray#

-- |Return the number of elements in the array.

sizeofArray# :: Array# a -> Int#
sizeofArray# = sizeofArray#

-- |Return the number of elements in the array.

sizeofMutableArray# :: MutableArray# s a -> Int#
sizeofMutableArray# = sizeofMutableArray#

-- |Read from specified index of immutable array. Result is packaged into
--     an unboxed singleton; the result itself is not yet evaluated.

indexArray# :: Array# a -> Int# -> (# a #)
indexArray# = indexArray#

-- |Make a mutable array immutable, without copying.

unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s,Array# a #)
unsafeFreezeArray# = unsafeFreezeArray#

-- |Make an immutable array mutable, without copying.

unsafeThawArray# :: Array# a -> State# s -> (# State# s,MutableArray# s a #)
unsafeThawArray# = unsafeThawArray#

-- |Given a source array, an offset into the source array, a
--    destination array, an offset into the destination array, and a
--    number of elements to copy, copy the elements from the source array
--    to the destination array. Both arrays must fully contain the
--    specified ranges, but this is not checked. The two arrays must not
--    be the same array in different states, but this is not checked
--    either.

copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
copyArray# = copyArray#

-- |Given a source array, an offset into the source array, a
--    destination array, an offset into the destination array, and a
--    number of elements to copy, copy the elements from the source array
--    to the destination array. The source and destination arrays can
--    refer to the same array. Both arrays must fully contain the
--    specified ranges, but this is not checked.

copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
copyMutableArray# = copyMutableArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

cloneArray# :: Array# a -> Int# -> Int# -> Array# a
cloneArray# = cloneArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,MutableArray# s a #)
cloneMutableArray# = cloneMutableArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,Array# a #)
freezeArray# = freezeArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s,MutableArray# s a #)
thawArray# = thawArray#

-- |Unsafe, machine-level atomic compare and swap on an element within an Array.

casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s,Int#,a #)
casArray# = casArray#

data SmallArray# a

data SmallMutableArray# s a

-- |Create a new mutable array with the specified number of elements,
--     in the specified state thread,
--     with each element containing the specified initial value.

newSmallArray# :: Int# -> a -> State# s -> (# State# s,SmallMutableArray# s a #)
newSmallArray# = newSmallArray#

sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
sameSmallMutableArray# = sameSmallMutableArray#

-- |Read from specified index of mutable array. Result is not yet evaluated.

readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s,a #)
readSmallArray# = readSmallArray#

-- |Write to specified index of mutable array.

writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s
writeSmallArray# = writeSmallArray#

-- |Return the number of elements in the array.

sizeofSmallArray# :: SmallArray# a -> Int#
sizeofSmallArray# = sizeofSmallArray#

-- |Return the number of elements in the array.

sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#
sizeofSmallMutableArray# = sizeofSmallMutableArray#

-- |Read from specified index of immutable array. Result is packaged into
--     an unboxed singleton; the result itself is not yet evaluated.

indexSmallArray# :: SmallArray# a -> Int# -> (# a #)
indexSmallArray# = indexSmallArray#

-- |Make a mutable array immutable, without copying.

unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s,SmallArray# a #)
unsafeFreezeSmallArray# = unsafeFreezeSmallArray#

-- |Make an immutable array mutable, without copying.

unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s,SmallMutableArray# s a #)
unsafeThawSmallArray# = unsafeThawSmallArray#

-- |Given a source array, an offset into the source array, a
--    destination array, an offset into the destination array, and a
--    number of elements to copy, copy the elements from the source array
--    to the destination array. Both arrays must fully contain the
--    specified ranges, but this is not checked. The two arrays must not
--    be the same array in different states, but this is not checked
--    either.

copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
copySmallArray# = copySmallArray#

-- |Given a source array, an offset into the source array, a
--    destination array, an offset into the destination array, and a
--    number of elements to copy, copy the elements from the source array
--    to the destination array. The source and destination arrays can
--    refer to the same array. Both arrays must fully contain the
--    specified ranges, but this is not checked.

copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
copySmallMutableArray# = copySmallMutableArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a
cloneSmallArray# = cloneSmallArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,SmallMutableArray# s a #)
cloneSmallMutableArray# = cloneSmallMutableArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,SmallArray# a #)
freezeSmallArray# = freezeSmallArray#

-- |Given a source array, an offset into the source array, and a number
--    of elements to copy, create a new array with the elements from the
--    source array. The provided array must fully contain the specified
--    range, but this is not checked.

thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s,SmallMutableArray# s a #)
thawSmallArray# = thawSmallArray#

-- |Unsafe, machine-level atomic compare and swap on an element within an array.

casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s,Int#,a #)
casSmallArray# = casSmallArray#

data ByteArray#

data MutableByteArray# s

-- |Create a new mutable byte array of specified size (in bytes), in
--     the specified state thread.

newByteArray# :: Int# -> State# s -> (# State# s,MutableByteArray# s #)
newByteArray# = newByteArray#

-- |Create a mutable byte array that the GC guarantees not to move.

newPinnedByteArray# :: Int# -> State# s -> (# State# s,MutableByteArray# s #)
newPinnedByteArray# = newPinnedByteArray#

-- |Create a mutable byte array, aligned by the specified amount, that the GC guarantees not to move.

newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s,MutableByteArray# s #)
newAlignedPinnedByteArray# = newAlignedPinnedByteArray#

-- |Determine whether a @MutableByteArray\#@ is guaranteed not to move
--    during GC.

isMutableByteArrayPinned# :: MutableByteArray# s -> Int#
isMutableByteArrayPinned# = isMutableByteArrayPinned#

-- |Determine whether a @ByteArray\#@ is guaranteed not to move during GC.

isByteArrayPinned# :: ByteArray# -> Int#
isByteArrayPinned# = isByteArrayPinned#

-- |Intended for use with pinned arrays; otherwise very unsafe!

byteArrayContents# :: ByteArray# -> Addr#
byteArrayContents# = byteArrayContents#

sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#
sameMutableByteArray# = sameMutableByteArray#

-- |Shrink mutable byte array to new specified size (in bytes), in
--     the specified state thread. The new size argument must be less than or
--     equal to the current size as reported by @sizeofMutableArray\#@.

shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s
shrinkMutableByteArray# = shrinkMutableByteArray#

-- |Resize (unpinned) mutable byte array to new specified size (in bytes).
--     The returned @MutableByteArray\#@ is either the original
--     @MutableByteArray\#@ resized in-place or, if not possible, a newly
--     allocated (unpinned) @MutableByteArray\#@ (with the original content
--     copied over).
-- 
--     To avoid undefined behaviour, the original @MutableByteArray\#@ shall
--     not be accessed anymore after a @resizeMutableByteArray\#@ has been
--     performed.  Moreover, no reference to the old one should be kept in order
--     to allow garbage collection of the original @MutableByteArray\#@ in
--     case a new @MutableByteArray\#@ had to be allocated.

resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,MutableByteArray# s #)
resizeMutableByteArray# = resizeMutableByteArray#

-- |Make a mutable byte array immutable, without copying.

unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s,ByteArray# #)
unsafeFreezeByteArray# = unsafeFreezeByteArray#

-- |Return the size of the array in bytes.

sizeofByteArray# :: ByteArray# -> Int#
sizeofByteArray# = sizeofByteArray#

-- |Return the size of the array in bytes. Note that this is deprecated as it is
--    unsafe in the presence of concurrent resize operations on the same byte
--    array. See @getSizeofMutableByteArray@.

sizeofMutableByteArray# :: MutableByteArray# s -> Int#
sizeofMutableByteArray# = sizeofMutableByteArray#

-- |Return the number of elements in the array.

getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s,Int# #)
getSizeofMutableByteArray# = getSizeofMutableByteArray#

-- |Read 8-bit character; offset in bytes.

indexCharArray# :: ByteArray# -> Int# -> Char#
indexCharArray# = indexCharArray#

-- |Read 31-bit character; offset in 4-byte words.

indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# = indexWideCharArray#

indexIntArray# :: ByteArray# -> Int# -> Int#
indexIntArray# = indexIntArray#

indexWordArray# :: ByteArray# -> Int# -> Word#
indexWordArray# = indexWordArray#

indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexAddrArray# = indexAddrArray#

indexFloatArray# :: ByteArray# -> Int# -> Float#
indexFloatArray# = indexFloatArray#

indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexDoubleArray# = indexDoubleArray#

indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexStablePtrArray# = indexStablePtrArray#

-- |Read 8-bit integer; offset in bytes.

indexInt8Array# :: ByteArray# -> Int# -> Int#
indexInt8Array# = indexInt8Array#

-- |Read 16-bit integer; offset in 16-bit words.

indexInt16Array# :: ByteArray# -> Int# -> Int#
indexInt16Array# = indexInt16Array#

-- |Read 32-bit integer; offset in 32-bit words.

indexInt32Array# :: ByteArray# -> Int# -> Int#
indexInt32Array# = indexInt32Array#

-- |Read 64-bit integer; offset in 64-bit words.

indexInt64Array# :: ByteArray# -> Int# -> Int#
indexInt64Array# = indexInt64Array#

-- |Read 8-bit word; offset in bytes.

indexWord8Array# :: ByteArray# -> Int# -> Word#
indexWord8Array# = indexWord8Array#

-- |Read 16-bit word; offset in 16-bit words.

indexWord16Array# :: ByteArray# -> Int# -> Word#
indexWord16Array# = indexWord16Array#

-- |Read 32-bit word; offset in 32-bit words.

indexWord32Array# :: ByteArray# -> Int# -> Word#
indexWord32Array# = indexWord32Array#

-- |Read 64-bit word; offset in 64-bit words.

indexWord64Array# :: ByteArray# -> Int# -> Word#
indexWord64Array# = indexWord64Array#

-- |Read 8-bit character; offset in bytes.

readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Char# #)
readCharArray# = readCharArray#

-- |Read 31-bit character; offset in 4-byte words.

readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Char# #)
readWideCharArray# = readWideCharArray#

-- |Read intger; offset in words.

readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
readIntArray# = readIntArray#

-- |Read word; offset in words.

readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
readWordArray# = readWordArray#

readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Addr# #)
readAddrArray# = readAddrArray#

readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Float# #)
readFloatArray# = readFloatArray#

readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Double# #)
readDoubleArray# = readDoubleArray#

readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,StablePtr# a #)
readStablePtrArray# = readStablePtrArray#

readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
readInt8Array# = readInt8Array#

readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
readInt16Array# = readInt16Array#

readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
readInt32Array# = readInt32Array#

readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
readInt64Array# = readInt64Array#

readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
readWord8Array# = readWord8Array#

readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
readWord16Array# = readWord16Array#

readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
readWord32Array# = readWord32Array#

readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
readWord64Array# = readWord64Array#

-- |Write 8-bit character; offset in bytes.

writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeCharArray# = writeCharArray#

-- |Write 31-bit character; offset in 4-byte words.

writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWideCharArray# = writeWideCharArray#

writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeIntArray# = writeIntArray#

writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWordArray# = writeWordArray#

writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeAddrArray# = writeAddrArray#

writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeFloatArray# = writeFloatArray#

writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeDoubleArray# = writeDoubleArray#

writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeStablePtrArray# = writeStablePtrArray#

writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt8Array# = writeInt8Array#

writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# = writeInt16Array#

writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# = writeInt32Array#

writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# = writeInt64Array#

writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8Array# = writeWord8Array#

writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# = writeWord16Array#

writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# = writeWord32Array#

writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# = writeWord64Array#

-- |Copy a range of the ByteArray# to the specified region in the MutableByteArray#.
--    Both arrays must fully contain the specified ranges, but this is not checked.
--    The two arrays must not be the same array in different states, but this is not checked either.

copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyByteArray# = copyByteArray#

-- |Copy a range of the first MutableByteArray# to the specified region in the second MutableByteArray#.
--    Both arrays must fully contain the specified ranges, but this is not checked.

copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArray# = copyMutableByteArray#

-- |Copy a range of the ByteArray# to the memory range starting at the Addr#.
--    The ByteArray# and the memory region at Addr# must fully contain the
--    specified ranges, but this is not checked. The Addr# must not point into the
--    ByteArray# (e.g. if the ByteArray# were pinned), but this is not checked
--    either.

copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s
copyByteArrayToAddr# = copyByteArrayToAddr#

-- |Copy a range of the MutableByteArray# to the memory range starting at the
--    Addr#. The MutableByteArray# and the memory region at Addr# must fully
--    contain the specified ranges, but this is not checked. The Addr# must not
--    point into the MutableByteArray# (e.g. if the MutableByteArray# were
--    pinned), but this is not checked either.

copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s
copyMutableByteArrayToAddr# = copyMutableByteArrayToAddr#

-- |Copy a memory range starting at the Addr# to the specified range in the
--    MutableByteArray#. The memory region at Addr# and the ByteArray# must fully
--    contain the specified ranges, but this is not checked. The Addr# must not
--    point into the MutableByteArray# (e.g. if the MutableByteArray# were pinned),
--    but this is not checked either.

copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyAddrToByteArray# = copyAddrToByteArray#

-- |@setByteArray# ba off len c@ sets the byte range @[off, off+len]@ of
--    the @MutableByteArray#@ to the byte @c@.

setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s
setByteArray# = setByteArray#

-- |Given an array and an offset in Int units, read an element. The
--     index is assumed to be in bounds. Implies a full memory barrier.

atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
atomicReadIntArray# = atomicReadIntArray#

-- |Given an array and an offset in Int units, write an element. The
--     index is assumed to be in bounds. Implies a full memory barrier.

atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
atomicWriteIntArray# = atomicWriteIntArray#

-- |Given an array, an offset in Int units, the expected old value, and
--     the new value, perform an atomic compare and swap i.e. write the new
--     value if the current value matches the provided old value. Returns
--     the value of the element before the operation. Implies a full memory
--     barrier.

casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s,Int# #)
casIntArray# = casIntArray#

-- |Given an array, and offset in Int units, and a value to add,
--     atomically add the value to the element. Returns the value of the
--     element before the operation. Implies a full memory barrier.

fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
fetchAddIntArray# = fetchAddIntArray#

-- |Given an array, and offset in Int units, and a value to subtract,
--     atomically substract the value to the element. Returns the value of
--     the element before the operation. Implies a full memory barrier.

fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
fetchSubIntArray# = fetchSubIntArray#

-- |Given an array, and offset in Int units, and a value to AND,
--     atomically AND the value to the element. Returns the value of the
--     element before the operation. Implies a full memory barrier.

fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
fetchAndIntArray# = fetchAndIntArray#

-- |Given an array, and offset in Int units, and a value to NAND,
--     atomically NAND the value to the element. Returns the value of the
--     element before the operation. Implies a full memory barrier.

fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
fetchNandIntArray# = fetchNandIntArray#

-- |Given an array, and offset in Int units, and a value to OR,
--     atomically OR the value to the element. Returns the value of the
--     element before the operation. Implies a full memory barrier.

fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
fetchOrIntArray# = fetchOrIntArray#

-- |Given an array, and offset in Int units, and a value to XOR,
--     atomically XOR the value to the element. Returns the value of the
--     element before the operation. Implies a full memory barrier.

fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
fetchXorIntArray# = fetchXorIntArray#

data ArrayArray#

data MutableArrayArray# s

-- |Create a new mutable array of arrays with the specified number of elements,
--     in the specified state thread, with each element recursively referring to the
--     newly created array.

newArrayArray# :: Int# -> State# s -> (# State# s,MutableArrayArray# s #)
newArrayArray# = newArrayArray#

sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#
sameMutableArrayArray# = sameMutableArrayArray#

-- |Make a mutable array of arrays immutable, without copying.

unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s,ArrayArray# #)
unsafeFreezeArrayArray# = unsafeFreezeArrayArray#

-- |Return the number of elements in the array.

sizeofArrayArray# :: ArrayArray# -> Int#
sizeofArrayArray# = sizeofArrayArray#

-- |Return the number of elements in the array.

sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
sizeofMutableArrayArray# = sizeofMutableArrayArray#

indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexByteArrayArray# = indexByteArrayArray#

indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
indexArrayArrayArray# = indexArrayArrayArray#

readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,ByteArray# #)
readByteArrayArray# = readByteArrayArray#

readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,MutableByteArray# s #)
readMutableByteArrayArray# = readMutableByteArrayArray#

readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,ArrayArray# #)
readArrayArrayArray# = readArrayArrayArray#

readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,MutableArrayArray# s #)
readMutableArrayArrayArray# = readMutableArrayArrayArray#

writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeByteArrayArray# = writeByteArrayArray#

writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeMutableByteArrayArray# = writeMutableByteArrayArray#

writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeArrayArrayArray# = writeArrayArrayArray#

writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
writeMutableArrayArrayArray# = writeMutableArrayArrayArray#

-- |Copy a range of the ArrayArray# to the specified region in the MutableArrayArray#.
--    Both arrays must fully contain the specified ranges, but this is not checked.
--    The two arrays must not be the same array in different states, but this is not checked either.

copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
copyArrayArray# = copyArrayArray#

-- |Copy a range of the first MutableArrayArray# to the specified region in the second
--    MutableArrayArray#.
--    Both arrays must fully contain the specified ranges, but this is not checked.

copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableArrayArray# = copyMutableArrayArray#

-- | An arbitrary machine address assumed to point outside
--          the garbage-collected heap. 

data Addr#

-- | The null address. 

nullAddr# :: Addr#
nullAddr# = nullAddr#

plusAddr# :: Addr# -> Int# -> Addr#
plusAddr# = plusAddr#

-- |Result is meaningless if two @Addr\#@s are so far apart that their
--          difference doesn\'t fit in an @Int\#@.

minusAddr# :: Addr# -> Addr# -> Int#
minusAddr# = minusAddr#

-- |Return the remainder when the @Addr\#@ arg, treated like an @Int\#@,
--           is divided by the @Int\#@ arg.

remAddr# :: Addr# -> Int# -> Int#
remAddr# = remAddr#

-- |Coerce directly from address to int. Strongly deprecated.

addr2Int# :: Addr# -> Int#
addr2Int# = addr2Int#

-- |Coerce directly from int to address. Strongly deprecated.

int2Addr# :: Int# -> Addr#
int2Addr# = int2Addr#

gtAddr# :: Addr# -> Addr# -> Int#
gtAddr# = gtAddr#

geAddr# :: Addr# -> Addr# -> Int#
geAddr# = geAddr#

eqAddr# :: Addr# -> Addr# -> Int#
eqAddr# = eqAddr#

neAddr# :: Addr# -> Addr# -> Int#
neAddr# = neAddr#

ltAddr# :: Addr# -> Addr# -> Int#
ltAddr# = ltAddr#

leAddr# :: Addr# -> Addr# -> Int#
leAddr# = leAddr#

-- |Reads 8-bit character; offset in bytes.

indexCharOffAddr# :: Addr# -> Int# -> Char#
indexCharOffAddr# = indexCharOffAddr#

-- |Reads 31-bit character; offset in 4-byte words.

indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# = indexWideCharOffAddr#

indexIntOffAddr# :: Addr# -> Int# -> Int#
indexIntOffAddr# = indexIntOffAddr#

indexWordOffAddr# :: Addr# -> Int# -> Word#
indexWordOffAddr# = indexWordOffAddr#

indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexAddrOffAddr# = indexAddrOffAddr#

indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexFloatOffAddr# = indexFloatOffAddr#

indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexDoubleOffAddr# = indexDoubleOffAddr#

indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexStablePtrOffAddr# = indexStablePtrOffAddr#

indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt8OffAddr# = indexInt8OffAddr#

indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# = indexInt16OffAddr#

indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# = indexInt32OffAddr#

indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# = indexInt64OffAddr#

indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord8OffAddr# = indexWord8OffAddr#

indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# = indexWord16OffAddr#

indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# = indexWord32OffAddr#

indexWord64OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# = indexWord64OffAddr#

-- |Reads 8-bit character; offset in bytes.

readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Char# #)
readCharOffAddr# = readCharOffAddr#

-- |Reads 31-bit character; offset in 4-byte words.

readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Char# #)
readWideCharOffAddr# = readWideCharOffAddr#

readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
readIntOffAddr# = readIntOffAddr#

readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
readWordOffAddr# = readWordOffAddr#

readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Addr# #)
readAddrOffAddr# = readAddrOffAddr#

readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Float# #)
readFloatOffAddr# = readFloatOffAddr#

readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Double# #)
readDoubleOffAddr# = readDoubleOffAddr#

readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,StablePtr# a #)
readStablePtrOffAddr# = readStablePtrOffAddr#

readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
readInt8OffAddr# = readInt8OffAddr#

readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
readInt16OffAddr# = readInt16OffAddr#

readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
readInt32OffAddr# = readInt32OffAddr#

readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
readInt64OffAddr# = readInt64OffAddr#

readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
readWord8OffAddr# = readWord8OffAddr#

readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
readWord16OffAddr# = readWord16OffAddr#

readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
readWord32OffAddr# = readWord32OffAddr#

readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
readWord64OffAddr# = readWord64OffAddr#

writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeCharOffAddr# = writeCharOffAddr#

writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# = writeWideCharOffAddr#

writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeIntOffAddr# = writeIntOffAddr#

writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWordOffAddr# = writeWordOffAddr#

writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeAddrOffAddr# = writeAddrOffAddr#

writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeFloatOffAddr# = writeFloatOffAddr#

writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeDoubleOffAddr# = writeDoubleOffAddr#

writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeStablePtrOffAddr# = writeStablePtrOffAddr#

writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt8OffAddr# = writeInt8OffAddr#

writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# = writeInt16OffAddr#

writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# = writeInt32OffAddr#

writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# = writeInt64OffAddr#

writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord8OffAddr# = writeWord8OffAddr#

writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# = writeWord16OffAddr#

writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# = writeWord32OffAddr#

writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# = writeWord64OffAddr#

-- |A @MutVar\#@ behaves like a single-element mutable array.

data MutVar# s a

-- |Create @MutVar\#@ with specified initial value in specified state thread.

newMutVar# :: a -> State# s -> (# State# s,MutVar# s a #)
newMutVar# = newMutVar#

-- |Read contents of @MutVar\#@. Result is not yet evaluated.

readMutVar# :: MutVar# s a -> State# s -> (# State# s,a #)
readMutVar# = readMutVar#

-- |Write contents of @MutVar\#@.

writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
writeMutVar# = writeMutVar#

sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
sameMutVar# = sameMutVar#

-- | Modify the contents of a @MutVar\#@. Note that this isn\'t strictly
--      speaking the correct type for this function, it should really be
--      @MutVar# s a -> (a -> (a,b)) -> State# s -> (# State# s, b #)@, however
--      we don\'t know about pairs here. 

atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s,c #)
atomicModifyMutVar# = atomicModifyMutVar#

casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s,Int#,a #)
casMutVar# = casMutVar#

catch# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
catch# = catch#

raise# :: b -> o
raise# = raise#

raiseIO# :: a -> State# (RealWorld) -> (# State# (RealWorld),b #)
raiseIO# = raiseIO#

maskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
maskAsyncExceptions# = maskAsyncExceptions#

maskUninterruptible# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
maskUninterruptible# = maskUninterruptible#

unmaskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
unmaskAsyncExceptions# = unmaskAsyncExceptions#

getMaskingState# :: State# (RealWorld) -> (# State# (RealWorld),Int# #)
getMaskingState# = getMaskingState#

data TVar# s a

atomically# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
atomically# = atomically#

retry# :: State# (RealWorld) -> (# State# (RealWorld),a #)
retry# = retry#

catchRetry# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
catchRetry# = catchRetry#

catchSTM# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
catchSTM# = catchSTM#

check# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> State# (RealWorld)
check# = check#

-- |Create a new @TVar\#@ holding a specified initial value.

newTVar# :: a -> State# s -> (# State# s,TVar# s a #)
newTVar# = newTVar#

-- |Read contents of @TVar\#@.  Result is not yet evaluated.

readTVar# :: TVar# s a -> State# s -> (# State# s,a #)
readTVar# = readTVar#

-- |Read contents of @TVar\#@ outside an STM transaction

readTVarIO# :: TVar# s a -> State# s -> (# State# s,a #)
readTVarIO# = readTVarIO#

-- |Write contents of @TVar\#@.

writeTVar# :: TVar# s a -> a -> State# s -> State# s
writeTVar# = writeTVar#

sameTVar# :: TVar# s a -> TVar# s a -> Int#
sameTVar# = sameTVar#

-- | A shared mutable variable (/not/ the same as a @MutVar\#@!).
--         (Note: in a non-concurrent implementation, @(MVar\# a)@ can be
--         represented by @(MutVar\# (Maybe a))@.) 

data MVar# s a

-- |Create new @MVar\#@; initially empty.

newMVar# :: State# s -> (# State# s,MVar# s a #)
newMVar# = newMVar#

-- |If @MVar\#@ is empty, block until it becomes full.
--    Then remove and return its contents, and set it empty.

takeMVar# :: MVar# s a -> State# s -> (# State# s,a #)
takeMVar# = takeMVar#

-- |If @MVar\#@ is empty, immediately return with integer 0 and value undefined.
--    Otherwise, return with integer 1 and contents of @MVar\#@, and set @MVar\#@ empty.

tryTakeMVar# :: MVar# s a -> State# s -> (# State# s,Int#,a #)
tryTakeMVar# = tryTakeMVar#

-- |If @MVar\#@ is full, block until it becomes empty.
--    Then store value arg as its new contents.

putMVar# :: MVar# s a -> a -> State# s -> State# s
putMVar# = putMVar#

-- |If @MVar\#@ is full, immediately return with integer 0.
--     Otherwise, store value arg as @MVar\#@\'s new contents, and return with integer 1.

tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s,Int# #)
tryPutMVar# = tryPutMVar#

-- |If @MVar\#@ is empty, block until it becomes full.
--    Then read its contents without modifying the MVar, without possibility
--    of intervention from other threads.

readMVar# :: MVar# s a -> State# s -> (# State# s,a #)
readMVar# = readMVar#

-- |If @MVar\#@ is empty, immediately return with integer 0 and value undefined.
--    Otherwise, return with integer 1 and contents of @MVar\#@.

tryReadMVar# :: MVar# s a -> State# s -> (# State# s,Int#,a #)
tryReadMVar# = tryReadMVar#

sameMVar# :: MVar# s a -> MVar# s a -> Int#
sameMVar# = sameMVar#

-- |Return 1 if @MVar\#@ is empty; 0 otherwise.

isEmptyMVar# :: MVar# s a -> State# s -> (# State# s,Int# #)
isEmptyMVar# = isEmptyMVar#

-- |Sleep specified number of microseconds.

delay# :: Int# -> State# s -> State# s
delay# = delay#

-- |Block until input is available on specified file descriptor.

waitRead# :: Int# -> State# s -> State# s
waitRead# = waitRead#

-- |Block until output is possible on specified file descriptor.

waitWrite# :: Int# -> State# s -> State# s
waitWrite# = waitWrite#

-- | @State\#@ is the primitive, unlifted type of states.  It has
--         one type parameter, thus @State\# RealWorld@, or @State\# s@,
--         where s is a type variable. The only purpose of the type parameter
--         is to keep different state threads separate.  It is represented by
--         nothing at all. 

data State# s

-- | @RealWorld@ is deeply magical.  It is /primitive/, but it is not
--         /unlifted/ (hence @ptrArg@).  We never manipulate values of type
--         @RealWorld@; it\'s only used in the type system, to parameterise @State\#@. 

data RealWorld

-- |(In a non-concurrent implementation, this can be a singleton
--         type, whose (unique) value is returned by @myThreadId\#@.  The
--         other operations can be omitted.)

data ThreadId#

fork# :: a -> State# (RealWorld) -> (# State# (RealWorld),ThreadId# #)
fork# = fork#

forkOn# :: Int# -> a -> State# (RealWorld) -> (# State# (RealWorld),ThreadId# #)
forkOn# = forkOn#

killThread# :: ThreadId# -> a -> State# (RealWorld) -> State# (RealWorld)
killThread# = killThread#

yield# :: State# (RealWorld) -> State# (RealWorld)
yield# = yield#

myThreadId# :: State# (RealWorld) -> (# State# (RealWorld),ThreadId# #)
myThreadId# = myThreadId#

labelThread# :: ThreadId# -> Addr# -> State# (RealWorld) -> State# (RealWorld)
labelThread# = labelThread#

isCurrentThreadBound# :: State# (RealWorld) -> (# State# (RealWorld),Int# #)
isCurrentThreadBound# = isCurrentThreadBound#

noDuplicate# :: State# s -> State# s
noDuplicate# = noDuplicate#

threadStatus# :: ThreadId# -> State# (RealWorld) -> (# State# (RealWorld),Int#,Int#,Int# #)
threadStatus# = threadStatus#

data Weak# b

-- | @mkWeak# k v finalizer s@ creates a weak reference to value @k@,
--      with an associated reference to some value @v@. If @k@ is still
--      alive then @v@ can be retrieved using @deRefWeak#@. Note that
--      the type of @k@ must be represented by a pointer (i.e. of kind @TYPE \'LiftedRep@ or @TYPE \'UnliftedRep@). 

mkWeak# :: o -> b -> (State# (RealWorld) -> (# State# (RealWorld),c #)) -> State# (RealWorld) -> (# State# (RealWorld),Weak# b #)
mkWeak# = mkWeak#

mkWeakNoFinalizer# :: o -> b -> State# (RealWorld) -> (# State# (RealWorld),Weak# b #)
mkWeakNoFinalizer# = mkWeakNoFinalizer#

-- | @addCFinalizerToWeak# fptr ptr flag eptr w@ attaches a C
--      function pointer @fptr@ to a weak pointer @w@ as a finalizer. If
--      @flag@ is zero, @fptr@ will be called with one argument,
--      @ptr@. Otherwise, it will be called with two arguments,
--      @eptr@ and @ptr@. @addCFinalizerToWeak#@ returns
--      1 on success, or 0 if @w@ is already dead. 

addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# (RealWorld) -> (# State# (RealWorld),Int# #)
addCFinalizerToWeak# = addCFinalizerToWeak#

deRefWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld),Int#,a #)
deRefWeak# = deRefWeak#

-- | Finalize a weak pointer. The return value is an unboxed tuple
--      containing the new state of the world and an \"unboxed Maybe\",
--      represented by an @Int#@ and a (possibly invalid) finalization
--      action. An @Int#@ of @1@ indicates that the finalizer is valid. The
--      return value @b@ from the finalizer should be ignored. 

finalizeWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld),Int#,State# (RealWorld) -> (# State# (RealWorld),b #) #)
finalizeWeak# = finalizeWeak#

touch# :: o -> State# (RealWorld) -> State# (RealWorld)
touch# = touch#

data StablePtr# a

data StableName# a

makeStablePtr# :: a -> State# (RealWorld) -> (# State# (RealWorld),StablePtr# a #)
makeStablePtr# = makeStablePtr#

deRefStablePtr# :: StablePtr# a -> State# (RealWorld) -> (# State# (RealWorld),a #)
deRefStablePtr# = deRefStablePtr#

eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
eqStablePtr# = eqStablePtr#

makeStableName# :: a -> State# (RealWorld) -> (# State# (RealWorld),StableName# a #)
makeStableName# = makeStableName#

eqStableName# :: StableName# a -> StableName# b -> Int#
eqStableName# = eqStableName#

stableNameToInt# :: StableName# a -> Int#
stableNameToInt# = stableNameToInt#

data Compact#

-- | Create a new Compact with the given size (in bytes, not words).
--      The size is rounded up to a multiple of the allocator block size,
--      and capped to one mega block. 

compactNew# :: Word# -> State# (RealWorld) -> (# State# (RealWorld),Compact# #)
compactNew# = compactNew#

-- | Set the new allocation size of the compact. This value (in bytes)
--      determines the size of each block in the compact chain. 

compactResize# :: Compact# -> Word# -> State# (RealWorld) -> State# (RealWorld)
compactResize# = compactResize#

-- | Returns 1# if the object is contained in the compact, 0# otherwise. 

compactContains# :: Compact# -> a -> State# (RealWorld) -> (# State# (RealWorld),Int# #)
compactContains# = compactContains#

-- | Returns 1# if the object is in any compact at all, 0# otherwise. 

compactContainsAny# :: a -> State# (RealWorld) -> (# State# (RealWorld),Int# #)
compactContainsAny# = compactContainsAny#

-- | Returns the address and the size (in bytes) of the first block of
--      a compact. 

compactGetFirstBlock# :: Compact# -> State# (RealWorld) -> (# State# (RealWorld),Addr#,Word# #)
compactGetFirstBlock# = compactGetFirstBlock#

-- | Given a compact and the address of one its blocks, returns the
--      next block and its size, or #nullAddr if the argument was the
--      last block in the compact. 

compactGetNextBlock# :: Compact# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Addr#,Word# #)
compactGetNextBlock# = compactGetNextBlock#

-- | Attempt to allocate a compact block with the given size (in
--      bytes) at the given address. The first argument is a hint to
--      the allocator, allocation might be satisfied at a different
--      address (which is returned).
--      The resulting block is not known to the GC until
--      compactFixupPointers# is called on it, and care must be taken
--      so that the address does not escape or memory will be leaked.
--    

compactAllocateBlock# :: Word# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Addr# #)
compactAllocateBlock# = compactAllocateBlock#

-- | Given the pointer to the first block of a compact, and the
--      address of the root object in the old address space, fix up
--      the internal pointers inside the compact to account for
--      a different position in memory than when it was serialized.
--      This method must be called exactly once after importing
--      a serialized compact, and returns the new compact and
--      the new adjusted root address. 

compactFixupPointers# :: Addr# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Compact#,Addr# #)
compactFixupPointers# = compactFixupPointers#

-- | Recursively add a closure and its transitive closure to a
--      {\texttt Compact\#}, evaluating any unevaluated components at the
--      same time.  Note: {\texttt compactAdd\#} is not thread-safe, so
--      only one thread may call {\texttt compactAdd\#} with a particular
--      {\texttt Compact#} at any given time.  The primop does not
--      enforce any mutual exclusion; the caller is expected to
--      arrange this. 

compactAdd# :: Compact# -> a -> State# (RealWorld) -> (# State# (RealWorld),a #)
compactAdd# = compactAdd#

-- | Like {\texttt compactAdd\#}, but retains sharing and cycles
--    during compaction. 

compactAddWithSharing# :: Compact# -> a -> State# (RealWorld) -> (# State# (RealWorld),a #)
compactAddWithSharing# = compactAddWithSharing#

-- | Return the size (in bytes) of the total amount of data in the Compact# 

compactSize# :: Compact# -> State# (RealWorld) -> (# State# (RealWorld),Word# #)
compactSize# = compactSize#

-- | Returns 1# if the given pointers are equal and 0# otherwise. 

reallyUnsafePtrEquality# :: a -> a -> Int#
reallyUnsafePtrEquality# = reallyUnsafePtrEquality#

par# :: a -> Int#
par# = par#

spark# :: a -> State# s -> (# State# s,a #)
spark# = spark#

seq# :: a -> State# s -> (# State# s,a #)
seq# = seq#

getSpark# :: State# s -> (# State# s,Int#,a #)
getSpark# = getSpark#

-- | Returns the number of sparks in the local spark pool. 

numSparks# :: State# s -> (# State# s,Int# #)
numSparks# = numSparks#

dataToTag# :: a -> Int#
dataToTag# = dataToTag#

-- |- Note [dataToTag#]
-- ~~~~~~~~~~~~~~~~~~~~
-- The dataToTag# primop should always be applied to an evaluated argument.
-- The way to ensure this is to invoke it via the \'getTag\' wrapper in GHC.Base:
--    getTag :: a -> Int#
--    getTag !x = dataToTag# x
-- 
-- But now consider
--     \z. case x of y -> let v = dataToTag# y in ...
-- 
-- To improve floating, the FloatOut pass (deliberately) does a
-- binder-swap on the case, to give
--     \z. case x of y -> let v = dataToTag# x in ...
-- 
-- Now FloatOut might float that v-binding outside the \z.  But that is
-- bad because that might mean x gest evaluated much too early!  (CorePrep
-- adds an eval to a dataToTag# call, to ensure that the argument really is
-- evaluated; see CorePrep Note [dataToTag magic].)
-- 
-- Solution: make DataToTag into a can_fail primop.  That will stop it floating
-- (see Note [PrimOp can_fail and has_side_effects] in PrimOp).  It\'s a bit of
-- a hack but never mind.
-- -

tagToEnum# :: Int# -> a
tagToEnum# = let x = x in x

-- | Primitive bytecode type. 

data BCO#

-- | Convert an @Addr\#@ to a followable Any type. 

addrToAny# :: Addr# -> (# a #)
addrToAny# = addrToAny#

-- | Retrive the address of any Haskell value. This is
--      essentially an {\texttt unsafeCoerce\#}, but if implemented as such
--      the core lint pass complains and fails to compile.
--      As a primop, it is opaque to core\/stg, and only appears
--      in cmm (where the copy propagation pass will get rid of it).
--      Note that \"a\" must be a value, not a thunk! It\'s too late
--      for strictness analysis to enforce this, so you\'re on your
--      own to guarantee this. Also note that {\texttt Addr\#} is not a GC
--      pointer - up to you to guarantee that it does not become
--      a dangling pointer immediately after you get it.

anyToAddr# :: a -> State# (RealWorld) -> (# State# (RealWorld),Addr# #)
anyToAddr# = anyToAddr#

-- | Wrap a BCO in a @AP_UPD@ thunk which will be updated with the value of
--      the BCO when evaluated. 

mkApUpd0# :: BCO# -> (# a #)
mkApUpd0# = mkApUpd0#

-- | @newBCO\# instrs lits ptrs arity bitmap@ creates a new bytecode object. The
--      resulting object encodes a function of the given arity with the instructions
--      encoded in @instrs@, and a static reference table usage bitmap given by
--      @bitmap@. 

newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s,BCO# #)
newBCO# = newBCO#

-- | @unpackClosure\# closure@ copies non-pointers and pointers in the
--      payload of the given closure into two new arrays, and returns a pointer to
--      the first word of the closure\'s info table, a pointer array for the
--      pointers in the payload, and a non-pointer array for the non-pointers in
--      the payload. 

unpackClosure# :: a -> (# Addr#,Array# b,ByteArray# #)
unpackClosure# = unpackClosure#

getApStackVal# :: a -> Int# -> (# Int#,b #)
getApStackVal# = getApStackVal#

getCCSOf# :: a -> State# s -> (# State# s,Addr# #)
getCCSOf# = getCCSOf#

-- | Returns the current @CostCentreStack@ (value is @NULL@ if
--      not profiling).  Takes a dummy argument which can be used to
--      avoid the call to @getCCCS\#@ being floated out by the
--      simplifier, which would result in an uninformative stack
--      (\"CAF\"). 

getCurrentCCS# :: a -> State# s -> (# State# s,Addr# #)
getCurrentCCS# = getCurrentCCS#

-- | Run the supplied IO action with an empty CCS.  For example, this
--      is used by the interpreter to run an interpreted computation
--      without the call stack showing that it was invoked from GHC. 

clearCCS# :: (State# s -> (# State# s,a #)) -> State# s -> (# State# s,a #)
clearCCS# = clearCCS#

-- | The type constructor @Proxy#@ is used to bear witness to some
--    type variable. It\'s used when you want to pass around proxy values
--    for doing things like modelling type applications. A @Proxy#@
--    is not only unboxed, it also has a polymorphic kind, and has no
--    runtime representation, being totally free. 

data Proxy# a

-- | Witness for an unboxed @Proxy#@ value, which has no runtime
--    representation. 

proxy# :: Proxy# a
proxy# = proxy#

-- | The value of @seq a b@ is bottom if @a@ is bottom, and
--      otherwise equal to @b@. @seq@ is usually introduced to
--      improve performance by avoiding unneeded laziness.
-- 
--      A note on evaluation order: the expression @seq a b@ does
--      /not/ guarantee that @a@ will be evaluated before @b@.
--      The only guarantee given by @seq@ is that the both @a@
--      and @b@ will be evaluated before @seq@ returns a value.
--      In particular, this means that @b@ may be evaluated before
--      @a@. If you need to guarantee a specific order of evaluation,
--      you must use the function @pseq@ from the \"parallel\" package. 

seq :: a -> b -> b
seq = seq

-- | The function @unsafeCoerce\#@ allows you to side-step the typechecker entirely. That
--         is, it allows you to coerce any type into any other type. If you use this function,
--         you had better get it right, otherwise segmentation faults await. It is generally
--         used when you want to write a program that you know is well-typed, but where Haskell\'s
--         type system is not expressive enough to prove that it is well typed.
-- 
--         The following uses of @unsafeCoerce\#@ are supposed to work (i.e. not lead to
--         spurious compile-time or run-time crashes):
-- 
--          * Casting any lifted type to @Any@
-- 
--          * Casting @Any@ back to the real type
-- 
--          * Casting an unboxed type to another unboxed type of the same size
--            (but not coercions between floating-point and integral types)
-- 
--          * Casting between two types that have the same runtime representation.  One case is when
--            the two types differ only in \"phantom\" type parameters, for example
--            @Ptr Int@ to @Ptr Float@, or @[Int]@ to @[Float]@ when the list is
--            known to be empty.  Also, a @newtype@ of a type @T@ has the same representation
--            at runtime as @T@.
-- 
--         Other uses of @unsafeCoerce\#@ are undefined.  In particular, you should not use
--         @unsafeCoerce\#@ to cast a T to an algebraic data type D, unless T is also
--         an algebraic data type.  For example, do not cast @Int->Int@ to @Bool@, even if
--         you later cast that @Bool@ back to @Int->Int@ before applying it.  The reasons
--         have to do with GHC\'s internal representation details (for the congnoscenti, data values
--         can be entered but function closures cannot).  If you want a safe type to cast things
--         to, use @Any@, which is not an algebraic data type.
-- 
--         

unsafeCoerce# :: a -> b
unsafeCoerce# = unsafeCoerce#

-- | Emits an event via the RTS tracing framework.  The contents
--      of the event is the zero-terminated byte string passed as the first
--      argument.  The event will be emitted either to the .eventlog file,
--      or to stderr, depending on the runtime RTS flags. 

traceEvent# :: Addr# -> State# s -> State# s
traceEvent# = traceEvent#

-- | Emits a marker event via the RTS tracing framework.  The contents
--      of the event is the zero-terminated byte string passed as the first
--      argument.  The event will be emitted either to the .eventlog file,
--      or to stderr, depending on the runtime RTS flags. 

traceMarker# :: Addr# -> State# s -> State# s
traceMarker# = traceMarker#

-- | The function @coerce@ allows you to safely convert between values of
--      types that have the same representation with no run-time overhead. In the
--      simplest case you can use it instead of a newtype constructor, to go from
--      the newtype\'s concrete type to the abstract type. But it also works in
--      more complicated settings, e.g. converting a list of newtypes to a list of
--      concrete types.
--    

coerce :: Coercible a b => a -> b
coerce = coerce

data Int8X16#

data Int16X8#

data Int32X4#

data Int64X2#

data Int8X32#

data Int16X16#

data Int32X8#

data Int64X4#

data Int8X64#

data Int16X32#

data Int32X16#

data Int64X8#

data Word8X16#

data Word16X8#

data Word32X4#

data Word64X2#

data Word8X32#

data Word16X16#

data Word32X8#

data Word64X4#

data Word8X64#

data Word16X32#

data Word32X16#

data Word64X8#

data FloatX4#

data DoubleX2#

data FloatX8#

data DoubleX4#

data FloatX16#

data DoubleX8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt8X16# :: Int# -> Int8X16#
broadcastInt8X16# = broadcastInt8X16#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt16X8# :: Int# -> Int16X8#
broadcastInt16X8# = broadcastInt16X8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt32X4# :: Int# -> Int32X4#
broadcastInt32X4# = broadcastInt32X4#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt64X2# :: Int# -> Int64X2#
broadcastInt64X2# = broadcastInt64X2#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt8X32# :: Int# -> Int8X32#
broadcastInt8X32# = broadcastInt8X32#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt16X16# :: Int# -> Int16X16#
broadcastInt16X16# = broadcastInt16X16#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt32X8# :: Int# -> Int32X8#
broadcastInt32X8# = broadcastInt32X8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt64X4# :: Int# -> Int64X4#
broadcastInt64X4# = broadcastInt64X4#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt8X64# :: Int# -> Int8X64#
broadcastInt8X64# = broadcastInt8X64#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt16X32# :: Int# -> Int16X32#
broadcastInt16X32# = broadcastInt16X32#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt32X16# :: Int# -> Int32X16#
broadcastInt32X16# = broadcastInt32X16#

-- | Broadcast a scalar to all elements of a vector. 

broadcastInt64X8# :: Int# -> Int64X8#
broadcastInt64X8# = broadcastInt64X8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord8X16# :: Word# -> Word8X16#
broadcastWord8X16# = broadcastWord8X16#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord16X8# :: Word# -> Word16X8#
broadcastWord16X8# = broadcastWord16X8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord32X4# :: Word# -> Word32X4#
broadcastWord32X4# = broadcastWord32X4#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord64X2# :: Word# -> Word64X2#
broadcastWord64X2# = broadcastWord64X2#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord8X32# :: Word# -> Word8X32#
broadcastWord8X32# = broadcastWord8X32#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord16X16# :: Word# -> Word16X16#
broadcastWord16X16# = broadcastWord16X16#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord32X8# :: Word# -> Word32X8#
broadcastWord32X8# = broadcastWord32X8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord64X4# :: Word# -> Word64X4#
broadcastWord64X4# = broadcastWord64X4#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord8X64# :: Word# -> Word8X64#
broadcastWord8X64# = broadcastWord8X64#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord16X32# :: Word# -> Word16X32#
broadcastWord16X32# = broadcastWord16X32#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord32X16# :: Word# -> Word32X16#
broadcastWord32X16# = broadcastWord32X16#

-- | Broadcast a scalar to all elements of a vector. 

broadcastWord64X8# :: Word# -> Word64X8#
broadcastWord64X8# = broadcastWord64X8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastFloatX4# :: Float# -> FloatX4#
broadcastFloatX4# = broadcastFloatX4#

-- | Broadcast a scalar to all elements of a vector. 

broadcastDoubleX2# :: Double# -> DoubleX2#
broadcastDoubleX2# = broadcastDoubleX2#

-- | Broadcast a scalar to all elements of a vector. 

broadcastFloatX8# :: Float# -> FloatX8#
broadcastFloatX8# = broadcastFloatX8#

-- | Broadcast a scalar to all elements of a vector. 

broadcastDoubleX4# :: Double# -> DoubleX4#
broadcastDoubleX4# = broadcastDoubleX4#

-- | Broadcast a scalar to all elements of a vector. 

broadcastFloatX16# :: Float# -> FloatX16#
broadcastFloatX16# = broadcastFloatX16#

-- | Broadcast a scalar to all elements of a vector. 

broadcastDoubleX8# :: Double# -> DoubleX8#
broadcastDoubleX8# = broadcastDoubleX8#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt8X16# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int8X16#
packInt8X16# = packInt8X16#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt16X8# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int16X8#
packInt16X8# = packInt16X8#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt32X4# :: (# Int#,Int#,Int#,Int# #) -> Int32X4#
packInt32X4# = packInt32X4#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt64X2# :: (# Int#,Int# #) -> Int64X2#
packInt64X2# = packInt64X2#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt8X32# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int8X32#
packInt8X32# = packInt8X32#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt16X16# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int16X16#
packInt16X16# = packInt16X16#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt32X8# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int32X8#
packInt32X8# = packInt32X8#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt64X4# :: (# Int#,Int#,Int#,Int# #) -> Int64X4#
packInt64X4# = packInt64X4#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt8X64# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int8X64#
packInt8X64# = packInt8X64#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt16X32# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int16X32#
packInt16X32# = packInt16X32#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt32X16# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int32X16#
packInt32X16# = packInt32X16#

-- | Pack the elements of an unboxed tuple into a vector. 

packInt64X8# :: (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #) -> Int64X8#
packInt64X8# = packInt64X8#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord8X16# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word8X16#
packWord8X16# = packWord8X16#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord16X8# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word16X8#
packWord16X8# = packWord16X8#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord32X4# :: (# Word#,Word#,Word#,Word# #) -> Word32X4#
packWord32X4# = packWord32X4#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord64X2# :: (# Word#,Word# #) -> Word64X2#
packWord64X2# = packWord64X2#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord8X32# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word8X32#
packWord8X32# = packWord8X32#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord16X16# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word16X16#
packWord16X16# = packWord16X16#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord32X8# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word32X8#
packWord32X8# = packWord32X8#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord64X4# :: (# Word#,Word#,Word#,Word# #) -> Word64X4#
packWord64X4# = packWord64X4#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord8X64# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word8X64#
packWord8X64# = packWord8X64#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord16X32# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word16X32#
packWord16X32# = packWord16X32#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord32X16# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word32X16#
packWord32X16# = packWord32X16#

-- | Pack the elements of an unboxed tuple into a vector. 

packWord64X8# :: (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #) -> Word64X8#
packWord64X8# = packWord64X8#

-- | Pack the elements of an unboxed tuple into a vector. 

packFloatX4# :: (# Float#,Float#,Float#,Float# #) -> FloatX4#
packFloatX4# = packFloatX4#

-- | Pack the elements of an unboxed tuple into a vector. 

packDoubleX2# :: (# Double#,Double# #) -> DoubleX2#
packDoubleX2# = packDoubleX2#

-- | Pack the elements of an unboxed tuple into a vector. 

packFloatX8# :: (# Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float# #) -> FloatX8#
packFloatX8# = packFloatX8#

-- | Pack the elements of an unboxed tuple into a vector. 

packDoubleX4# :: (# Double#,Double#,Double#,Double# #) -> DoubleX4#
packDoubleX4# = packDoubleX4#

-- | Pack the elements of an unboxed tuple into a vector. 

packFloatX16# :: (# Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float# #) -> FloatX16#
packFloatX16# = packFloatX16#

-- | Pack the elements of an unboxed tuple into a vector. 

packDoubleX8# :: (# Double#,Double#,Double#,Double#,Double#,Double#,Double#,Double# #) -> DoubleX8#
packDoubleX8# = packDoubleX8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt8X16# :: Int8X16# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt8X16# = unpackInt8X16#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt16X8# :: Int16X8# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt16X8# = unpackInt16X8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt32X4# :: Int32X4# -> (# Int#,Int#,Int#,Int# #)
unpackInt32X4# = unpackInt32X4#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt64X2# :: Int64X2# -> (# Int#,Int# #)
unpackInt64X2# = unpackInt64X2#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt8X32# :: Int8X32# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt8X32# = unpackInt8X32#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt16X16# :: Int16X16# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt16X16# = unpackInt16X16#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt32X8# :: Int32X8# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt32X8# = unpackInt32X8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt64X4# :: Int64X4# -> (# Int#,Int#,Int#,Int# #)
unpackInt64X4# = unpackInt64X4#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt8X64# :: Int8X64# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt8X64# = unpackInt8X64#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt16X32# :: Int16X32# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt16X32# = unpackInt16X32#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt32X16# :: Int32X16# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt32X16# = unpackInt32X16#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackInt64X8# :: Int64X8# -> (# Int#,Int#,Int#,Int#,Int#,Int#,Int#,Int# #)
unpackInt64X8# = unpackInt64X8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord8X16# :: Word8X16# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord8X16# = unpackWord8X16#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord16X8# :: Word16X8# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord16X8# = unpackWord16X8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord32X4# :: Word32X4# -> (# Word#,Word#,Word#,Word# #)
unpackWord32X4# = unpackWord32X4#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord64X2# :: Word64X2# -> (# Word#,Word# #)
unpackWord64X2# = unpackWord64X2#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord8X32# :: Word8X32# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord8X32# = unpackWord8X32#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord16X16# :: Word16X16# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord16X16# = unpackWord16X16#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord32X8# :: Word32X8# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord32X8# = unpackWord32X8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord64X4# :: Word64X4# -> (# Word#,Word#,Word#,Word# #)
unpackWord64X4# = unpackWord64X4#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord8X64# :: Word8X64# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord8X64# = unpackWord8X64#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord16X32# :: Word16X32# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord16X32# = unpackWord16X32#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord32X16# :: Word32X16# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord32X16# = unpackWord32X16#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackWord64X8# :: Word64X8# -> (# Word#,Word#,Word#,Word#,Word#,Word#,Word#,Word# #)
unpackWord64X8# = unpackWord64X8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackFloatX4# :: FloatX4# -> (# Float#,Float#,Float#,Float# #)
unpackFloatX4# = unpackFloatX4#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackDoubleX2# :: DoubleX2# -> (# Double#,Double# #)
unpackDoubleX2# = unpackDoubleX2#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackFloatX8# :: FloatX8# -> (# Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float# #)
unpackFloatX8# = unpackFloatX8#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackDoubleX4# :: DoubleX4# -> (# Double#,Double#,Double#,Double# #)
unpackDoubleX4# = unpackDoubleX4#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackFloatX16# :: FloatX16# -> (# Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float#,Float# #)
unpackFloatX16# = unpackFloatX16#

-- | Unpack the elements of a vector into an unboxed tuple. #

unpackDoubleX8# :: DoubleX8# -> (# Double#,Double#,Double#,Double#,Double#,Double#,Double#,Double# #)
unpackDoubleX8# = unpackDoubleX8#

-- | Insert a scalar at the given position in a vector. 

insertInt8X16# :: Int8X16# -> Int# -> Int# -> Int8X16#
insertInt8X16# = insertInt8X16#

-- | Insert a scalar at the given position in a vector. 

insertInt16X8# :: Int16X8# -> Int# -> Int# -> Int16X8#
insertInt16X8# = insertInt16X8#

-- | Insert a scalar at the given position in a vector. 

insertInt32X4# :: Int32X4# -> Int# -> Int# -> Int32X4#
insertInt32X4# = insertInt32X4#

-- | Insert a scalar at the given position in a vector. 

insertInt64X2# :: Int64X2# -> Int# -> Int# -> Int64X2#
insertInt64X2# = insertInt64X2#

-- | Insert a scalar at the given position in a vector. 

insertInt8X32# :: Int8X32# -> Int# -> Int# -> Int8X32#
insertInt8X32# = insertInt8X32#

-- | Insert a scalar at the given position in a vector. 

insertInt16X16# :: Int16X16# -> Int# -> Int# -> Int16X16#
insertInt16X16# = insertInt16X16#

-- | Insert a scalar at the given position in a vector. 

insertInt32X8# :: Int32X8# -> Int# -> Int# -> Int32X8#
insertInt32X8# = insertInt32X8#

-- | Insert a scalar at the given position in a vector. 

insertInt64X4# :: Int64X4# -> Int# -> Int# -> Int64X4#
insertInt64X4# = insertInt64X4#

-- | Insert a scalar at the given position in a vector. 

insertInt8X64# :: Int8X64# -> Int# -> Int# -> Int8X64#
insertInt8X64# = insertInt8X64#

-- | Insert a scalar at the given position in a vector. 

insertInt16X32# :: Int16X32# -> Int# -> Int# -> Int16X32#
insertInt16X32# = insertInt16X32#

-- | Insert a scalar at the given position in a vector. 

insertInt32X16# :: Int32X16# -> Int# -> Int# -> Int32X16#
insertInt32X16# = insertInt32X16#

-- | Insert a scalar at the given position in a vector. 

insertInt64X8# :: Int64X8# -> Int# -> Int# -> Int64X8#
insertInt64X8# = insertInt64X8#

-- | Insert a scalar at the given position in a vector. 

insertWord8X16# :: Word8X16# -> Word# -> Int# -> Word8X16#
insertWord8X16# = insertWord8X16#

-- | Insert a scalar at the given position in a vector. 

insertWord16X8# :: Word16X8# -> Word# -> Int# -> Word16X8#
insertWord16X8# = insertWord16X8#

-- | Insert a scalar at the given position in a vector. 

insertWord32X4# :: Word32X4# -> Word# -> Int# -> Word32X4#
insertWord32X4# = insertWord32X4#

-- | Insert a scalar at the given position in a vector. 

insertWord64X2# :: Word64X2# -> Word# -> Int# -> Word64X2#
insertWord64X2# = insertWord64X2#

-- | Insert a scalar at the given position in a vector. 

insertWord8X32# :: Word8X32# -> Word# -> Int# -> Word8X32#
insertWord8X32# = insertWord8X32#

-- | Insert a scalar at the given position in a vector. 

insertWord16X16# :: Word16X16# -> Word# -> Int# -> Word16X16#
insertWord16X16# = insertWord16X16#

-- | Insert a scalar at the given position in a vector. 

insertWord32X8# :: Word32X8# -> Word# -> Int# -> Word32X8#
insertWord32X8# = insertWord32X8#

-- | Insert a scalar at the given position in a vector. 

insertWord64X4# :: Word64X4# -> Word# -> Int# -> Word64X4#
insertWord64X4# = insertWord64X4#

-- | Insert a scalar at the given position in a vector. 

insertWord8X64# :: Word8X64# -> Word# -> Int# -> Word8X64#
insertWord8X64# = insertWord8X64#

-- | Insert a scalar at the given position in a vector. 

insertWord16X32# :: Word16X32# -> Word# -> Int# -> Word16X32#
insertWord16X32# = insertWord16X32#

-- | Insert a scalar at the given position in a vector. 

insertWord32X16# :: Word32X16# -> Word# -> Int# -> Word32X16#
insertWord32X16# = insertWord32X16#

-- | Insert a scalar at the given position in a vector. 

insertWord64X8# :: Word64X8# -> Word# -> Int# -> Word64X8#
insertWord64X8# = insertWord64X8#

-- | Insert a scalar at the given position in a vector. 

insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#
insertFloatX4# = insertFloatX4#

-- | Insert a scalar at the given position in a vector. 

insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#
insertDoubleX2# = insertDoubleX2#

-- | Insert a scalar at the given position in a vector. 

insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#
insertFloatX8# = insertFloatX8#

-- | Insert a scalar at the given position in a vector. 

insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#
insertDoubleX4# = insertDoubleX4#

-- | Insert a scalar at the given position in a vector. 

insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#
insertFloatX16# = insertFloatX16#

-- | Insert a scalar at the given position in a vector. 

insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#
insertDoubleX8# = insertDoubleX8#

-- | Add two vectors element-wise. 

plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
plusInt8X16# = plusInt8X16#

-- | Add two vectors element-wise. 

plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
plusInt16X8# = plusInt16X8#

-- | Add two vectors element-wise. 

plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
plusInt32X4# = plusInt32X4#

-- | Add two vectors element-wise. 

plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
plusInt64X2# = plusInt64X2#

-- | Add two vectors element-wise. 

plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
plusInt8X32# = plusInt8X32#

-- | Add two vectors element-wise. 

plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
plusInt16X16# = plusInt16X16#

-- | Add two vectors element-wise. 

plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
plusInt32X8# = plusInt32X8#

-- | Add two vectors element-wise. 

plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
plusInt64X4# = plusInt64X4#

-- | Add two vectors element-wise. 

plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
plusInt8X64# = plusInt8X64#

-- | Add two vectors element-wise. 

plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
plusInt16X32# = plusInt16X32#

-- | Add two vectors element-wise. 

plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
plusInt32X16# = plusInt32X16#

-- | Add two vectors element-wise. 

plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
plusInt64X8# = plusInt64X8#

-- | Add two vectors element-wise. 

plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
plusWord8X16# = plusWord8X16#

-- | Add two vectors element-wise. 

plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
plusWord16X8# = plusWord16X8#

-- | Add two vectors element-wise. 

plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
plusWord32X4# = plusWord32X4#

-- | Add two vectors element-wise. 

plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
plusWord64X2# = plusWord64X2#

-- | Add two vectors element-wise. 

plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
plusWord8X32# = plusWord8X32#

-- | Add two vectors element-wise. 

plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
plusWord16X16# = plusWord16X16#

-- | Add two vectors element-wise. 

plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
plusWord32X8# = plusWord32X8#

-- | Add two vectors element-wise. 

plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
plusWord64X4# = plusWord64X4#

-- | Add two vectors element-wise. 

plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
plusWord8X64# = plusWord8X64#

-- | Add two vectors element-wise. 

plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
plusWord16X32# = plusWord16X32#

-- | Add two vectors element-wise. 

plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
plusWord32X16# = plusWord32X16#

-- | Add two vectors element-wise. 

plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
plusWord64X8# = plusWord64X8#

-- | Add two vectors element-wise. 

plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
plusFloatX4# = plusFloatX4#

-- | Add two vectors element-wise. 

plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
plusDoubleX2# = plusDoubleX2#

-- | Add two vectors element-wise. 

plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
plusFloatX8# = plusFloatX8#

-- | Add two vectors element-wise. 

plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
plusDoubleX4# = plusDoubleX4#

-- | Add two vectors element-wise. 

plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
plusFloatX16# = plusFloatX16#

-- | Add two vectors element-wise. 

plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
plusDoubleX8# = plusDoubleX8#

-- | Subtract two vectors element-wise. 

minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
minusInt8X16# = minusInt8X16#

-- | Subtract two vectors element-wise. 

minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
minusInt16X8# = minusInt16X8#

-- | Subtract two vectors element-wise. 

minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
minusInt32X4# = minusInt32X4#

-- | Subtract two vectors element-wise. 

minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
minusInt64X2# = minusInt64X2#

-- | Subtract two vectors element-wise. 

minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
minusInt8X32# = minusInt8X32#

-- | Subtract two vectors element-wise. 

minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
minusInt16X16# = minusInt16X16#

-- | Subtract two vectors element-wise. 

minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
minusInt32X8# = minusInt32X8#

-- | Subtract two vectors element-wise. 

minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
minusInt64X4# = minusInt64X4#

-- | Subtract two vectors element-wise. 

minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
minusInt8X64# = minusInt8X64#

-- | Subtract two vectors element-wise. 

minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
minusInt16X32# = minusInt16X32#

-- | Subtract two vectors element-wise. 

minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
minusInt32X16# = minusInt32X16#

-- | Subtract two vectors element-wise. 

minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
minusInt64X8# = minusInt64X8#

-- | Subtract two vectors element-wise. 

minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
minusWord8X16# = minusWord8X16#

-- | Subtract two vectors element-wise. 

minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
minusWord16X8# = minusWord16X8#

-- | Subtract two vectors element-wise. 

minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
minusWord32X4# = minusWord32X4#

-- | Subtract two vectors element-wise. 

minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
minusWord64X2# = minusWord64X2#

-- | Subtract two vectors element-wise. 

minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
minusWord8X32# = minusWord8X32#

-- | Subtract two vectors element-wise. 

minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
minusWord16X16# = minusWord16X16#

-- | Subtract two vectors element-wise. 

minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
minusWord32X8# = minusWord32X8#

-- | Subtract two vectors element-wise. 

minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
minusWord64X4# = minusWord64X4#

-- | Subtract two vectors element-wise. 

minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
minusWord8X64# = minusWord8X64#

-- | Subtract two vectors element-wise. 

minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
minusWord16X32# = minusWord16X32#

-- | Subtract two vectors element-wise. 

minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
minusWord32X16# = minusWord32X16#

-- | Subtract two vectors element-wise. 

minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
minusWord64X8# = minusWord64X8#

-- | Subtract two vectors element-wise. 

minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
minusFloatX4# = minusFloatX4#

-- | Subtract two vectors element-wise. 

minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
minusDoubleX2# = minusDoubleX2#

-- | Subtract two vectors element-wise. 

minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
minusFloatX8# = minusFloatX8#

-- | Subtract two vectors element-wise. 

minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
minusDoubleX4# = minusDoubleX4#

-- | Subtract two vectors element-wise. 

minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
minusFloatX16# = minusFloatX16#

-- | Subtract two vectors element-wise. 

minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
minusDoubleX8# = minusDoubleX8#

-- | Multiply two vectors element-wise. 

timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
timesInt8X16# = timesInt8X16#

-- | Multiply two vectors element-wise. 

timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
timesInt16X8# = timesInt16X8#

-- | Multiply two vectors element-wise. 

timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
timesInt32X4# = timesInt32X4#

-- | Multiply two vectors element-wise. 

timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
timesInt64X2# = timesInt64X2#

-- | Multiply two vectors element-wise. 

timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
timesInt8X32# = timesInt8X32#

-- | Multiply two vectors element-wise. 

timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
timesInt16X16# = timesInt16X16#

-- | Multiply two vectors element-wise. 

timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
timesInt32X8# = timesInt32X8#

-- | Multiply two vectors element-wise. 

timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
timesInt64X4# = timesInt64X4#

-- | Multiply two vectors element-wise. 

timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
timesInt8X64# = timesInt8X64#

-- | Multiply two vectors element-wise. 

timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
timesInt16X32# = timesInt16X32#

-- | Multiply two vectors element-wise. 

timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
timesInt32X16# = timesInt32X16#

-- | Multiply two vectors element-wise. 

timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
timesInt64X8# = timesInt64X8#

-- | Multiply two vectors element-wise. 

timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
timesWord8X16# = timesWord8X16#

-- | Multiply two vectors element-wise. 

timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
timesWord16X8# = timesWord16X8#

-- | Multiply two vectors element-wise. 

timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
timesWord32X4# = timesWord32X4#

-- | Multiply two vectors element-wise. 

timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
timesWord64X2# = timesWord64X2#

-- | Multiply two vectors element-wise. 

timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
timesWord8X32# = timesWord8X32#

-- | Multiply two vectors element-wise. 

timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
timesWord16X16# = timesWord16X16#

-- | Multiply two vectors element-wise. 

timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
timesWord32X8# = timesWord32X8#

-- | Multiply two vectors element-wise. 

timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
timesWord64X4# = timesWord64X4#

-- | Multiply two vectors element-wise. 

timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
timesWord8X64# = timesWord8X64#

-- | Multiply two vectors element-wise. 

timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
timesWord16X32# = timesWord16X32#

-- | Multiply two vectors element-wise. 

timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
timesWord32X16# = timesWord32X16#

-- | Multiply two vectors element-wise. 

timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
timesWord64X8# = timesWord64X8#

-- | Multiply two vectors element-wise. 

timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
timesFloatX4# = timesFloatX4#

-- | Multiply two vectors element-wise. 

timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
timesDoubleX2# = timesDoubleX2#

-- | Multiply two vectors element-wise. 

timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
timesFloatX8# = timesFloatX8#

-- | Multiply two vectors element-wise. 

timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
timesDoubleX4# = timesDoubleX4#

-- | Multiply two vectors element-wise. 

timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
timesFloatX16# = timesFloatX16#

-- | Multiply two vectors element-wise. 

timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
timesDoubleX8# = timesDoubleX8#

-- | Divide two vectors element-wise. 

divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
divideFloatX4# = divideFloatX4#

-- | Divide two vectors element-wise. 

divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
divideDoubleX2# = divideDoubleX2#

-- | Divide two vectors element-wise. 

divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
divideFloatX8# = divideFloatX8#

-- | Divide two vectors element-wise. 

divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
divideDoubleX4# = divideDoubleX4#

-- | Divide two vectors element-wise. 

divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
divideFloatX16# = divideFloatX16#

-- | Divide two vectors element-wise. 

divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
divideDoubleX8# = divideDoubleX8#

-- | Rounds towards zero element-wise. 

quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
quotInt8X16# = quotInt8X16#

-- | Rounds towards zero element-wise. 

quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
quotInt16X8# = quotInt16X8#

-- | Rounds towards zero element-wise. 

quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
quotInt32X4# = quotInt32X4#

-- | Rounds towards zero element-wise. 

quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
quotInt64X2# = quotInt64X2#

-- | Rounds towards zero element-wise. 

quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
quotInt8X32# = quotInt8X32#

-- | Rounds towards zero element-wise. 

quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
quotInt16X16# = quotInt16X16#

-- | Rounds towards zero element-wise. 

quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
quotInt32X8# = quotInt32X8#

-- | Rounds towards zero element-wise. 

quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
quotInt64X4# = quotInt64X4#

-- | Rounds towards zero element-wise. 

quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
quotInt8X64# = quotInt8X64#

-- | Rounds towards zero element-wise. 

quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
quotInt16X32# = quotInt16X32#

-- | Rounds towards zero element-wise. 

quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
quotInt32X16# = quotInt32X16#

-- | Rounds towards zero element-wise. 

quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
quotInt64X8# = quotInt64X8#

-- | Rounds towards zero element-wise. 

quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
quotWord8X16# = quotWord8X16#

-- | Rounds towards zero element-wise. 

quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
quotWord16X8# = quotWord16X8#

-- | Rounds towards zero element-wise. 

quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
quotWord32X4# = quotWord32X4#

-- | Rounds towards zero element-wise. 

quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
quotWord64X2# = quotWord64X2#

-- | Rounds towards zero element-wise. 

quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
quotWord8X32# = quotWord8X32#

-- | Rounds towards zero element-wise. 

quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
quotWord16X16# = quotWord16X16#

-- | Rounds towards zero element-wise. 

quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
quotWord32X8# = quotWord32X8#

-- | Rounds towards zero element-wise. 

quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
quotWord64X4# = quotWord64X4#

-- | Rounds towards zero element-wise. 

quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
quotWord8X64# = quotWord8X64#

-- | Rounds towards zero element-wise. 

quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
quotWord16X32# = quotWord16X32#

-- | Rounds towards zero element-wise. 

quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
quotWord32X16# = quotWord32X16#

-- | Rounds towards zero element-wise. 

quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
quotWord64X8# = quotWord64X8#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
remInt8X16# = remInt8X16#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
remInt16X8# = remInt16X8#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
remInt32X4# = remInt32X4#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
remInt64X2# = remInt64X2#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
remInt8X32# = remInt8X32#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
remInt16X16# = remInt16X16#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
remInt32X8# = remInt32X8#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
remInt64X4# = remInt64X4#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
remInt8X64# = remInt8X64#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
remInt16X32# = remInt16X32#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
remInt32X16# = remInt32X16#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
remInt64X8# = remInt64X8#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
remWord8X16# = remWord8X16#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
remWord16X8# = remWord16X8#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
remWord32X4# = remWord32X4#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
remWord64X2# = remWord64X2#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
remWord8X32# = remWord8X32#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
remWord16X16# = remWord16X16#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
remWord32X8# = remWord32X8#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
remWord64X4# = remWord64X4#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
remWord8X64# = remWord8X64#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
remWord16X32# = remWord16X32#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
remWord32X16# = remWord32X16#

-- | Satisfies @(quot\# x y) times\# y plus\# (rem\# x y) == x@. 

remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
remWord64X8# = remWord64X8#

-- | Negate element-wise. 

negateInt8X16# :: Int8X16# -> Int8X16#
negateInt8X16# = negateInt8X16#

-- | Negate element-wise. 

negateInt16X8# :: Int16X8# -> Int16X8#
negateInt16X8# = negateInt16X8#

-- | Negate element-wise. 

negateInt32X4# :: Int32X4# -> Int32X4#
negateInt32X4# = negateInt32X4#

-- | Negate element-wise. 

negateInt64X2# :: Int64X2# -> Int64X2#
negateInt64X2# = negateInt64X2#

-- | Negate element-wise. 

negateInt8X32# :: Int8X32# -> Int8X32#
negateInt8X32# = negateInt8X32#

-- | Negate element-wise. 

negateInt16X16# :: Int16X16# -> Int16X16#
negateInt16X16# = negateInt16X16#

-- | Negate element-wise. 

negateInt32X8# :: Int32X8# -> Int32X8#
negateInt32X8# = negateInt32X8#

-- | Negate element-wise. 

negateInt64X4# :: Int64X4# -> Int64X4#
negateInt64X4# = negateInt64X4#

-- | Negate element-wise. 

negateInt8X64# :: Int8X64# -> Int8X64#
negateInt8X64# = negateInt8X64#

-- | Negate element-wise. 

negateInt16X32# :: Int16X32# -> Int16X32#
negateInt16X32# = negateInt16X32#

-- | Negate element-wise. 

negateInt32X16# :: Int32X16# -> Int32X16#
negateInt32X16# = negateInt32X16#

-- | Negate element-wise. 

negateInt64X8# :: Int64X8# -> Int64X8#
negateInt64X8# = negateInt64X8#

-- | Negate element-wise. 

negateFloatX4# :: FloatX4# -> FloatX4#
negateFloatX4# = negateFloatX4#

-- | Negate element-wise. 

negateDoubleX2# :: DoubleX2# -> DoubleX2#
negateDoubleX2# = negateDoubleX2#

-- | Negate element-wise. 

negateFloatX8# :: FloatX8# -> FloatX8#
negateFloatX8# = negateFloatX8#

-- | Negate element-wise. 

negateDoubleX4# :: DoubleX4# -> DoubleX4#
negateDoubleX4# = negateDoubleX4#

-- | Negate element-wise. 

negateFloatX16# :: FloatX16# -> FloatX16#
negateFloatX16# = negateFloatX16#

-- | Negate element-wise. 

negateDoubleX8# :: DoubleX8# -> DoubleX8#
negateDoubleX8# = negateDoubleX8#

-- | Read a vector from specified index of immutable array. 

indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#
indexInt8X16Array# = indexInt8X16Array#

-- | Read a vector from specified index of immutable array. 

indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#
indexInt16X8Array# = indexInt16X8Array#

-- | Read a vector from specified index of immutable array. 

indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#
indexInt32X4Array# = indexInt32X4Array#

-- | Read a vector from specified index of immutable array. 

indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#
indexInt64X2Array# = indexInt64X2Array#

-- | Read a vector from specified index of immutable array. 

indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#
indexInt8X32Array# = indexInt8X32Array#

-- | Read a vector from specified index of immutable array. 

indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#
indexInt16X16Array# = indexInt16X16Array#

-- | Read a vector from specified index of immutable array. 

indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#
indexInt32X8Array# = indexInt32X8Array#

-- | Read a vector from specified index of immutable array. 

indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#
indexInt64X4Array# = indexInt64X4Array#

-- | Read a vector from specified index of immutable array. 

indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#
indexInt8X64Array# = indexInt8X64Array#

-- | Read a vector from specified index of immutable array. 

indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#
indexInt16X32Array# = indexInt16X32Array#

-- | Read a vector from specified index of immutable array. 

indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#
indexInt32X16Array# = indexInt32X16Array#

-- | Read a vector from specified index of immutable array. 

indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#
indexInt64X8Array# = indexInt64X8Array#

-- | Read a vector from specified index of immutable array. 

indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#
indexWord8X16Array# = indexWord8X16Array#

-- | Read a vector from specified index of immutable array. 

indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#
indexWord16X8Array# = indexWord16X8Array#

-- | Read a vector from specified index of immutable array. 

indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#
indexWord32X4Array# = indexWord32X4Array#

-- | Read a vector from specified index of immutable array. 

indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#
indexWord64X2Array# = indexWord64X2Array#

-- | Read a vector from specified index of immutable array. 

indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#
indexWord8X32Array# = indexWord8X32Array#

-- | Read a vector from specified index of immutable array. 

indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#
indexWord16X16Array# = indexWord16X16Array#

-- | Read a vector from specified index of immutable array. 

indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#
indexWord32X8Array# = indexWord32X8Array#

-- | Read a vector from specified index of immutable array. 

indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#
indexWord64X4Array# = indexWord64X4Array#

-- | Read a vector from specified index of immutable array. 

indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#
indexWord8X64Array# = indexWord8X64Array#

-- | Read a vector from specified index of immutable array. 

indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#
indexWord16X32Array# = indexWord16X32Array#

-- | Read a vector from specified index of immutable array. 

indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#
indexWord32X16Array# = indexWord32X16Array#

-- | Read a vector from specified index of immutable array. 

indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#
indexWord64X8Array# = indexWord64X8Array#

-- | Read a vector from specified index of immutable array. 

indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#
indexFloatX4Array# = indexFloatX4Array#

-- | Read a vector from specified index of immutable array. 

indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#
indexDoubleX2Array# = indexDoubleX2Array#

-- | Read a vector from specified index of immutable array. 

indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#
indexFloatX8Array# = indexFloatX8Array#

-- | Read a vector from specified index of immutable array. 

indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#
indexDoubleX4Array# = indexDoubleX4Array#

-- | Read a vector from specified index of immutable array. 

indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#
indexFloatX16Array# = indexFloatX16Array#

-- | Read a vector from specified index of immutable array. 

indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#
indexDoubleX8Array# = indexDoubleX8Array#

-- | Read a vector from specified index of mutable array. 

readInt8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int8X16# #)
readInt8X16Array# = readInt8X16Array#

-- | Read a vector from specified index of mutable array. 

readInt16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int16X8# #)
readInt16X8Array# = readInt16X8Array#

-- | Read a vector from specified index of mutable array. 

readInt32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int32X4# #)
readInt32X4Array# = readInt32X4Array#

-- | Read a vector from specified index of mutable array. 

readInt64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int64X2# #)
readInt64X2Array# = readInt64X2Array#

-- | Read a vector from specified index of mutable array. 

readInt8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int8X32# #)
readInt8X32Array# = readInt8X32Array#

-- | Read a vector from specified index of mutable array. 

readInt16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int16X16# #)
readInt16X16Array# = readInt16X16Array#

-- | Read a vector from specified index of mutable array. 

readInt32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int32X8# #)
readInt32X8Array# = readInt32X8Array#

-- | Read a vector from specified index of mutable array. 

readInt64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int64X4# #)
readInt64X4Array# = readInt64X4Array#

-- | Read a vector from specified index of mutable array. 

readInt8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int8X64# #)
readInt8X64Array# = readInt8X64Array#

-- | Read a vector from specified index of mutable array. 

readInt16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int16X32# #)
readInt16X32Array# = readInt16X32Array#

-- | Read a vector from specified index of mutable array. 

readInt32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int32X16# #)
readInt32X16Array# = readInt32X16Array#

-- | Read a vector from specified index of mutable array. 

readInt64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int64X8# #)
readInt64X8Array# = readInt64X8Array#

-- | Read a vector from specified index of mutable array. 

readWord8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word8X16# #)
readWord8X16Array# = readWord8X16Array#

-- | Read a vector from specified index of mutable array. 

readWord16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word16X8# #)
readWord16X8Array# = readWord16X8Array#

-- | Read a vector from specified index of mutable array. 

readWord32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word32X4# #)
readWord32X4Array# = readWord32X4Array#

-- | Read a vector from specified index of mutable array. 

readWord64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word64X2# #)
readWord64X2Array# = readWord64X2Array#

-- | Read a vector from specified index of mutable array. 

readWord8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word8X32# #)
readWord8X32Array# = readWord8X32Array#

-- | Read a vector from specified index of mutable array. 

readWord16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word16X16# #)
readWord16X16Array# = readWord16X16Array#

-- | Read a vector from specified index of mutable array. 

readWord32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word32X8# #)
readWord32X8Array# = readWord32X8Array#

-- | Read a vector from specified index of mutable array. 

readWord64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word64X4# #)
readWord64X4Array# = readWord64X4Array#

-- | Read a vector from specified index of mutable array. 

readWord8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word8X64# #)
readWord8X64Array# = readWord8X64Array#

-- | Read a vector from specified index of mutable array. 

readWord16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word16X32# #)
readWord16X32Array# = readWord16X32Array#

-- | Read a vector from specified index of mutable array. 

readWord32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word32X16# #)
readWord32X16Array# = readWord32X16Array#

-- | Read a vector from specified index of mutable array. 

readWord64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word64X8# #)
readWord64X8Array# = readWord64X8Array#

-- | Read a vector from specified index of mutable array. 

readFloatX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,FloatX4# #)
readFloatX4Array# = readFloatX4Array#

-- | Read a vector from specified index of mutable array. 

readDoubleX2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,DoubleX2# #)
readDoubleX2Array# = readDoubleX2Array#

-- | Read a vector from specified index of mutable array. 

readFloatX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,FloatX8# #)
readFloatX8Array# = readFloatX8Array#

-- | Read a vector from specified index of mutable array. 

readDoubleX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,DoubleX4# #)
readDoubleX4Array# = readDoubleX4Array#

-- | Read a vector from specified index of mutable array. 

readFloatX16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,FloatX16# #)
readFloatX16Array# = readFloatX16Array#

-- | Read a vector from specified index of mutable array. 

readDoubleX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,DoubleX8# #)
readDoubleX8Array# = readDoubleX8Array#

-- | Write a vector to specified index of mutable array. 

writeInt8X16Array# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s
writeInt8X16Array# = writeInt8X16Array#

-- | Write a vector to specified index of mutable array. 

writeInt16X8Array# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s
writeInt16X8Array# = writeInt16X8Array#

-- | Write a vector to specified index of mutable array. 

writeInt32X4Array# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s
writeInt32X4Array# = writeInt32X4Array#

-- | Write a vector to specified index of mutable array. 

writeInt64X2Array# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s
writeInt64X2Array# = writeInt64X2Array#

-- | Write a vector to specified index of mutable array. 

writeInt8X32Array# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s
writeInt8X32Array# = writeInt8X32Array#

-- | Write a vector to specified index of mutable array. 

writeInt16X16Array# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s
writeInt16X16Array# = writeInt16X16Array#

-- | Write a vector to specified index of mutable array. 

writeInt32X8Array# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s
writeInt32X8Array# = writeInt32X8Array#

-- | Write a vector to specified index of mutable array. 

writeInt64X4Array# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s
writeInt64X4Array# = writeInt64X4Array#

-- | Write a vector to specified index of mutable array. 

writeInt8X64Array# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s
writeInt8X64Array# = writeInt8X64Array#

-- | Write a vector to specified index of mutable array. 

writeInt16X32Array# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s
writeInt16X32Array# = writeInt16X32Array#

-- | Write a vector to specified index of mutable array. 

writeInt32X16Array# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s
writeInt32X16Array# = writeInt32X16Array#

-- | Write a vector to specified index of mutable array. 

writeInt64X8Array# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s
writeInt64X8Array# = writeInt64X8Array#

-- | Write a vector to specified index of mutable array. 

writeWord8X16Array# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s
writeWord8X16Array# = writeWord8X16Array#

-- | Write a vector to specified index of mutable array. 

writeWord16X8Array# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s
writeWord16X8Array# = writeWord16X8Array#

-- | Write a vector to specified index of mutable array. 

writeWord32X4Array# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s
writeWord32X4Array# = writeWord32X4Array#

-- | Write a vector to specified index of mutable array. 

writeWord64X2Array# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s
writeWord64X2Array# = writeWord64X2Array#

-- | Write a vector to specified index of mutable array. 

writeWord8X32Array# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s
writeWord8X32Array# = writeWord8X32Array#

-- | Write a vector to specified index of mutable array. 

writeWord16X16Array# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s
writeWord16X16Array# = writeWord16X16Array#

-- | Write a vector to specified index of mutable array. 

writeWord32X8Array# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s
writeWord32X8Array# = writeWord32X8Array#

-- | Write a vector to specified index of mutable array. 

writeWord64X4Array# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s
writeWord64X4Array# = writeWord64X4Array#

-- | Write a vector to specified index of mutable array. 

writeWord8X64Array# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s
writeWord8X64Array# = writeWord8X64Array#

-- | Write a vector to specified index of mutable array. 

writeWord16X32Array# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s
writeWord16X32Array# = writeWord16X32Array#

-- | Write a vector to specified index of mutable array. 

writeWord32X16Array# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s
writeWord32X16Array# = writeWord32X16Array#

-- | Write a vector to specified index of mutable array. 

writeWord64X8Array# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s
writeWord64X8Array# = writeWord64X8Array#

-- | Write a vector to specified index of mutable array. 

writeFloatX4Array# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s
writeFloatX4Array# = writeFloatX4Array#

-- | Write a vector to specified index of mutable array. 

writeDoubleX2Array# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s
writeDoubleX2Array# = writeDoubleX2Array#

-- | Write a vector to specified index of mutable array. 

writeFloatX8Array# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s
writeFloatX8Array# = writeFloatX8Array#

-- | Write a vector to specified index of mutable array. 

writeDoubleX4Array# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s
writeDoubleX4Array# = writeDoubleX4Array#

-- | Write a vector to specified index of mutable array. 

writeFloatX16Array# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s
writeFloatX16Array# = writeFloatX16Array#

-- | Write a vector to specified index of mutable array. 

writeDoubleX8Array# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s
writeDoubleX8Array# = writeDoubleX8Array#

-- | Reads vector; offset in bytes. 

indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#
indexInt8X16OffAddr# = indexInt8X16OffAddr#

-- | Reads vector; offset in bytes. 

indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#
indexInt16X8OffAddr# = indexInt16X8OffAddr#

-- | Reads vector; offset in bytes. 

indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#
indexInt32X4OffAddr# = indexInt32X4OffAddr#

-- | Reads vector; offset in bytes. 

indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#
indexInt64X2OffAddr# = indexInt64X2OffAddr#

-- | Reads vector; offset in bytes. 

indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#
indexInt8X32OffAddr# = indexInt8X32OffAddr#

-- | Reads vector; offset in bytes. 

indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#
indexInt16X16OffAddr# = indexInt16X16OffAddr#

-- | Reads vector; offset in bytes. 

indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#
indexInt32X8OffAddr# = indexInt32X8OffAddr#

-- | Reads vector; offset in bytes. 

indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#
indexInt64X4OffAddr# = indexInt64X4OffAddr#

-- | Reads vector; offset in bytes. 

indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#
indexInt8X64OffAddr# = indexInt8X64OffAddr#

-- | Reads vector; offset in bytes. 

indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#
indexInt16X32OffAddr# = indexInt16X32OffAddr#

-- | Reads vector; offset in bytes. 

indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#
indexInt32X16OffAddr# = indexInt32X16OffAddr#

-- | Reads vector; offset in bytes. 

indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#
indexInt64X8OffAddr# = indexInt64X8OffAddr#

-- | Reads vector; offset in bytes. 

indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#
indexWord8X16OffAddr# = indexWord8X16OffAddr#

-- | Reads vector; offset in bytes. 

indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#
indexWord16X8OffAddr# = indexWord16X8OffAddr#

-- | Reads vector; offset in bytes. 

indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#
indexWord32X4OffAddr# = indexWord32X4OffAddr#

-- | Reads vector; offset in bytes. 

indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#
indexWord64X2OffAddr# = indexWord64X2OffAddr#

-- | Reads vector; offset in bytes. 

indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#
indexWord8X32OffAddr# = indexWord8X32OffAddr#

-- | Reads vector; offset in bytes. 

indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#
indexWord16X16OffAddr# = indexWord16X16OffAddr#

-- | Reads vector; offset in bytes. 

indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#
indexWord32X8OffAddr# = indexWord32X8OffAddr#

-- | Reads vector; offset in bytes. 

indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#
indexWord64X4OffAddr# = indexWord64X4OffAddr#

-- | Reads vector; offset in bytes. 

indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#
indexWord8X64OffAddr# = indexWord8X64OffAddr#

-- | Reads vector; offset in bytes. 

indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#
indexWord16X32OffAddr# = indexWord16X32OffAddr#

-- | Reads vector; offset in bytes. 

indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#
indexWord32X16OffAddr# = indexWord32X16OffAddr#

-- | Reads vector; offset in bytes. 

indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#
indexWord64X8OffAddr# = indexWord64X8OffAddr#

-- | Reads vector; offset in bytes. 

indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#
indexFloatX4OffAddr# = indexFloatX4OffAddr#

-- | Reads vector; offset in bytes. 

indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#
indexDoubleX2OffAddr# = indexDoubleX2OffAddr#

-- | Reads vector; offset in bytes. 

indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#
indexFloatX8OffAddr# = indexFloatX8OffAddr#

-- | Reads vector; offset in bytes. 

indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#
indexDoubleX4OffAddr# = indexDoubleX4OffAddr#

-- | Reads vector; offset in bytes. 

indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#
indexFloatX16OffAddr# = indexFloatX16OffAddr#

-- | Reads vector; offset in bytes. 

indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#
indexDoubleX8OffAddr# = indexDoubleX8OffAddr#

-- | Reads vector; offset in bytes. 

readInt8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int8X16# #)
readInt8X16OffAddr# = readInt8X16OffAddr#

-- | Reads vector; offset in bytes. 

readInt16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int16X8# #)
readInt16X8OffAddr# = readInt16X8OffAddr#

-- | Reads vector; offset in bytes. 

readInt32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int32X4# #)
readInt32X4OffAddr# = readInt32X4OffAddr#

-- | Reads vector; offset in bytes. 

readInt64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int64X2# #)
readInt64X2OffAddr# = readInt64X2OffAddr#

-- | Reads vector; offset in bytes. 

readInt8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int8X32# #)
readInt8X32OffAddr# = readInt8X32OffAddr#

-- | Reads vector; offset in bytes. 

readInt16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int16X16# #)
readInt16X16OffAddr# = readInt16X16OffAddr#

-- | Reads vector; offset in bytes. 

readInt32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int32X8# #)
readInt32X8OffAddr# = readInt32X8OffAddr#

-- | Reads vector; offset in bytes. 

readInt64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int64X4# #)
readInt64X4OffAddr# = readInt64X4OffAddr#

-- | Reads vector; offset in bytes. 

readInt8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int8X64# #)
readInt8X64OffAddr# = readInt8X64OffAddr#

-- | Reads vector; offset in bytes. 

readInt16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int16X32# #)
readInt16X32OffAddr# = readInt16X32OffAddr#

-- | Reads vector; offset in bytes. 

readInt32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int32X16# #)
readInt32X16OffAddr# = readInt32X16OffAddr#

-- | Reads vector; offset in bytes. 

readInt64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int64X8# #)
readInt64X8OffAddr# = readInt64X8OffAddr#

-- | Reads vector; offset in bytes. 

readWord8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word8X16# #)
readWord8X16OffAddr# = readWord8X16OffAddr#

-- | Reads vector; offset in bytes. 

readWord16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word16X8# #)
readWord16X8OffAddr# = readWord16X8OffAddr#

-- | Reads vector; offset in bytes. 

readWord32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word32X4# #)
readWord32X4OffAddr# = readWord32X4OffAddr#

-- | Reads vector; offset in bytes. 

readWord64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word64X2# #)
readWord64X2OffAddr# = readWord64X2OffAddr#

-- | Reads vector; offset in bytes. 

readWord8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word8X32# #)
readWord8X32OffAddr# = readWord8X32OffAddr#

-- | Reads vector; offset in bytes. 

readWord16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word16X16# #)
readWord16X16OffAddr# = readWord16X16OffAddr#

-- | Reads vector; offset in bytes. 

readWord32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word32X8# #)
readWord32X8OffAddr# = readWord32X8OffAddr#

-- | Reads vector; offset in bytes. 

readWord64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word64X4# #)
readWord64X4OffAddr# = readWord64X4OffAddr#

-- | Reads vector; offset in bytes. 

readWord8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word8X64# #)
readWord8X64OffAddr# = readWord8X64OffAddr#

-- | Reads vector; offset in bytes. 

readWord16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word16X32# #)
readWord16X32OffAddr# = readWord16X32OffAddr#

-- | Reads vector; offset in bytes. 

readWord32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word32X16# #)
readWord32X16OffAddr# = readWord32X16OffAddr#

-- | Reads vector; offset in bytes. 

readWord64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word64X8# #)
readWord64X8OffAddr# = readWord64X8OffAddr#

-- | Reads vector; offset in bytes. 

readFloatX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,FloatX4# #)
readFloatX4OffAddr# = readFloatX4OffAddr#

-- | Reads vector; offset in bytes. 

readDoubleX2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,DoubleX2# #)
readDoubleX2OffAddr# = readDoubleX2OffAddr#

-- | Reads vector; offset in bytes. 

readFloatX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,FloatX8# #)
readFloatX8OffAddr# = readFloatX8OffAddr#

-- | Reads vector; offset in bytes. 

readDoubleX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,DoubleX4# #)
readDoubleX4OffAddr# = readDoubleX4OffAddr#

-- | Reads vector; offset in bytes. 

readFloatX16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,FloatX16# #)
readFloatX16OffAddr# = readFloatX16OffAddr#

-- | Reads vector; offset in bytes. 

readDoubleX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,DoubleX8# #)
readDoubleX8OffAddr# = readDoubleX8OffAddr#

-- | Write vector; offset in bytes. 

writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s
writeInt8X16OffAddr# = writeInt8X16OffAddr#

-- | Write vector; offset in bytes. 

writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s
writeInt16X8OffAddr# = writeInt16X8OffAddr#

-- | Write vector; offset in bytes. 

writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s
writeInt32X4OffAddr# = writeInt32X4OffAddr#

-- | Write vector; offset in bytes. 

writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s
writeInt64X2OffAddr# = writeInt64X2OffAddr#

-- | Write vector; offset in bytes. 

writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s
writeInt8X32OffAddr# = writeInt8X32OffAddr#

-- | Write vector; offset in bytes. 

writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s
writeInt16X16OffAddr# = writeInt16X16OffAddr#

-- | Write vector; offset in bytes. 

writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s
writeInt32X8OffAddr# = writeInt32X8OffAddr#

-- | Write vector; offset in bytes. 

writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s
writeInt64X4OffAddr# = writeInt64X4OffAddr#

-- | Write vector; offset in bytes. 

writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s
writeInt8X64OffAddr# = writeInt8X64OffAddr#

-- | Write vector; offset in bytes. 

writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s
writeInt16X32OffAddr# = writeInt16X32OffAddr#

-- | Write vector; offset in bytes. 

writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s
writeInt32X16OffAddr# = writeInt32X16OffAddr#

-- | Write vector; offset in bytes. 

writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s
writeInt64X8OffAddr# = writeInt64X8OffAddr#

-- | Write vector; offset in bytes. 

writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s
writeWord8X16OffAddr# = writeWord8X16OffAddr#

-- | Write vector; offset in bytes. 

writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s
writeWord16X8OffAddr# = writeWord16X8OffAddr#

-- | Write vector; offset in bytes. 

writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s
writeWord32X4OffAddr# = writeWord32X4OffAddr#

-- | Write vector; offset in bytes. 

writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s
writeWord64X2OffAddr# = writeWord64X2OffAddr#

-- | Write vector; offset in bytes. 

writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s
writeWord8X32OffAddr# = writeWord8X32OffAddr#

-- | Write vector; offset in bytes. 

writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s
writeWord16X16OffAddr# = writeWord16X16OffAddr#

-- | Write vector; offset in bytes. 

writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s
writeWord32X8OffAddr# = writeWord32X8OffAddr#

-- | Write vector; offset in bytes. 

writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s
writeWord64X4OffAddr# = writeWord64X4OffAddr#

-- | Write vector; offset in bytes. 

writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s
writeWord8X64OffAddr# = writeWord8X64OffAddr#

-- | Write vector; offset in bytes. 

writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s
writeWord16X32OffAddr# = writeWord16X32OffAddr#

-- | Write vector; offset in bytes. 

writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s
writeWord32X16OffAddr# = writeWord32X16OffAddr#

-- | Write vector; offset in bytes. 

writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s
writeWord64X8OffAddr# = writeWord64X8OffAddr#

-- | Write vector; offset in bytes. 

writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s
writeFloatX4OffAddr# = writeFloatX4OffAddr#

-- | Write vector; offset in bytes. 

writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s
writeDoubleX2OffAddr# = writeDoubleX2OffAddr#

-- | Write vector; offset in bytes. 

writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s
writeFloatX8OffAddr# = writeFloatX8OffAddr#

-- | Write vector; offset in bytes. 

writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s
writeDoubleX4OffAddr# = writeDoubleX4OffAddr#

-- | Write vector; offset in bytes. 

writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s
writeFloatX16OffAddr# = writeFloatX16OffAddr#

-- | Write vector; offset in bytes. 

writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s
writeDoubleX8OffAddr# = writeDoubleX8OffAddr#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#
indexInt8ArrayAsInt8X16# = indexInt8ArrayAsInt8X16#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#
indexInt16ArrayAsInt16X8# = indexInt16ArrayAsInt16X8#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#
indexInt32ArrayAsInt32X4# = indexInt32ArrayAsInt32X4#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#
indexInt64ArrayAsInt64X2# = indexInt64ArrayAsInt64X2#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#
indexInt8ArrayAsInt8X32# = indexInt8ArrayAsInt8X32#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#
indexInt16ArrayAsInt16X16# = indexInt16ArrayAsInt16X16#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#
indexInt32ArrayAsInt32X8# = indexInt32ArrayAsInt32X8#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#
indexInt64ArrayAsInt64X4# = indexInt64ArrayAsInt64X4#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#
indexInt8ArrayAsInt8X64# = indexInt8ArrayAsInt8X64#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#
indexInt16ArrayAsInt16X32# = indexInt16ArrayAsInt16X32#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#
indexInt32ArrayAsInt32X16# = indexInt32ArrayAsInt32X16#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#
indexInt64ArrayAsInt64X8# = indexInt64ArrayAsInt64X8#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#
indexWord8ArrayAsWord8X16# = indexWord8ArrayAsWord8X16#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#
indexWord16ArrayAsWord16X8# = indexWord16ArrayAsWord16X8#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#
indexWord32ArrayAsWord32X4# = indexWord32ArrayAsWord32X4#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#
indexWord64ArrayAsWord64X2# = indexWord64ArrayAsWord64X2#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#
indexWord8ArrayAsWord8X32# = indexWord8ArrayAsWord8X32#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#
indexWord16ArrayAsWord16X16# = indexWord16ArrayAsWord16X16#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#
indexWord32ArrayAsWord32X8# = indexWord32ArrayAsWord32X8#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#
indexWord64ArrayAsWord64X4# = indexWord64ArrayAsWord64X4#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#
indexWord8ArrayAsWord8X64# = indexWord8ArrayAsWord8X64#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#
indexWord16ArrayAsWord16X32# = indexWord16ArrayAsWord16X32#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#
indexWord32ArrayAsWord32X16# = indexWord32ArrayAsWord32X16#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#
indexWord64ArrayAsWord64X8# = indexWord64ArrayAsWord64X8#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#
indexFloatArrayAsFloatX4# = indexFloatArrayAsFloatX4#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#
indexDoubleArrayAsDoubleX2# = indexDoubleArrayAsDoubleX2#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#
indexFloatArrayAsFloatX8# = indexFloatArrayAsFloatX8#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#
indexDoubleArrayAsDoubleX4# = indexDoubleArrayAsDoubleX4#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#
indexFloatArrayAsFloatX16# = indexFloatArrayAsFloatX16#

-- | Read a vector from specified index of immutable array of scalars; offset is in scalar elements. 

indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#
indexDoubleArrayAsDoubleX8# = indexDoubleArrayAsDoubleX8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int8X16# #)
readInt8ArrayAsInt8X16# = readInt8ArrayAsInt8X16#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int16X8# #)
readInt16ArrayAsInt16X8# = readInt16ArrayAsInt16X8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int32X4# #)
readInt32ArrayAsInt32X4# = readInt32ArrayAsInt32X4#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int64X2# #)
readInt64ArrayAsInt64X2# = readInt64ArrayAsInt64X2#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int8X32# #)
readInt8ArrayAsInt8X32# = readInt8ArrayAsInt8X32#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int16X16# #)
readInt16ArrayAsInt16X16# = readInt16ArrayAsInt16X16#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int32X8# #)
readInt32ArrayAsInt32X8# = readInt32ArrayAsInt32X8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int64X4# #)
readInt64ArrayAsInt64X4# = readInt64ArrayAsInt64X4#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int8X64# #)
readInt8ArrayAsInt8X64# = readInt8ArrayAsInt8X64#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int16X32# #)
readInt16ArrayAsInt16X32# = readInt16ArrayAsInt16X32#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int32X16# #)
readInt32ArrayAsInt32X16# = readInt32ArrayAsInt32X16#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int64X8# #)
readInt64ArrayAsInt64X8# = readInt64ArrayAsInt64X8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word8X16# #)
readWord8ArrayAsWord8X16# = readWord8ArrayAsWord8X16#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word16X8# #)
readWord16ArrayAsWord16X8# = readWord16ArrayAsWord16X8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word32X4# #)
readWord32ArrayAsWord32X4# = readWord32ArrayAsWord32X4#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word64X2# #)
readWord64ArrayAsWord64X2# = readWord64ArrayAsWord64X2#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word8X32# #)
readWord8ArrayAsWord8X32# = readWord8ArrayAsWord8X32#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word16X16# #)
readWord16ArrayAsWord16X16# = readWord16ArrayAsWord16X16#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word32X8# #)
readWord32ArrayAsWord32X8# = readWord32ArrayAsWord32X8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word64X4# #)
readWord64ArrayAsWord64X4# = readWord64ArrayAsWord64X4#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word8X64# #)
readWord8ArrayAsWord8X64# = readWord8ArrayAsWord8X64#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word16X32# #)
readWord16ArrayAsWord16X32# = readWord16ArrayAsWord16X32#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word32X16# #)
readWord32ArrayAsWord32X16# = readWord32ArrayAsWord32X16#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word64X8# #)
readWord64ArrayAsWord64X8# = readWord64ArrayAsWord64X8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,FloatX4# #)
readFloatArrayAsFloatX4# = readFloatArrayAsFloatX4#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,DoubleX2# #)
readDoubleArrayAsDoubleX2# = readDoubleArrayAsDoubleX2#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,FloatX8# #)
readFloatArrayAsFloatX8# = readFloatArrayAsFloatX8#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,DoubleX4# #)
readDoubleArrayAsDoubleX4# = readDoubleArrayAsDoubleX4#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,FloatX16# #)
readFloatArrayAsFloatX16# = readFloatArrayAsFloatX16#

-- | Read a vector from specified index of mutable array of scalars; offset is in scalar elements. 

readDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,DoubleX8# #)
readDoubleArrayAsDoubleX8# = readDoubleArrayAsDoubleX8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s
writeInt8ArrayAsInt8X16# = writeInt8ArrayAsInt8X16#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s
writeInt16ArrayAsInt16X8# = writeInt16ArrayAsInt16X8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s
writeInt32ArrayAsInt32X4# = writeInt32ArrayAsInt32X4#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s
writeInt64ArrayAsInt64X2# = writeInt64ArrayAsInt64X2#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s
writeInt8ArrayAsInt8X32# = writeInt8ArrayAsInt8X32#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s
writeInt16ArrayAsInt16X16# = writeInt16ArrayAsInt16X16#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s
writeInt32ArrayAsInt32X8# = writeInt32ArrayAsInt32X8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s
writeInt64ArrayAsInt64X4# = writeInt64ArrayAsInt64X4#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s
writeInt8ArrayAsInt8X64# = writeInt8ArrayAsInt8X64#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s
writeInt16ArrayAsInt16X32# = writeInt16ArrayAsInt16X32#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s
writeInt32ArrayAsInt32X16# = writeInt32ArrayAsInt32X16#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s
writeInt64ArrayAsInt64X8# = writeInt64ArrayAsInt64X8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s
writeWord8ArrayAsWord8X16# = writeWord8ArrayAsWord8X16#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s
writeWord16ArrayAsWord16X8# = writeWord16ArrayAsWord16X8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s
writeWord32ArrayAsWord32X4# = writeWord32ArrayAsWord32X4#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s
writeWord64ArrayAsWord64X2# = writeWord64ArrayAsWord64X2#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s
writeWord8ArrayAsWord8X32# = writeWord8ArrayAsWord8X32#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s
writeWord16ArrayAsWord16X16# = writeWord16ArrayAsWord16X16#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s
writeWord32ArrayAsWord32X8# = writeWord32ArrayAsWord32X8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s
writeWord64ArrayAsWord64X4# = writeWord64ArrayAsWord64X4#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s
writeWord8ArrayAsWord8X64# = writeWord8ArrayAsWord8X64#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s
writeWord16ArrayAsWord16X32# = writeWord16ArrayAsWord16X32#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s
writeWord32ArrayAsWord32X16# = writeWord32ArrayAsWord32X16#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s
writeWord64ArrayAsWord64X8# = writeWord64ArrayAsWord64X8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s
writeFloatArrayAsFloatX4# = writeFloatArrayAsFloatX4#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s
writeDoubleArrayAsDoubleX2# = writeDoubleArrayAsDoubleX2#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s
writeFloatArrayAsFloatX8# = writeFloatArrayAsFloatX8#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s
writeDoubleArrayAsDoubleX4# = writeDoubleArrayAsDoubleX4#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s
writeFloatArrayAsFloatX16# = writeFloatArrayAsFloatX16#

-- | Write a vector to specified index of mutable array of scalars; offset is in scalar elements. 

writeDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s
writeDoubleArrayAsDoubleX8# = writeDoubleArrayAsDoubleX8#

-- | Reads vector; offset in scalar elements. 

indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#
indexInt8OffAddrAsInt8X16# = indexInt8OffAddrAsInt8X16#

-- | Reads vector; offset in scalar elements. 

indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#
indexInt16OffAddrAsInt16X8# = indexInt16OffAddrAsInt16X8#

-- | Reads vector; offset in scalar elements. 

indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#
indexInt32OffAddrAsInt32X4# = indexInt32OffAddrAsInt32X4#

-- | Reads vector; offset in scalar elements. 

indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#
indexInt64OffAddrAsInt64X2# = indexInt64OffAddrAsInt64X2#

-- | Reads vector; offset in scalar elements. 

indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#
indexInt8OffAddrAsInt8X32# = indexInt8OffAddrAsInt8X32#

-- | Reads vector; offset in scalar elements. 

indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#
indexInt16OffAddrAsInt16X16# = indexInt16OffAddrAsInt16X16#

-- | Reads vector; offset in scalar elements. 

indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#
indexInt32OffAddrAsInt32X8# = indexInt32OffAddrAsInt32X8#

-- | Reads vector; offset in scalar elements. 

indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#
indexInt64OffAddrAsInt64X4# = indexInt64OffAddrAsInt64X4#

-- | Reads vector; offset in scalar elements. 

indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#
indexInt8OffAddrAsInt8X64# = indexInt8OffAddrAsInt8X64#

-- | Reads vector; offset in scalar elements. 

indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#
indexInt16OffAddrAsInt16X32# = indexInt16OffAddrAsInt16X32#

-- | Reads vector; offset in scalar elements. 

indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#
indexInt32OffAddrAsInt32X16# = indexInt32OffAddrAsInt32X16#

-- | Reads vector; offset in scalar elements. 

indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#
indexInt64OffAddrAsInt64X8# = indexInt64OffAddrAsInt64X8#

-- | Reads vector; offset in scalar elements. 

indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#
indexWord8OffAddrAsWord8X16# = indexWord8OffAddrAsWord8X16#

-- | Reads vector; offset in scalar elements. 

indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#
indexWord16OffAddrAsWord16X8# = indexWord16OffAddrAsWord16X8#

-- | Reads vector; offset in scalar elements. 

indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#
indexWord32OffAddrAsWord32X4# = indexWord32OffAddrAsWord32X4#

-- | Reads vector; offset in scalar elements. 

indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#
indexWord64OffAddrAsWord64X2# = indexWord64OffAddrAsWord64X2#

-- | Reads vector; offset in scalar elements. 

indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#
indexWord8OffAddrAsWord8X32# = indexWord8OffAddrAsWord8X32#

-- | Reads vector; offset in scalar elements. 

indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#
indexWord16OffAddrAsWord16X16# = indexWord16OffAddrAsWord16X16#

-- | Reads vector; offset in scalar elements. 

indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#
indexWord32OffAddrAsWord32X8# = indexWord32OffAddrAsWord32X8#

-- | Reads vector; offset in scalar elements. 

indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#
indexWord64OffAddrAsWord64X4# = indexWord64OffAddrAsWord64X4#

-- | Reads vector; offset in scalar elements. 

indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#
indexWord8OffAddrAsWord8X64# = indexWord8OffAddrAsWord8X64#

-- | Reads vector; offset in scalar elements. 

indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#
indexWord16OffAddrAsWord16X32# = indexWord16OffAddrAsWord16X32#

-- | Reads vector; offset in scalar elements. 

indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#
indexWord32OffAddrAsWord32X16# = indexWord32OffAddrAsWord32X16#

-- | Reads vector; offset in scalar elements. 

indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#
indexWord64OffAddrAsWord64X8# = indexWord64OffAddrAsWord64X8#

-- | Reads vector; offset in scalar elements. 

indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#
indexFloatOffAddrAsFloatX4# = indexFloatOffAddrAsFloatX4#

-- | Reads vector; offset in scalar elements. 

indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#
indexDoubleOffAddrAsDoubleX2# = indexDoubleOffAddrAsDoubleX2#

-- | Reads vector; offset in scalar elements. 

indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#
indexFloatOffAddrAsFloatX8# = indexFloatOffAddrAsFloatX8#

-- | Reads vector; offset in scalar elements. 

indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#
indexDoubleOffAddrAsDoubleX4# = indexDoubleOffAddrAsDoubleX4#

-- | Reads vector; offset in scalar elements. 

indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#
indexFloatOffAddrAsFloatX16# = indexFloatOffAddrAsFloatX16#

-- | Reads vector; offset in scalar elements. 

indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#
indexDoubleOffAddrAsDoubleX8# = indexDoubleOffAddrAsDoubleX8#

-- | Reads vector; offset in scalar elements. 

readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# s -> (# State# s,Int8X16# #)
readInt8OffAddrAsInt8X16# = readInt8OffAddrAsInt8X16#

-- | Reads vector; offset in scalar elements. 

readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# s -> (# State# s,Int16X8# #)
readInt16OffAddrAsInt16X8# = readInt16OffAddrAsInt16X8#

-- | Reads vector; offset in scalar elements. 

readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# s -> (# State# s,Int32X4# #)
readInt32OffAddrAsInt32X4# = readInt32OffAddrAsInt32X4#

-- | Reads vector; offset in scalar elements. 

readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# s -> (# State# s,Int64X2# #)
readInt64OffAddrAsInt64X2# = readInt64OffAddrAsInt64X2#

-- | Reads vector; offset in scalar elements. 

readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# s -> (# State# s,Int8X32# #)
readInt8OffAddrAsInt8X32# = readInt8OffAddrAsInt8X32#

-- | Reads vector; offset in scalar elements. 

readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# s -> (# State# s,Int16X16# #)
readInt16OffAddrAsInt16X16# = readInt16OffAddrAsInt16X16#

-- | Reads vector; offset in scalar elements. 

readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# s -> (# State# s,Int32X8# #)
readInt32OffAddrAsInt32X8# = readInt32OffAddrAsInt32X8#

-- | Reads vector; offset in scalar elements. 

readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# s -> (# State# s,Int64X4# #)
readInt64OffAddrAsInt64X4# = readInt64OffAddrAsInt64X4#

-- | Reads vector; offset in scalar elements. 

readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# s -> (# State# s,Int8X64# #)
readInt8OffAddrAsInt8X64# = readInt8OffAddrAsInt8X64#

-- | Reads vector; offset in scalar elements. 

readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# s -> (# State# s,Int16X32# #)
readInt16OffAddrAsInt16X32# = readInt16OffAddrAsInt16X32#

-- | Reads vector; offset in scalar elements. 

readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# s -> (# State# s,Int32X16# #)
readInt32OffAddrAsInt32X16# = readInt32OffAddrAsInt32X16#

-- | Reads vector; offset in scalar elements. 

readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# s -> (# State# s,Int64X8# #)
readInt64OffAddrAsInt64X8# = readInt64OffAddrAsInt64X8#

-- | Reads vector; offset in scalar elements. 

readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# s -> (# State# s,Word8X16# #)
readWord8OffAddrAsWord8X16# = readWord8OffAddrAsWord8X16#

-- | Reads vector; offset in scalar elements. 

readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# s -> (# State# s,Word16X8# #)
readWord16OffAddrAsWord16X8# = readWord16OffAddrAsWord16X8#

-- | Reads vector; offset in scalar elements. 

readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# s -> (# State# s,Word32X4# #)
readWord32OffAddrAsWord32X4# = readWord32OffAddrAsWord32X4#

-- | Reads vector; offset in scalar elements. 

readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# s -> (# State# s,Word64X2# #)
readWord64OffAddrAsWord64X2# = readWord64OffAddrAsWord64X2#

-- | Reads vector; offset in scalar elements. 

readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# s -> (# State# s,Word8X32# #)
readWord8OffAddrAsWord8X32# = readWord8OffAddrAsWord8X32#

-- | Reads vector; offset in scalar elements. 

readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# s -> (# State# s,Word16X16# #)
readWord16OffAddrAsWord16X16# = readWord16OffAddrAsWord16X16#

-- | Reads vector; offset in scalar elements. 

readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# s -> (# State# s,Word32X8# #)
readWord32OffAddrAsWord32X8# = readWord32OffAddrAsWord32X8#

-- | Reads vector; offset in scalar elements. 

readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# s -> (# State# s,Word64X4# #)
readWord64OffAddrAsWord64X4# = readWord64OffAddrAsWord64X4#

-- | Reads vector; offset in scalar elements. 

readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# s -> (# State# s,Word8X64# #)
readWord8OffAddrAsWord8X64# = readWord8OffAddrAsWord8X64#

-- | Reads vector; offset in scalar elements. 

readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# s -> (# State# s,Word16X32# #)
readWord16OffAddrAsWord16X32# = readWord16OffAddrAsWord16X32#

-- | Reads vector; offset in scalar elements. 

readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# s -> (# State# s,Word32X16# #)
readWord32OffAddrAsWord32X16# = readWord32OffAddrAsWord32X16#

-- | Reads vector; offset in scalar elements. 

readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# s -> (# State# s,Word64X8# #)
readWord64OffAddrAsWord64X8# = readWord64OffAddrAsWord64X8#

-- | Reads vector; offset in scalar elements. 

readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# s -> (# State# s,FloatX4# #)
readFloatOffAddrAsFloatX4# = readFloatOffAddrAsFloatX4#

-- | Reads vector; offset in scalar elements. 

readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# s -> (# State# s,DoubleX2# #)
readDoubleOffAddrAsDoubleX2# = readDoubleOffAddrAsDoubleX2#

-- | Reads vector; offset in scalar elements. 

readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# s -> (# State# s,FloatX8# #)
readFloatOffAddrAsFloatX8# = readFloatOffAddrAsFloatX8#

-- | Reads vector; offset in scalar elements. 

readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# s -> (# State# s,DoubleX4# #)
readDoubleOffAddrAsDoubleX4# = readDoubleOffAddrAsDoubleX4#

-- | Reads vector; offset in scalar elements. 

readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# s -> (# State# s,FloatX16# #)
readFloatOffAddrAsFloatX16# = readFloatOffAddrAsFloatX16#

-- | Reads vector; offset in scalar elements. 

readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# s -> (# State# s,DoubleX8# #)
readDoubleOffAddrAsDoubleX8# = readDoubleOffAddrAsDoubleX8#

-- | Write vector; offset in scalar elements. 

writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s
writeInt8OffAddrAsInt8X16# = writeInt8OffAddrAsInt8X16#

-- | Write vector; offset in scalar elements. 

writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s
writeInt16OffAddrAsInt16X8# = writeInt16OffAddrAsInt16X8#

-- | Write vector; offset in scalar elements. 

writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s
writeInt32OffAddrAsInt32X4# = writeInt32OffAddrAsInt32X4#

-- | Write vector; offset in scalar elements. 

writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s
writeInt64OffAddrAsInt64X2# = writeInt64OffAddrAsInt64X2#

-- | Write vector; offset in scalar elements. 

writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s
writeInt8OffAddrAsInt8X32# = writeInt8OffAddrAsInt8X32#

-- | Write vector; offset in scalar elements. 

writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s
writeInt16OffAddrAsInt16X16# = writeInt16OffAddrAsInt16X16#

-- | Write vector; offset in scalar elements. 

writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s
writeInt32OffAddrAsInt32X8# = writeInt32OffAddrAsInt32X8#

-- | Write vector; offset in scalar elements. 

writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s
writeInt64OffAddrAsInt64X4# = writeInt64OffAddrAsInt64X4#

-- | Write vector; offset in scalar elements. 

writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s
writeInt8OffAddrAsInt8X64# = writeInt8OffAddrAsInt8X64#

-- | Write vector; offset in scalar elements. 

writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s
writeInt16OffAddrAsInt16X32# = writeInt16OffAddrAsInt16X32#

-- | Write vector; offset in scalar elements. 

writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s
writeInt32OffAddrAsInt32X16# = writeInt32OffAddrAsInt32X16#

-- | Write vector; offset in scalar elements. 

writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s
writeInt64OffAddrAsInt64X8# = writeInt64OffAddrAsInt64X8#

-- | Write vector; offset in scalar elements. 

writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s
writeWord8OffAddrAsWord8X16# = writeWord8OffAddrAsWord8X16#

-- | Write vector; offset in scalar elements. 

writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s
writeWord16OffAddrAsWord16X8# = writeWord16OffAddrAsWord16X8#

-- | Write vector; offset in scalar elements. 

writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s
writeWord32OffAddrAsWord32X4# = writeWord32OffAddrAsWord32X4#

-- | Write vector; offset in scalar elements. 

writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s
writeWord64OffAddrAsWord64X2# = writeWord64OffAddrAsWord64X2#

-- | Write vector; offset in scalar elements. 

writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s
writeWord8OffAddrAsWord8X32# = writeWord8OffAddrAsWord8X32#

-- | Write vector; offset in scalar elements. 

writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s
writeWord16OffAddrAsWord16X16# = writeWord16OffAddrAsWord16X16#

-- | Write vector; offset in scalar elements. 

writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s
writeWord32OffAddrAsWord32X8# = writeWord32OffAddrAsWord32X8#

-- | Write vector; offset in scalar elements. 

writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s
writeWord64OffAddrAsWord64X4# = writeWord64OffAddrAsWord64X4#

-- | Write vector; offset in scalar elements. 

writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s
writeWord8OffAddrAsWord8X64# = writeWord8OffAddrAsWord8X64#

-- | Write vector; offset in scalar elements. 

writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s
writeWord16OffAddrAsWord16X32# = writeWord16OffAddrAsWord16X32#

-- | Write vector; offset in scalar elements. 

writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s
writeWord32OffAddrAsWord32X16# = writeWord32OffAddrAsWord32X16#

-- | Write vector; offset in scalar elements. 

writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s
writeWord64OffAddrAsWord64X8# = writeWord64OffAddrAsWord64X8#

-- | Write vector; offset in scalar elements. 

writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s
writeFloatOffAddrAsFloatX4# = writeFloatOffAddrAsFloatX4#

-- | Write vector; offset in scalar elements. 

writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s
writeDoubleOffAddrAsDoubleX2# = writeDoubleOffAddrAsDoubleX2#

-- | Write vector; offset in scalar elements. 

writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s
writeFloatOffAddrAsFloatX8# = writeFloatOffAddrAsFloatX8#

-- | Write vector; offset in scalar elements. 

writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s
writeDoubleOffAddrAsDoubleX4# = writeDoubleOffAddrAsDoubleX4#

-- | Write vector; offset in scalar elements. 

writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s
writeFloatOffAddrAsFloatX16# = writeFloatOffAddrAsFloatX16#

-- | Write vector; offset in scalar elements. 

writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s
writeDoubleOffAddrAsDoubleX8# = writeDoubleOffAddrAsDoubleX8#

prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchByteArray3# = prefetchByteArray3#

prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchMutableByteArray3# = prefetchMutableByteArray3#

prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchAddr3# = prefetchAddr3#

prefetchValue3# :: a -> State# s -> State# s
prefetchValue3# = prefetchValue3#

prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchByteArray2# = prefetchByteArray2#

prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchMutableByteArray2# = prefetchMutableByteArray2#

prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchAddr2# = prefetchAddr2#

prefetchValue2# :: a -> State# s -> State# s
prefetchValue2# = prefetchValue2#

prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchByteArray1# = prefetchByteArray1#

prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchMutableByteArray1# = prefetchMutableByteArray1#

prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchAddr1# = prefetchAddr1#

prefetchValue1# :: a -> State# s -> State# s
prefetchValue1# = prefetchValue1#

prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchByteArray0# = prefetchByteArray0#

prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchMutableByteArray0# = prefetchMutableByteArray0#

prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchAddr0# = prefetchAddr0#

prefetchValue0# :: a -> State# s -> State# s
prefetchValue0# = prefetchValue0#
